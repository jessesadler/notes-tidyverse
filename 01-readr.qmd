---
date: "2023-03-15"
date-modified: last-modified
---

# readr {#sec-readr}

```{r}
#| label: common.r
#| echo: false
source("_common.R")
```

## `readr` resources {#sec-resources}

- [`readr` website](https://readr.tidyverse.org/index.html)
- [R for Data Science, Chapter 8: Data Import](https://r4ds.hadley.nz/data-import.html)
- [Introduction to readr vignette](https://readr.tidyverse.org/articles/readr.html)

```{r}
#| label: setup
#| message: false
library(readr)
```

The primary task of `readr` is to parse a flat, plain-text file into a data frame in which each column is cast into the correct type. Parsing takes place in three basic stages:

1. The flat file is parsed into a rectangular matrix of strings.
2. The type of each column is determined.
3. Each column of strings is parsed into a vector of a more specific type.

## Overview {#sec-overview}

The `read_*` functions work by first calling the respective `spec_*` function, as described in @sec-specs, which uses `guess_parser()` on each column and casts the character vectors to the specified types using the `parse_*` functions as described in @sec-parsers. Use `spec()` after the csv is read in to see all of the column types, or `spec_csv()` to see the column specifications before reading in the data. This is particularly useful with very wide data.

```{r}
#| label: read_csv
# Read in data
df <- read_csv(readr_example("mini-gapminder-americas.csv"))
df

# See full column specification
spec(df)
```

### Overriding the defaults {#sec-overriding}

One of the main aspects of working with `readr` is the ability to override the default column specifications. One way to start the process of overriding the defaults is to copy the code output generated by `spec()`.

Override default column types with `col_types` argument in three ways:

1. With a compact string representation where each character represents one column: `"dcnf"`
2. With a named list using `col_*` functions
3. With a names list using character abbreviations of types

Columns not specified will be parsed automatically. You can skip columns to not import them with `col_skip()`. Alternatively, you can only read in the columns that you specify with `cols_only()` instead of a named list. You can also set a default type for columns through the `.default` argument in the named list.

### Chickens example {#sec-chickens}

Here is a simple example of reading in a column as a factor instead of a character and integer instead of double. Use of `spec_csv()` to only show the column types.

```{r}
#| label: chicken
# 1. Compact method
read_csv(readr_example("chickens.csv"), col_types = "cfic")

# 2. col_* functions
spec_csv(readr_example("chickens.csv"), col_types = list(
  sex = col_factor(c("hen", "rooster")),
  eggs_laid = col_integer()
))

# 3. list with abbreviations
spec_csv(readr_example("chickens.csv"), col_types = list(
  sex = "f",
  eggs_laid = "i"
))
```

Notice that the `col_*` functions method is the most explicit and provides the most flexibility to provide additional parameters such as specifying the levels of a factor of a date format.

### Available column specifications {#sec-col-specs}

| Function                      | Abbreviated string |
|-------------------------------|--------------------|
| `col_logical()`               | `"l"`              |
| `col_integer()`               | `"i"`              |
| `col_double()`                | `"d"`              |
| `col_character()`             | `"c"`              |
| `col_factor(levels, ordered)` | `"f"`              |
| `col_date(format = "")`       | `"D"`              |
| `col_time(format = "")`       | `"t"`              |
| `col_datetime(format = "")`   | `"T"`              |
| `col_number()`                | `"n"`              |
| `col_skip()`                  | `"_"` or `"-"`     |
| `col_guess()`                 | `"?"`              |

## Example data {#sec-ex-data}
I have created some example data in [Appendix -@sec-exdata] that provides a good overview of the different data formats that might be encountered and how to deal with them. Consult the [data key](readr-data.qmd#key) to see how columns should be parsed.

Start by seeing how it does by default with `guess_parser()` using `spec_csv()` and what the data looks like:

```{r}
#| label: ex-spec
# Data
read_csv("data/readr-example.csv", show_col_types = FALSE)

# Column specifications
spec_csv("data/readr-example.csv")
```

The parser generally does well. Columns `a`, `b`, `c`, and `d` are all completely correct, including identifying `NA` values in column `b`, but there are some issues to deal with in columns `e`, `f`, and `g`.

### Overriding guesses
To override the guesses from `guess_parser()` we can use `col_*` functions to be more specific, turning `character()` into `factor()` (@sec-factors) and `double()` to `integer()` (@sec-vctrs). Use `col_number()` to properly read in values such as $42,498.74 as numeric (@sec-number). Can also add "none" to the `na` argument to turn "none" into `NA` in column `e`. Use of `col_only()` only reads in the specified columns.

```{r}
#| label: ex-integer-factor
read_csv("data/readr-example.csv", 
         na = c("", "NA", "none"), # Add none as NA in b
         col_types = cols_only(
  e = col_factor(c("hello", "goodbye", "kook", "gnarly")),
  f = col_integer(),
  g = col_number()
))
```

### Dealing with dates {#sec-dates}
Dealing with dates often requires the use of a date format in `col_date()`, `col_time()`, and `col_datetime()` functions. Columns `i` and `m` are correctly specified as `date` and `datetime` because they follow the formats in `locale()`. See @sec-datetime for details.

```{r}
#| label: ex-dates
read_csv("data/readr-example.csv", col_types = cols_only(
  h = col_date("%Y%m%d"), # date as 8 digit number (20230316)
  i = col_date(), # date in locale (2023-03-16)
  j = col_date("%d %B %Y"), # 16 March 2023
  k = col_date("%b %d %Y"), # Mar 16 2023
  l = col_time("%h"), # time
  m = col_datetime() # datetime in locale (2023-03-16 11:49)
))
```

## Vector parsers {#sec-parsers}

Parse character vectors and return specified vector types with `parse_*` functions.

### Atomic vectors {#sec-vctrs}

`parse_logical()`, `parse_integer()`, `parse_double()`, and `parse_character()` are straightforward parsers that produce the corresponding atomic vector.

```{r}
#| label: atomic-vectors
parse_double(c("1.56", "2.34", "3.56"))

class(parse_integer(c("1", "2", "3")))

parse_logical(c("true", "false"))
```

### Flexible numeric parser {#sec-number}

`parse_number()` is more flexible than `parse_double()`; it allows non-numeric prefixes and suffixes, and knows how to deal with grouping marks.

```{r}
#| label: parse_number
parse_number(c("0%", "10%", "150%"))

parse_number(c("$1,234.5", "$12.45"))
```

### Date-times {#sec-datetime}

`readr` supports three types of date-times, which all take a `format` argument to define how the date-time is formatted:

- dates: number of days since 1970-01-01
    - `parse_date()` uses the `date_format` specified by the `locale()`. The default value is `%AD` which uses an automatic date parser that recognizes dates of the format `Y-m-d` or `Y/m/d`.
- times: number of seconds since midnight
    - `parse_time()` uses the `time_format` specified by `locale()`. The default value is `%At` which uses an automatic time parser that recognizes times of the form `H:M` optionally followed by seconds and am/pm.
- datetimes: number of seconds since midnight 1970-01-01
    - Recognizes [ISO8601](https://en.wikipedia.org/wiki/ISO_8601) datetimes.

Parsing dates with default formats:

```{r}
#| label: default-datetimes
parse_date("2010-10-01")
parse_time("1:00pm")
parse_datetime("2010-10-01 21:45")
```

See the default formats with `locale()`

```{r}
#| label: locale
locale()
```

In most cases you will need to supply a `format` for date and datetime. See [date format specifications](https://readr.tidyverse.org/reference/parse_datetime.html).

- Year: `"%Y"` (4 digits); `"%y"` (2 digits)
- Month: `"%m"` (2 digits), `"%b"` (abbreviated name), `"%B"` (full name)
- Day: `"%d"` (2 digits), `"%e"` (optional leading space), `"%a"` (abbreviated name)
- Hour: `"%H"`, or `"%I"` with AM/PM, or "%h" if times represent durations longer than one day.
- Minutes: `"%M"`
- Seconds: `"%S"` (integer seconds), `"%OS"` (partial seconds)
- Time zone: `"%Z"` (as name, e.g. "America/Chicago"), `"%z"` (as offset from UTC, e.g. "+0800")
- AM/PM indicator: "%p"
- Shortcuts:
    - `"%D"` = `"%m/%d/%y"`
    - `"%F"` = `"%Y-%m-%d"`
    - `"%R"` = `"%H:%M"`
    - `"%T"` = `"%H:%M:%S"`
    - `"%x"` = `"%y/%m/%d"`

```{r}
#| label: datetimes
parse_date("1 January, 2020", "%d %B, %Y")
parse_date("20230315", "%Y%m%d")
parse_datetime("02/02/23", "%m/%d/%y")
```

### Factors {#sec-factors}

`readr` does not parse characters as factors. Use `parse_factor()` with optional argument for `levels`. If `levels` is `NULL`, they are discovered from unique values in the supplied character vector.

```{r}
#| label: factors
parse_factor(c("a", "b", "a"), levels = c("a", "b", "c"))
parse_factor(c("a", "b", "a"))
```

## Column specification {#sec-specs}

`readr` works by guessing which parser to use for each column. You can access the results using `guess_parser()`.

```{r}
#| label: guess
guess_parser(c("1", "2", "3"))
guess_parser(c("1,000", "2,000", "3,000"))
guess_parser(c("2001/10/10"))
```

Use `spec_csv()` and others to see the specification that `readr` would generate for columns in a file.

```{r}
#| label: spec_csv
spec_csv(readr_example("challenge.csv"))
```

Use `spec()` to see the specifications that `readr` used when reading in a tibble from a flat file.

```{r}
#| label: spec
df <- read_csv(readr_example("mtcars.csv"))

spec(df)
```

`readr` uses the first 1000 rows to guess the column type to speed up the reading process. You can change the number of rows used with `guess_max`. Note the difference with `challenge.csv` with `y` going from logical to date.

```{r}
#| label: challenge
spec_csv(readr_example("challenge.csv"))
spec_csv(readr_example("challenge.csv"), guess_max = 1001)
```
