[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "tidyverse notes",
    "section": "",
    "text": "Welcome\nThis is a Quarto notebook that contains notes I have taken on tidyverse and tidyverse-adjacent packages and programming resources for working with R.",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "01-pipe.html",
    "href": "01-pipe.html",
    "title": "1  Pipe: magrittr and native",
    "section": "",
    "text": "1.1 Resources\nlibrary(dplyr)\nlibrary(purrr)",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Pipe: magrittr and native</span>"
    ]
  },
  {
    "objectID": "01-pipe.html#resources",
    "href": "01-pipe.html#resources",
    "title": "1  Pipe: magrittr and native",
    "section": "",
    "text": "magrittr package\nRelease of R 4.1\nThe (updated) history of the pipe operator in R\nSimpler R coding with pipes &gt; the present and future of the magrittr package – 5 August 2014\nDifferences between the base R and magrittr pipes\nIsabella Velásquez - Understanding the native R pipe |&gt;\nTim Tiefenbach - Why continue to use magrittr pipe – 17 October 2022",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Pipe: magrittr and native</span>"
    ]
  },
  {
    "objectID": "01-pipe.html#sec-native-pipe",
    "href": "01-pipe.html#sec-native-pipe",
    "title": "1  Pipe: magrittr and native",
    "section": "\n1.2 Native pipe",
    "text": "1.2 Native pipe\n\nThe native pipe was introduced in R 4.1 alongside the use of new anonymous function syntax.\nPipe the left-hand side into the first argument of the right-hand side. In normal usage, it works almost exactly like the magrittr pipe.\nIn R 4.2 the native pipe got the _ syntax to insert the left-hand side into a named argument of the right-hand side function. However, this functionality is not as powerful as in %&gt;%, see Section 1.3.\n\nThe tidyverse style guidelines are moving over to the usage of the native pipe. The native pipe is used for all examples in the Second Edition of R for Data Science. Hadley discusses the move to the native pipe in Documentation in the release notes for purrr 1.0.0. There, he notes the advantages of the greater simplicity of the native pipe and the clarity provided by anonymous functions, see Section 1.2.2.\n\n1.2.1 Usage\nThe pipe operator is implemented as a syntax transformation.\n\nquote(mtcars |&gt; subset(cyl == 4) |&gt; nrow())\n#&gt; nrow(subset(mtcars, cyl == 4))\n\nLike the magrittr pipe, the native pipe places the left-hand side into the first argument of the right hand side.\n\nmtcars |&gt; filter(cyl == 4) |&gt; head()\n#&gt;                 mpg cyl  disp hp drat    wt  qsec vs am gear carb\n#&gt; Datsun 710     22.8   4 108.0 93 3.85 2.320 18.61  1  1    4    1\n#&gt; Merc 240D      24.4   4 146.7 62 3.69 3.190 20.00  1  0    4    2\n#&gt; Merc 230       22.8   4 140.8 95 3.92 3.150 22.90  1  0    4    2\n#&gt; Fiat 128       32.4   4  78.7 66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic    30.4   4  75.7 52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla 33.9   4  71.1 65 4.22 1.835 19.90  1  1    4    1\n\nThere are two ways to place the left-hand side elsewhere in the right-hand side function: anonymous functions and _ placeholder\n\n1.2.2 The pipe and the anonymous function\nThe pipe and the new shorthand syntax for the anonymous function both debuted with R 4.1.\n\nmtcars |&gt; subset(cyl == 4) |&gt; (\\(x) lm(mpg ~ disp, data = x))()\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = mpg ~ disp, data = x)\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)         disp  \n#&gt;     40.8720      -0.1351\n\nExample of using anonymous function to make code more clear taken from purrr 1.0.0 release. This is part of the move away from formula notation (~) to anonymous function.\n\n# Previously\n1:5 %&gt;%\n  map(~ rnorm(10, .x)) %&gt;%\n  map_dbl(mean)\n#&gt; [1] 0.6989054 2.1852344 2.9494400 3.3351719 4.6173895\n\n# Use of anonymous function\n1:5 |&gt;\n  map(\\(x) rnorm(10, x)) |&gt;\n  map_dbl(mean) \n#&gt; [1] 1.447187 1.826487 2.715834 3.273295 5.036881\n\n\n1.2.3 Underscore placeholder\nThe _ placeholder is similar to magrittr . placeholder. However, the _ placeholder can only be used once and must be used with a named argument. See Section 1.3 for examples of these limitations. Nevertheless, the _ placeholder does cover most use cases.\n\nmtcars |&gt; subset(cyl == 4) |&gt; lm(mpg ~ disp, data = _)\n#&gt; \n#&gt; Call:\n#&gt; lm(formula = mpg ~ disp, data = subset(mtcars, cyl == 4))\n#&gt; \n#&gt; Coefficients:\n#&gt; (Intercept)         disp  \n#&gt;     40.8720      -0.1351\n\nIn R 4.3 the _ placeholder can be used with extraction functions $, or as the head of a chain of extractions [, [[, or @. However, it cannot be used with [[ to start the extraction as in case 4 of the magrittr pipe below.\n\nmtcars |&gt; _$cyl\n#&gt;  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4\nmtcars |&gt; subset(cyl == 4) |&gt; lm(mpg ~ disp, data = _) |&gt; _$coef[[2]]\n#&gt; [1] -0.1351418",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Pipe: magrittr and native</span>"
    ]
  },
  {
    "objectID": "01-pipe.html#sec-magrittr",
    "href": "01-pipe.html#sec-magrittr",
    "title": "1  Pipe: magrittr and native",
    "section": "\n1.3 The magrittr pipe",
    "text": "1.3 The magrittr pipe\nUses of the magrittr . notation that are easier or not possible with the native pipe.\n\nUse of . in unnamed arguments\n\n\nc(1:3) %&gt;% paste(\"No\", .)\n#&gt; [1] \"No 1\" \"No 2\" \"No 3\"\n\n\nUse of multiple . in right-hand side\n\n\nc(1:3) %&gt;% paste(., \"No\", .)\n#&gt; [1] \"1 No 1\" \"2 No 2\" \"3 No 3\"\n\n# Need anonymous function with native pipe\nc(1:3) |&gt; (\\(x) paste(x, \"No\", x))()\n#&gt; [1] \"1 No 1\" \"2 No 2\" \"3 No 3\"\n\n\nUse of . in nested functions\n\n\niris %&gt;% \n  bind_rows(mutate(., Species = \"all\")) %&gt;% \n  count(Species)\n#&gt;      Species   n\n#&gt; 1        all 150\n#&gt; 2     setosa  50\n#&gt; 3 versicolor  50\n#&gt; 4  virginica  50\n\n\nUse of . with infix operators on left- and right-hand side\n\n\nmtcars %&gt;% `[[`(\"cyl\")\n#&gt;  [1] 6 6 4 6 8 6 8 4 4 6 6 8 8 8 8 8 8 4 4 4 4 8 8 8 8 4 4 4 8 6 8 4",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Pipe: magrittr and native</span>"
    ]
  },
  {
    "objectID": "01-readr.html",
    "href": "01-readr.html",
    "title": "2  readr",
    "section": "",
    "text": "2.1 readr resources\nlibrary(readr)\nThe primary task of readr is to parse a flat, plain-text file into a data frame in which each column is cast into the correct type. Parsing takes place in three basic stages:",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>readr</span>"
    ]
  },
  {
    "objectID": "01-readr.html#sec-resources",
    "href": "01-readr.html#sec-resources",
    "title": "2  readr",
    "section": "",
    "text": "readr website\nR for Data Science, Chapter 8: Data Import\nIntroduction to readr vignette\n\n\n\n\nThe flat file is parsed into a rectangular matrix of strings.\nThe type of each column is determined.\nEach column of strings is parsed into a vector of a more specific type.",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>readr</span>"
    ]
  },
  {
    "objectID": "01-readr.html#sec-overview",
    "href": "01-readr.html#sec-overview",
    "title": "2  readr",
    "section": "\n2.2 Overview",
    "text": "2.2 Overview\nThe read_* functions work by first calling the respective spec_* function, as described in Section 10.4, which uses guess_parser() on each column and casts the character vectors to the specified types using the parse_* functions as described in Section 2.4. Use spec() after the csv is read in to see all of the column types, or spec_csv() to see the column specifications before reading in the data. This is particularly useful with very wide data.\n\n# Read in data\ndf &lt;- read_csv(readr_example(\"mini-gapminder-americas.csv\"))\n#&gt; Rows: 6 Columns: 5\n#&gt; ── Column specification ────────────────────────────────────────────────────────\n#&gt; Delimiter: \",\"\n#&gt; chr (1): country\n#&gt; dbl (4): year, lifeExp, pop, gdpPercap\n#&gt; \n#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\ndf\n#&gt; # A tibble: 6 × 5\n#&gt;   country    year lifeExp      pop gdpPercap\n#&gt;   &lt;chr&gt;     &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;\n#&gt; 1 Argentina  1952    62.5 17876956     5911.\n#&gt; 2 Bolivia    1952    40.4  2883315     2677.\n#&gt; 3 Brazil     1952    50.9 56602560     2109.\n#&gt; 4 Canada     1952    68.8 14785584    11367.\n#&gt; 5 Chile      1952    54.7  6377619     3940.\n#&gt; 6 Colombia   1952    50.6 12350771     2144.\n\n# See full column specification\nspec(df)\n#&gt; cols(\n#&gt;   country = col_character(),\n#&gt;   year = col_double(),\n#&gt;   lifeExp = col_double(),\n#&gt;   pop = col_double(),\n#&gt;   gdpPercap = col_double()\n#&gt; )\n\n\n2.2.1 Overriding the defaults\nOne of the main aspects of working with readr is the ability to override the default column specifications. One way to start the process of overriding the defaults is to copy the code output generated by spec().\nOverride default column types with col_types argument in three ways:\n\nWith a compact string representation where each character represents one column: \"dcnf\"\n\nWith a named list using col_* functions\nWith a names list using character abbreviations of types\n\nColumns not specified will be parsed automatically. You can skip columns to not import them with col_skip(). Alternatively, you can only read in the columns that you specify with cols_only() instead of a named list. You can also set a default type for columns through the .default argument in the named list.\n\n2.2.2 Chickens example\nHere is a simple example of reading in a column as a factor instead of a character and integer instead of double. Use of spec_csv() to only show the column types.\n\n# 1. Compact method\nread_csv(readr_example(\"chickens.csv\"), col_types = \"cfic\")\n#&gt; # A tibble: 5 × 4\n#&gt;   chicken                 sex     eggs_laid motto                               \n#&gt;   &lt;chr&gt;                   &lt;fct&gt;       &lt;int&gt; &lt;chr&gt;                               \n#&gt; 1 Foghorn Leghorn         rooster         0 That's a joke, ah say, that's a jok…\n#&gt; 2 Chicken Little          hen             3 The sky is falling!                 \n#&gt; 3 Ginger                  hen            12 Listen. We'll either die free chick…\n#&gt; 4 Camilla the Chicken     hen             7 Bawk, buck, ba-gawk.                \n#&gt; 5 Ernie The Giant Chicken rooster         0 Put Captain Solo in the cargo hold.\n\n# 2. col_* functions\nspec_csv(readr_example(\"chickens.csv\"), col_types = list(\n  sex = col_factor(c(\"hen\", \"rooster\")),\n  eggs_laid = col_integer()\n))\n#&gt; cols(\n#&gt;   chicken = col_character(),\n#&gt;   sex = col_factor(levels = c(\"hen\", \"rooster\"), ordered = FALSE, include_na = FALSE),\n#&gt;   eggs_laid = col_integer(),\n#&gt;   motto = col_character()\n#&gt; )\n\n# 3. list with abbreviations\nspec_csv(readr_example(\"chickens.csv\"), col_types = list(\n  sex = \"f\",\n  eggs_laid = \"i\"\n))\n#&gt; cols(\n#&gt;   chicken = col_character(),\n#&gt;   sex = col_factor(levels = NULL, ordered = FALSE, include_na = FALSE),\n#&gt;   eggs_laid = col_integer(),\n#&gt;   motto = col_character()\n#&gt; )\n\nNotice that the col_* functions method is the most explicit and provides the most flexibility to provide additional parameters such as specifying the levels of a factor of a date format.\n\n2.2.3 Available column specifications\n\n\nFunction\nAbbreviated string\n\n\n\ncol_logical()\n\"l\"\n\n\ncol_integer()\n\"i\"\n\n\ncol_double()\n\"d\"\n\n\ncol_character()\n\"c\"\n\n\ncol_factor(levels, ordered)\n\"f\"\n\n\ncol_date(format = \"\")\n\"D\"\n\n\ncol_time(format = \"\")\n\"t\"\n\n\ncol_datetime(format = \"\")\n\"T\"\n\n\ncol_number()\n\"n\"\n\n\ncol_skip()\n\n\"_\" or \"-\"\n\n\n\ncol_guess()\n\"?\"",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>readr</span>"
    ]
  },
  {
    "objectID": "01-readr.html#sec-ex-data",
    "href": "01-readr.html#sec-ex-data",
    "title": "2  readr",
    "section": "\n2.3 Example data",
    "text": "2.3 Example data\nI have created some example data in Appendix A that provides a good overview of the different data formats that might be encountered and how to deal with them. Consult the data key to see how columns should be parsed.\nStart by seeing how it does by default with guess_parser() using spec_csv() and what the data looks like:\n\n# Data\nread_csv(\"data/readr-example.csv\", show_col_types = FALSE)\n#&gt; # A tibble: 50 × 13\n#&gt;    a     b         c d     e           f g              h i          j     k    \n#&gt;    &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;chr&gt;      &lt;dbl&gt; &lt;date&gt;     &lt;chr&gt; &lt;chr&gt;\n#&gt;  1 p     b      95.2 TRUE  gnarly     48 $42,498.… 1.47e7 1585-05-06 20 J… Feb …\n#&gt;  2 x     b      71.1 FALSE none       36 $141,971… 1.58e7 1366-12-10 23 A… Jun …\n#&gt;  3 e     d      15.6 FALSE kook       35 $15,852.… 1.55e7 1606-06-05 4 Ju… Sep …\n#&gt;  4 o     b      57.6 TRUE  kook       46 $66,555.… 1.46e7 1675-01-14 20 O… Dec …\n#&gt;  5 v     d      91.1 TRUE  hello      23 $143,747… 1.35e7 1400-05-12 27 J… Oct …\n#&gt;  6 r     d      40.0 TRUE  gnarly     36 $46,013.… 1.34e7 1578-09-14 26 J… Nov …\n#&gt;  7 h     &lt;NA&gt;   70.8 TRUE  gnarly     43 $126,686… 1.32e7 1492-08-28 5 No… Aug …\n#&gt;  8 p     e      82.0 TRUE  goodbye    43 $85,459.… 1.37e7 1214-10-11 17 F… Feb …\n#&gt;  9 u     &lt;NA&gt;   96.9 FALSE hello      37 $143,002… 1.56e7 1310-10-12 27 O… Nov …\n#&gt; 10 i     d      12.1 FALSE hello      48 $162,345… 1.61e7 1299-01-20 25 S… Aug …\n#&gt; # ℹ 40 more rows\n#&gt; # ℹ 2 more variables: l &lt;dbl&gt;, m &lt;dttm&gt;\n\n# Column specifications\nspec_csv(\"data/readr-example.csv\")\n#&gt; cols(\n#&gt;   a = col_character(),\n#&gt;   b = col_character(),\n#&gt;   c = col_double(),\n#&gt;   d = col_logical(),\n#&gt;   e = col_character(),\n#&gt;   f = col_double(),\n#&gt;   g = col_character(),\n#&gt;   h = col_double(),\n#&gt;   i = col_date(format = \"\"),\n#&gt;   j = col_character(),\n#&gt;   k = col_character(),\n#&gt;   l = col_double(),\n#&gt;   m = col_datetime(format = \"\")\n#&gt; )\n\nThe parser generally does well. Columns a, b, c, and d are all completely correct, including identifying NA values in column b, but there are some issues to deal with in columns e, f, and g.\n\n2.3.1 Overriding guesses\nTo override the guesses from guess_parser() we can use col_* functions to be more specific, turning character() into factor() (Section 2.4.4) and double() to integer() (Section 2.4.1). Use col_number() to properly read in values such as $42,498.74 as numeric (Section 2.4.2). Can also add “none” to the na argument to turn “none” into NA in column e. Use of col_only() only reads in the specified columns.\n\nread_csv(\"data/readr-example.csv\", \n         na = c(\"\", \"NA\", \"none\"), # Add none as NA in b\n         col_types = cols_only(\n  e = col_factor(c(\"hello\", \"goodbye\", \"kook\", \"gnarly\")),\n  f = col_integer(),\n  g = col_number()\n))\n#&gt; # A tibble: 50 × 3\n#&gt;    e           f       g\n#&gt;    &lt;fct&gt;   &lt;int&gt;   &lt;dbl&gt;\n#&gt;  1 gnarly     48  42499.\n#&gt;  2 &lt;NA&gt;       36 141972.\n#&gt;  3 kook       35  15853.\n#&gt;  4 kook       46  66555.\n#&gt;  5 hello      23 143748.\n#&gt;  6 gnarly     36  46013.\n#&gt;  7 gnarly     43 126687.\n#&gt;  8 goodbye    43  85460.\n#&gt;  9 hello      37 143003.\n#&gt; 10 hello      48 162346.\n#&gt; # ℹ 40 more rows\n\n\n2.3.2 Dealing with dates\nDealing with dates often requires the use of a date format in col_date(), col_time(), and col_datetime() functions. Columns i and m are correctly specified as date and datetime because they follow the formats in locale(). See Section 2.4.3 for details.\n\nread_csv(\"data/readr-example.csv\", col_types = cols_only(\n  h = col_date(\"%Y%m%d\"), # date as 8 digit number (20230316)\n  i = col_date(), # date in locale (2023-03-16)\n  j = col_date(\"%d %B %Y\"), # 16 March 2023\n  k = col_date(\"%b %d %Y\"), # Mar 16 2023\n  l = col_time(\"%h\"), # time\n  m = col_datetime() # datetime in locale (2023-03-16 11:49)\n))\n#&gt; # A tibble: 50 × 6\n#&gt;    h          i          j          k          l         m                  \n#&gt;    &lt;date&gt;     &lt;date&gt;     &lt;date&gt;     &lt;date&gt;     &lt;time&gt;    &lt;dttm&gt;             \n#&gt;  1 1465-12-20 1585-05-06 1503-01-20 1313-02-04 150248:00 2023-05-16 02:57:00\n#&gt;  2 1582-09-13 1366-12-10 1390-04-23 1553-06-17 197379:00 2023-04-28 23:26:00\n#&gt;  3 1546-08-15 1606-06-05 1585-07-04 1299-09-18 101224:00 2023-09-22 13:17:00\n#&gt;  4 1463-11-27 1675-01-14 1237-10-20 1558-12-01 225648:00 2023-02-27 07:48:00\n#&gt;  5 1352-03-26 1400-05-12 1394-07-27 1297-10-21 300957:00 2023-02-11 17:22:00\n#&gt;  6 1335-05-25 1578-09-14 1593-07-26 1621-11-23  43411:00 2023-06-02 06:30:00\n#&gt;  7 1315-03-20 1492-08-28 1237-11-05 1681-08-09 317706:00 2023-07-26 12:09:00\n#&gt;  8 1370-01-09 1214-10-11 1650-02-17 1301-02-28 224552:00 2023-06-26 01:25:00\n#&gt;  9 1562-05-23 1310-10-12 1660-10-27 1524-11-08  48277:00 2023-12-25 14:20:00\n#&gt; 10 1608-06-21 1299-01-20 1263-09-25 1290-08-23 239288:00 2023-04-14 04:22:00\n#&gt; # ℹ 40 more rows",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>readr</span>"
    ]
  },
  {
    "objectID": "01-readr.html#sec-parsers",
    "href": "01-readr.html#sec-parsers",
    "title": "2  readr",
    "section": "\n2.4 Vector parsers",
    "text": "2.4 Vector parsers\nParse character vectors and return specified vector types with parse_* functions.\n\n2.4.1 Atomic vectors\nparse_logical(), parse_integer(), parse_double(), and parse_character() are straightforward parsers that produce the corresponding atomic vector.\n\nparse_double(c(\"1.56\", \"2.34\", \"3.56\"))\n#&gt; [1] 1.56 2.34 3.56\n\nclass(parse_integer(c(\"1\", \"2\", \"3\")))\n#&gt; [1] \"integer\"\n\nparse_logical(c(\"true\", \"false\"))\n#&gt; [1]  TRUE FALSE\n\n\n2.4.2 Flexible numeric parser\nparse_number() is more flexible than parse_double(); it allows non-numeric prefixes and suffixes, and knows how to deal with grouping marks.\n\nparse_number(c(\"0%\", \"10%\", \"150%\"))\n#&gt; [1]   0  10 150\n\nparse_number(c(\"$1,234.5\", \"$12.45\"))\n#&gt; [1] 1234.50   12.45\n\n\n2.4.3 Date-times\nreadr supports three types of date-times, which all take a format argument to define how the date-time is formatted:\n\ndates: number of days since 1970-01-01\n\n\nparse_date() uses the date_format specified by the locale(). The default value is %AD which uses an automatic date parser that recognizes dates of the format Y-m-d or Y/m/d.\n\n\ntimes: number of seconds since midnight\n\n\nparse_time() uses the time_format specified by locale(). The default value is %At which uses an automatic time parser that recognizes times of the form H:M optionally followed by seconds and am/pm.\n\n\ndatetimes: number of seconds since midnight 1970-01-01\n\nRecognizes ISO8601 datetimes.\n\n\n\nParsing dates with default formats:\n\nparse_date(\"2010-10-01\")\n#&gt; [1] \"2010-10-01\"\nparse_time(\"1:00pm\")\n#&gt; 13:00:00\nparse_datetime(\"2010-10-01 21:45\")\n#&gt; [1] \"2010-10-01 21:45:00 UTC\"\n\nSee the default formats with locale()\n\nlocale()\n#&gt; &lt;locale&gt;\n#&gt; Numbers:  123,456.78\n#&gt; Formats:  %AD / %AT\n#&gt; Timezone: UTC\n#&gt; Encoding: UTF-8\n#&gt; &lt;date_names&gt;\n#&gt; Days:   Sunday (Sun), Monday (Mon), Tuesday (Tue), Wednesday (Wed), Thursday\n#&gt;         (Thu), Friday (Fri), Saturday (Sat)\n#&gt; Months: January (Jan), February (Feb), March (Mar), April (Apr), May (May),\n#&gt;         June (Jun), July (Jul), August (Aug), September (Sep), October\n#&gt;         (Oct), November (Nov), December (Dec)\n#&gt; AM/PM:  AM/PM\n\nIn most cases you will need to supply a format for date and datetime. See date format specifications.\n\nYear: \"%Y\" (4 digits); \"%y\" (2 digits)\nMonth: \"%m\" (2 digits), \"%b\" (abbreviated name), \"%B\" (full name)\nDay: \"%d\" (2 digits), \"%e\" (optional leading space), \"%a\" (abbreviated name)\nHour: \"%H\", or \"%I\" with AM/PM, or “%h” if times represent durations longer than one day.\nMinutes: \"%M\"\n\nSeconds: \"%S\" (integer seconds), \"%OS\" (partial seconds)\nTime zone: \"%Z\" (as name, e.g. “America/Chicago”), \"%z\" (as offset from UTC, e.g. “+0800”)\nAM/PM indicator: “%p”\nShortcuts:\n\n\n\"%D\" = \"%m/%d/%y\"\n\n\n\"%F\" = \"%Y-%m-%d\"\n\n\n\"%R\" = \"%H:%M\"\n\n\n\"%T\" = \"%H:%M:%S\"\n\n\n\"%x\" = \"%y/%m/%d\"\n\n\n\n\n\nparse_date(\"1 January, 2020\", \"%d %B, %Y\")\n#&gt; [1] \"2020-01-01\"\nparse_date(\"20230315\", \"%Y%m%d\")\n#&gt; [1] \"2023-03-15\"\nparse_datetime(\"02/02/23\", \"%m/%d/%y\")\n#&gt; [1] \"2023-02-02 UTC\"\n\n\n2.4.4 Factors\nreadr does not parse characters as factors. Use parse_factor() with optional argument for levels. If levels is NULL, they are discovered from unique values in the supplied character vector.\n\nparse_factor(c(\"a\", \"b\", \"a\"), levels = c(\"a\", \"b\", \"c\"))\n#&gt; [1] a b a\n#&gt; Levels: a b c\nparse_factor(c(\"a\", \"b\", \"a\"))\n#&gt; [1] a b a\n#&gt; Levels: a b",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>readr</span>"
    ]
  },
  {
    "objectID": "01-readr.html#sec-specs",
    "href": "01-readr.html#sec-specs",
    "title": "2  readr",
    "section": "\n2.5 Column specification",
    "text": "2.5 Column specification\nreadr works by guessing which parser to use for each column. You can access the results using guess_parser().\n\nguess_parser(c(\"1\", \"2\", \"3\"))\n#&gt; [1] \"double\"\nguess_parser(c(\"1,000\", \"2,000\", \"3,000\"))\n#&gt; [1] \"number\"\nguess_parser(c(\"2001/10/10\"))\n#&gt; [1] \"date\"\n\nUse spec_csv() and others to see the specification that readr would generate for columns in a file.\n\nspec_csv(readr_example(\"challenge.csv\"))\n#&gt; cols(\n#&gt;   x = col_double(),\n#&gt;   y = col_logical()\n#&gt; )\n\nUse spec() to see the specifications that readr used when reading in a tibble from a flat file.\n\ndf &lt;- read_csv(readr_example(\"mtcars.csv\"))\n#&gt; Rows: 32 Columns: 11\n#&gt; ── Column specification ────────────────────────────────────────────────────────\n#&gt; Delimiter: \",\"\n#&gt; dbl (11): mpg, cyl, disp, hp, drat, wt, qsec, vs, am, gear, carb\n#&gt; \n#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nspec(df)\n#&gt; cols(\n#&gt;   mpg = col_double(),\n#&gt;   cyl = col_double(),\n#&gt;   disp = col_double(),\n#&gt;   hp = col_double(),\n#&gt;   drat = col_double(),\n#&gt;   wt = col_double(),\n#&gt;   qsec = col_double(),\n#&gt;   vs = col_double(),\n#&gt;   am = col_double(),\n#&gt;   gear = col_double(),\n#&gt;   carb = col_double()\n#&gt; )\n\nreadr uses the first 1000 rows to guess the column type to speed up the reading process. You can change the number of rows used with guess_max. Note the difference with challenge.csv with y going from logical to date.\n\nspec_csv(readr_example(\"challenge.csv\"))\n#&gt; cols(\n#&gt;   x = col_double(),\n#&gt;   y = col_logical()\n#&gt; )\nspec_csv(readr_example(\"challenge.csv\"), guess_max = 1001)\n#&gt; cols(\n#&gt;   x = col_double(),\n#&gt;   y = col_date(format = \"\")\n#&gt; )",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>readr</span>"
    ]
  },
  {
    "objectID": "01-dplyr-colwise.html",
    "href": "01-dplyr-colwise.html",
    "title": "3  dplyr: Column-wise operations",
    "section": "",
    "text": "3.1 Basic usage\nTwo main arguments of across()\nacross() uses tidyselect and so uses helper functions such as where(), starts_with() and can use c() to select multiple columns instead of the old function of vars().\nstarwars %&gt;% \n  summarise(across(where(is.character), n_distinct))\n#&gt; # A tibble: 1 × 8\n#&gt;    name hair_color skin_color eye_color   sex gender homeworld species\n#&gt;   &lt;int&gt;      &lt;int&gt;      &lt;int&gt;     &lt;int&gt; &lt;int&gt;  &lt;int&gt;     &lt;int&gt;   &lt;int&gt;\n#&gt; 1    87         12         31        15     5      3        49      38\n\nstarwars %&gt;% \n  summarise(across(c(sex, gender, homeworld), n_distinct))\n#&gt; # A tibble: 1 × 3\n#&gt;     sex gender homeworld\n#&gt;   &lt;int&gt;  &lt;int&gt;     &lt;int&gt;\n#&gt; 1     5      3        49\nYou can also apply a function with arguments, but with dplyr 1.1.0 you now need to use an anonymous function or lambda syntax.\nstarwars %&gt;% \n  group_by(homeworld) %&gt;% \n  filter(n() &gt; 1) %&gt;% \n  summarise(across(where(is.numeric), \\(x) mean(x, na.rm = TRUE)), n = n())\n#&gt; # A tibble: 10 × 5\n#&gt;    homeworld height  mass birth_year     n\n#&gt;    &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt; &lt;int&gt;\n#&gt;  1 Alderaan    176.  64         43       3\n#&gt;  2 Corellia    175   78.5       25       2\n#&gt;  3 Coruscant   174.  50         91       3\n#&gt;  4 Kamino      208.  83.1       31.5     3\n#&gt;  5 Kashyyyk    231  124        200       2\n#&gt;  6 Mirial      168   53.1       49       2\n#&gt;  7 Naboo       177.  64.2       55      11\n#&gt;  8 Ryloth      179   55         48       2\n#&gt;  9 Tatooine    170.  85.4       54.6    10\n#&gt; 10 &lt;NA&gt;        139.  82        334.     10",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>dplyr: Column-wise operations</span>"
    ]
  },
  {
    "objectID": "01-dplyr-colwise.html#sec-basic",
    "href": "01-dplyr-colwise.html#sec-basic",
    "title": "3  dplyr: Column-wise operations",
    "section": "",
    "text": ".cols: selects the columns you want to operate on using tidy select syntax.\n\n.fns: a function or list of functions to apply to each column.",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>dplyr: Column-wise operations</span>"
    ]
  },
  {
    "objectID": "01-dplyr-colwise.html#sec-multi-funcs",
    "href": "01-dplyr-colwise.html#sec-multi-funcs",
    "title": "3  dplyr: Column-wise operations",
    "section": "\n3.2 Multiple functions",
    "text": "3.2 Multiple functions\nYou can transform each variable with more than one function by supplying a named list of functions, lambda functions, or anonymous functions in the second argument.\n\nmin_max &lt;- list(\n  min = \\(x) min(x, na.rm = TRUE),\n  max = \\(x) max(x, na.rm = TRUE)\n)\nstarwars %&gt;% \n  summarise(across(where(is.numeric), min_max))\n#&gt; # A tibble: 1 × 6\n#&gt;   height_min height_max mass_min mass_max birth_year_min birth_year_max\n#&gt;        &lt;int&gt;      &lt;int&gt;    &lt;dbl&gt;    &lt;dbl&gt;          &lt;dbl&gt;          &lt;dbl&gt;\n#&gt; 1         66        264       15     1358              8            896\n\nYou can control the names created for the columns with the .names argument and glue style syntax.\n\nstarwars %&gt;% \n  summarise(across(where(is.numeric), min_max, .names = \"{.fn}.{.col}\"))\n#&gt; # A tibble: 1 × 6\n#&gt;   min.height max.height min.mass max.mass min.birth_year max.birth_year\n#&gt;        &lt;int&gt;      &lt;int&gt;    &lt;dbl&gt;    &lt;dbl&gt;          &lt;dbl&gt;          &lt;dbl&gt;\n#&gt; 1         66        264       15     1358              8            896",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>dplyr: Column-wise operations</span>"
    ]
  },
  {
    "objectID": "01-dplyr-colwise.html#sec-gotchas",
    "href": "01-dplyr-colwise.html#sec-gotchas",
    "title": "3  dplyr: Column-wise operations",
    "section": "\n3.3 Gotchas",
    "text": "3.3 Gotchas\nBe careful when combining numeric summaries with where(is.numeric). For instance, if using n = n(), make sure that it comes after the transformation of across(where(is.numeric).\n\ndf &lt;- data.frame(x = c(1, 2, 3), y = c(1, 4, 9))\n\ndf %&gt;% \n  summarise(across(where(is.numeric), sd), n = n())\n#&gt;   x        y n\n#&gt; 1 1 4.041452 3\n\nAnother way to do this and make it more explicit is to call tibble() within summarise() to create a new tibble from the different pieces.\n\ndf %&gt;% \n  summarise(\n    tibble(n = n(), across(where(is.numeric), sd))\n  )\n#&gt;   n x        y\n#&gt; 1 3 1 4.041452",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>dplyr: Column-wise operations</span>"
    ]
  },
  {
    "objectID": "01-dplyr-colwise.html#sec-filter",
    "href": "01-dplyr-colwise.html#sec-filter",
    "title": "3  dplyr: Column-wise operations",
    "section": "\n3.4 filter() and across()\n",
    "text": "3.4 filter() and across()\n\nCannot directly use across() and tidyselect methods with filter because you need another step to combine the results. This can be done with if_any() and if_all().\n\n\nif_any() keeps the rows where the predicate is true for at least one selected column.\n\nif_all() keeps the rows where the predicate is true for all selected columns.\n\n\nnrow(starwars)\n#&gt; [1] 87\n\n# Keep rows with at least one non-NA value\nstarwars %&gt;% \n  filter(if_any(everything(), ~ !is.na(.x))) %&gt;% \n  nrow()\n#&gt; [1] 87\n\n# Keep rows that do not have any NA values\nstarwars %&gt;% \n  filter(if_all(everything(), ~ !is.na(.x))) %&gt;% \n  nrow()\n#&gt; [1] 29",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>dplyr: Column-wise operations</span>"
    ]
  },
  {
    "objectID": "01-dplyr-colwise.html#replacing-_if-_at-and-_all",
    "href": "01-dplyr-colwise.html#replacing-_if-_at-and-_all",
    "title": "3  dplyr: Column-wise operations",
    "section": "\n3.5 Replacing _if, _at, and _all\n",
    "text": "3.5 Replacing _if, _at, and _all\n\n\n\nacross() makes it possible to compute useful summaries that were previously impossible. For example, it’s now easy to summarise numeric vectors with one function, factors with another, and still compute the number of rows in each group.\n\nacross() reduces the number of functions that dplyr needs to provide.\nWith the where() helper, across() unifies _if and _at semantics, allowing combinations that used to be impossible. For example, you can now transform all numeric columns whose name begins with “x”: across(where(is.numeric) & starts_with(\"x\")).\n\nacross() doesn’t need vars().",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>dplyr: Column-wise operations</span>"
    ]
  },
  {
    "objectID": "01-dplyr-rowwise.html",
    "href": "01-dplyr-rowwise.html",
    "title": "4  dplyr: Row-wise operations",
    "section": "",
    "text": "4.1 Creating\nrowwise() works like group_by() in the sense that it doesn’t change what the data looks like; it changes how dplyr verbs operate on the data. rowwise() switches the orientation of dplyr verbs on data frames to work across rows instead of down columns.\ndf &lt;- tibble(x = 1:2, y = 3:4, z = 5:6)\n\n# Normal\ndf %&gt;% mutate(m = mean(c(x, y, z)))\n#&gt; # A tibble: 2 × 4\n#&gt;       x     y     z     m\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     3     5   3.5\n#&gt; 2     2     4     6   3.5\n\n# rowwise\ndf %&gt;% rowwise() %&gt;% mutate(m = mean(c(x, y, z)))\n#&gt; # A tibble: 2 × 4\n#&gt; # Rowwise: \n#&gt;       x     y     z     m\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     3     5     3\n#&gt; 2     2     4     6     4\nYou can supply “identifier” variables in rowwise(). These variables are preserved when you call summarise() and so function similarly to variables in group_by(). You can remove the grouping with ungroup() or .groups.\ndf &lt;- tibble(name = c(\"Mara\", \"Hadley\"), x = 1:2, y = 3:4, z = 5:6)\n\ndf %&gt;% \n  rowwise() %&gt;% \n  summarise(m = mean(c(x, y, z)))\n#&gt; # A tibble: 2 × 1\n#&gt;       m\n#&gt;   &lt;dbl&gt;\n#&gt; 1     3\n#&gt; 2     4\n\ndf %&gt;% \n  rowwise(name) %&gt;% \n  summarise(m = mean(c(x, y, z)), .groups = \"drop\")\n#&gt; # A tibble: 2 × 2\n#&gt;   name       m\n#&gt;   &lt;chr&gt;  &lt;dbl&gt;\n#&gt; 1 Mara       3\n#&gt; 2 Hadley     4",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>dplyr: Row-wise operations</span>"
    ]
  },
  {
    "objectID": "01-dplyr-rowwise.html#sec-per-row",
    "href": "01-dplyr-rowwise.html#sec-per-row",
    "title": "4  dplyr: Row-wise operations",
    "section": "\n4.2 Per row summary statistics",
    "text": "4.2 Per row summary statistics\nUse mutate() to add a new column to each row; use summarise() to return just the summary column(s) and any “identifier” columns.\nData that might represent scores for students on tests:\n\ndf &lt;- tibble(id = 1:6, w = 10:15, x = 20:25, y = 30:35, z = 40:45)\n\nSum of total scores as a new column with mutate() or on its own with summarise():\n\n# mutate\ndf %&gt;% \n  rowwise() %&gt;% \n  mutate(total = sum(c(w, x, y, z)))\n#&gt; # A tibble: 6 × 6\n#&gt; # Rowwise: \n#&gt;      id     w     x     y     z total\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;\n#&gt; 1     1    10    20    30    40   100\n#&gt; 2     2    11    21    31    41   104\n#&gt; 3     3    12    22    32    42   108\n#&gt; 4     4    13    23    33    43   112\n#&gt; 5     5    14    24    34    44   116\n#&gt; 6     6    15    25    35    45   120\n\n# summarise\ndf %&gt;% \n  rowwise() %&gt;% \n  summarise(total = sum(c(w, x, y, z)), .groups = \"drop\")\n#&gt; # A tibble: 6 × 1\n#&gt;   total\n#&gt;   &lt;int&gt;\n#&gt; 1   100\n#&gt; 2   104\n#&gt; 3   108\n#&gt; 4   112\n#&gt; 5   116\n#&gt; 6   120\n\nYou can use c_across() to access tidy selection syntax and “identifier” columns are not used within computations.\n\ndf %&gt;% \n  rowwise(id) %&gt;% \n  mutate(total = sum(c_across(w:z)))\n#&gt; # A tibble: 6 × 6\n#&gt; # Rowwise:  id\n#&gt;      id     w     x     y     z total\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;\n#&gt; 1     1    10    20    30    40   100\n#&gt; 2     2    11    21    31    41   104\n#&gt; 3     3    12    22    32    42   108\n#&gt; 4     4    13    23    33    43   112\n#&gt; 5     5    14    24    34    44   116\n#&gt; 6     6    15    25    35    45   120\n\ndf %&gt;% \n  rowwise(id) %&gt;% \n  mutate(total = sum(c_across(where(is.numeric))))\n#&gt; # A tibble: 6 × 6\n#&gt; # Rowwise:  id\n#&gt;      id     w     x     y     z total\n#&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;\n#&gt; 1     1    10    20    30    40   100\n#&gt; 2     2    11    21    31    41   104\n#&gt; 3     3    12    22    32    42   108\n#&gt; 4     4    13    23    33    43   112\n#&gt; 5     5    14    24    34    44   116\n#&gt; 6     6    15    25    35    45   120\n\nYou can combine rowwise analysis with column-wise analysis such as computing the proportion of the total for each column.\n\ndf %&gt;% \n  rowwise(id) %&gt;% \n  mutate(total = sum(c_across(w:z))) %&gt;% \n  ungroup() %&gt;% \n  mutate(across(w:z, \\(x) x / total))\n#&gt; # A tibble: 6 × 6\n#&gt;      id     w     x     y     z total\n#&gt;   &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;\n#&gt; 1     1 0.1   0.2   0.3   0.4     100\n#&gt; 2     2 0.106 0.202 0.298 0.394   104\n#&gt; 3     3 0.111 0.204 0.296 0.389   108\n#&gt; 4     4 0.116 0.205 0.295 0.384   112\n#&gt; 5     5 0.121 0.207 0.293 0.379   116\n#&gt; 6     6 0.125 0.208 0.292 0.375   120",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>dplyr: Row-wise operations</span>"
    ]
  },
  {
    "objectID": "01-dplyr-rowwise.html#sec-list-cols",
    "href": "01-dplyr-rowwise.html#sec-list-cols",
    "title": "4  dplyr: Row-wise operations",
    "section": "\n4.3 List-columns",
    "text": "4.3 List-columns\nrowwise() pairs well with list columns and helps to avoid for loops, use of the apply() functions, or purr::map() functions. If you want to get the length of list columns you either have to use the rather esoteric lengths() function or apply() or map() functions. But you can now do this with rowwise().\n\ndf &lt;- tibble(x = list(1, 2:3, 4:6))\n\n# Base apply\ndf %&gt;% mutate(l = sapply(x, length))\n#&gt; # A tibble: 3 × 2\n#&gt;   x             l\n#&gt;   &lt;list&gt;    &lt;int&gt;\n#&gt; 1 &lt;dbl [1]&gt;     1\n#&gt; 2 &lt;int [2]&gt;     2\n#&gt; 3 &lt;int [3]&gt;     3\n\n# purrr::map\ndf %&gt;% mutate(l = purrr::map_int(x, length))\n#&gt; # A tibble: 3 × 2\n#&gt;   x             l\n#&gt;   &lt;list&gt;    &lt;int&gt;\n#&gt; 1 &lt;dbl [1]&gt;     1\n#&gt; 2 &lt;int [2]&gt;     2\n#&gt; 3 &lt;int [3]&gt;     3\n\n# rowwise\ndf %&gt;% \n  rowwise() %&gt;% \n  mutate(l = length(x))\n#&gt; # A tibble: 3 × 2\n#&gt; # Rowwise: \n#&gt;   x             l\n#&gt;   &lt;list&gt;    &lt;int&gt;\n#&gt; 1 &lt;dbl [1]&gt;     1\n#&gt; 2 &lt;int [2]&gt;     2\n#&gt; 3 &lt;int [3]&gt;     3\n\n\n4.3.1 Subsetting list-columns\nList-columns provide a good way to understand how grouping with rowwise() works differently from grouping with group_by() even when each group happens to have only one row. In rowwise() each group always only has one row.\n\ndf &lt;- tibble(g = 1:2, y = list(1:3, \"a\"))\ngf &lt;- df %&gt;% group_by(g)\nrf &lt;- df %&gt;% rowwise(g)\n\n# group_by\ngf %&gt;% mutate(type = typeof(y), length = length(y))\n#&gt; # A tibble: 2 × 4\n#&gt; # Groups:   g [2]\n#&gt;       g y         type  length\n#&gt;   &lt;int&gt; &lt;list&gt;    &lt;chr&gt;  &lt;int&gt;\n#&gt; 1     1 &lt;int [3]&gt; list       1\n#&gt; 2     2 &lt;chr [1]&gt; list       1\n\n# rowwise\nrf %&gt;% mutate(type = typeof(y), length = length(y))\n#&gt; # A tibble: 2 × 4\n#&gt; # Rowwise:  g\n#&gt;       g y         type      length\n#&gt;   &lt;int&gt; &lt;list&gt;    &lt;chr&gt;      &lt;int&gt;\n#&gt; 1     1 &lt;int [3]&gt; integer        3\n#&gt; 2     2 &lt;chr [1]&gt; character      1\n\nmutate() slices that data to pass to length(y) with [ in the grouped data frame but uses [[ subsetting for row-wise mutates.\n\n4.3.2 Modelling\nrowwise() and list-columns provides a variety of solutions to modelling problems. You can create a nested data frame that is more explicit than group_by() and returns a rowwise data frame.\n\nby_cyl &lt;- mtcars %&gt;% nest_by(cyl)\nby_cyl\n#&gt; # A tibble: 3 × 2\n#&gt; # Rowwise:  cyl\n#&gt;     cyl                data\n#&gt;   &lt;dbl&gt; &lt;list&lt;tibble[,10]&gt;&gt;\n#&gt; 1     4           [11 × 10]\n#&gt; 2     6            [7 × 10]\n#&gt; 3     8           [14 × 10]\n\nNow we can make one model per row and one set of predictions per row:\n\nmods &lt;- by_cyl %&gt;% \n  mutate(mod = list(lm(mpg ~ wt, data = data))) %&gt;% \n  mutate(pred = list(predict(mod, data)))\nmods\n#&gt; # A tibble: 3 × 4\n#&gt; # Rowwise:  cyl\n#&gt;     cyl                data mod    pred      \n#&gt;   &lt;dbl&gt; &lt;list&lt;tibble[,10]&gt;&gt; &lt;list&gt; &lt;list&gt;    \n#&gt; 1     4           [11 × 10] &lt;lm&gt;   &lt;dbl [11]&gt;\n#&gt; 2     6            [7 × 10] &lt;lm&gt;   &lt;dbl [7]&gt; \n#&gt; 3     8           [14 × 10] &lt;lm&gt;   &lt;dbl [14]&gt;\n\nYou can then summarize the model in a variety of ways or access the parameters of each model:\n\n# Summary\nmods %&gt;% summarise(rsq = summary(mod)$r.squared)\n#&gt; `summarise()` has grouped output by 'cyl'. You can override using the `.groups`\n#&gt; argument.\n#&gt; # A tibble: 3 × 2\n#&gt; # Groups:   cyl [3]\n#&gt;     cyl   rsq\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     4 0.509\n#&gt; 2     6 0.465\n#&gt; 3     8 0.423\n\n# Access parameters\nmods %&gt;% reframe(broom::tidy(mod))\n#&gt; # A tibble: 6 × 6\n#&gt;     cyl term        estimate std.error statistic    p.value\n#&gt;   &lt;dbl&gt; &lt;chr&gt;          &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n#&gt; 1     4 (Intercept)    39.6      4.35       9.10 0.00000777\n#&gt; 2     4 wt             -5.65     1.85      -3.05 0.0137    \n#&gt; 3     6 (Intercept)    28.4      4.18       6.79 0.00105   \n#&gt; 4     6 wt             -2.78     1.33      -2.08 0.0918    \n#&gt; 5     8 (Intercept)    23.9      3.01       7.94 0.00000405\n#&gt; 6     8 wt             -2.19     0.739     -2.97 0.0118",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>dplyr: Row-wise operations</span>"
    ]
  },
  {
    "objectID": "01-dplyr-rowwise.html#sec-repeated-funcs",
    "href": "01-dplyr-rowwise.html#sec-repeated-funcs",
    "title": "4  dplyr: Row-wise operations",
    "section": "\n4.4 Repeated function calls",
    "text": "4.4 Repeated function calls\nrowwise() can also return a vector of length greater than one if the result is a list. This means that rowwise() and mutate() provide an elegant way to call a function many times with varying arguments, storing the outputs alongside the inputs. For instance you can store argument parameters for runif() in a data frame and then have the results presented in a list column.\n\ndf &lt;- tribble(\n  ~ n, ~ min, ~ max,\n    1,     0,     1,\n    2,    10,   100,\n    3,   100,  1000,\n)\n\ndf %&gt;% \n  rowwise() %&gt;% \n  mutate(data = list(runif(n, min, max)))\n#&gt; # A tibble: 3 × 4\n#&gt; # Rowwise: \n#&gt;       n   min   max data     \n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt;   \n#&gt; 1     1     0     1 &lt;dbl [1]&gt;\n#&gt; 2     2    10   100 &lt;dbl [2]&gt;\n#&gt; 3     3   100  1000 &lt;dbl [3]&gt;\n\nYou can also vary the functions called with the use of do.call().\n\ndf &lt;- tribble(\n   ~rng,     ~params,\n   \"runif\",  list(n = 10), \n   \"rnorm\",  list(n = 20),\n   \"rpois\",  list(n = 10, lambda = 5),\n) %&gt;%\n  rowwise()\n\ndf %&gt;% \n  mutate(data = list(do.call(rng, params)))\n#&gt; # A tibble: 3 × 3\n#&gt; # Rowwise: \n#&gt;   rng   params           data      \n#&gt;   &lt;chr&gt; &lt;list&gt;           &lt;list&gt;    \n#&gt; 1 runif &lt;named list [1]&gt; &lt;dbl [10]&gt;\n#&gt; 2 rnorm &lt;named list [1]&gt; &lt;dbl [20]&gt;\n#&gt; 3 rpois &lt;named list [2]&gt; &lt;int [10]&gt;",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>dplyr: Row-wise operations</span>"
    ]
  },
  {
    "objectID": "01-dplyr-1.0.0.html",
    "href": "01-dplyr-1.0.0.html",
    "title": "5  dplyr 1.0.0",
    "section": "",
    "text": "5.1 dplyr 1.0.0 Blog posts\nlibrary(dplyr)",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>dplyr 1.0.0</span>"
    ]
  },
  {
    "objectID": "01-dplyr-1.0.0.html#dplyr-1.0.0-blog-posts",
    "href": "01-dplyr-1.0.0.html#dplyr-1.0.0-blog-posts",
    "title": "5  dplyr 1.0.0",
    "section": "",
    "text": "dplyr 1.0.0 is coming soon\ndplyr 1.0.0: new summarise() features\ndplyr 1.0.0: select, rename, relocate\ndplyr 1.0.0: working across columns\ndplyr 1.0.0: working within rows\ndplyr 1.0.0 and vctrs\ndplyr 1.0.0 for package developers\ndplyr 1.0.0: last minute additions",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>dplyr 1.0.0</span>"
    ]
  },
  {
    "objectID": "01-dplyr-1.0.0.html#sec-overview",
    "href": "01-dplyr-1.0.0.html#sec-overview",
    "title": "5  dplyr 1.0.0",
    "section": "\n5.2 Overview of new features",
    "text": "5.2 Overview of new features\n\nBetter support for row-wise operations: Row-wise operations.\nA new, simpler, approach to column-wise operations: Column-wise operations\n\n\nselect() can select columns based on their type, and has a new syntax that better matches how you describe selections in English.\nA new relocate() verb makes it easier change the position of columns.\nNew way to program with dplyr. See Programming with dplyr notes.\n\ndplyr is now based on the vctrs package.",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>dplyr 1.0.0</span>"
    ]
  },
  {
    "objectID": "01-dplyr-1.0.0.html#sec-summarise",
    "href": "01-dplyr-1.0.0.html#sec-summarise",
    "title": "5  dplyr 1.0.0",
    "section": "\n5.3 New summarise() features",
    "text": "5.3 New summarise() features\nNew feature to allow multiple summarizations per group, outputting multiple rows. This ability was removed in dplyr 1.1.0 and moved to the new function reframe(). See reframe().\nsummarise() also gains a new .groups argument to control how groups are dropped if summarise() is used on a grouped data frame. See summarise() and grouping. The options are:\n\nAddition of a .groups argument to:\n\n\"drop_last\": (default) drops the last grouping level.\n\n\"drop\": drops all grouping levels.\n\n\"keep\" preserves the grouping of the input.\n\n\"rowwise\" turns each row into its own group.",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>dplyr 1.0.0</span>"
    ]
  },
  {
    "objectID": "01-dplyr-1.0.0.html#sec-tidyselect",
    "href": "01-dplyr-1.0.0.html#sec-tidyselect",
    "title": "5  dplyr 1.0.0",
    "section": "\n5.4 select(), rename(), relocate()\n",
    "text": "5.4 select(), rename(), relocate()\n\nThese features are implemented in the tidyselect package. See dplyr Argument type: tidy-select.\n\n5.4.1 Five ways to select variables in select() and rename():\n\nPosition: df %&gt;% select(1:4)\n\nGenerally not recommended, but it can be very useful, particularly if the variable names are very long, non-syntactic, or duplicated.\n\n\nName: df %&gt;% select(a, e, j)\n\nFunction of name: df %&gt;% select(starts_with(\"x\"))\n\nHelper functions: starts_with(), ends_with(), contains(), matches()\n\n\n\nType: df %&gt;% select(where(is.numeric))\n\nAny combination with Boolean operators !, &, and |: df %&gt;% select(!where(is.factor))\n\n\n5.4.2 Programming\n\n\nany_of(): Takes a character vector of variable names and silently ignores the missing columns.\n\nall_of() throws an error if a column name is missing.\n\n\ndf &lt;- tibble(x1 = 1, x2 = \"a\", x3 = 2, y1 = \"b\", y2 = 3, y3 = \"c\", y4 = 4)\n\nvars &lt;- c(\"x1\", \"x2\", \"y1\", \"z\")\ndf %&gt;% select(any_of(vars))\n#&gt; # A tibble: 1 × 3\n#&gt;      x1 x2    y1   \n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1     1 a     b\n\n# all_of() errors if variable is missing\ndf %&gt;% select(all_of(vars))\n#&gt; Error in `all_of()`:\n#&gt; ! Can't subset columns that don't exist.\n#&gt; ✖ Column `z` doesn't exist.\n\nrename_with() makes it easier to rename variables programmatically. It supersedes rename_if() and rename_at().\n\ndf %&gt;% rename_with(toupper)\n#&gt; # A tibble: 1 × 7\n#&gt;      X1 X2       X3 Y1       Y2 Y3       Y4\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     1 a         2 b         3 c         4\n\nYou can optionally choose which columns to apply the transformation to:\n\ndf %&gt;% rename_with(toupper, starts_with(\"x\"))\n#&gt; # A tibble: 1 × 7\n#&gt;      X1 X2       X3 y1       y2 y3       y4\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     1 a         2 b         3 c         4\n\ndf %&gt;% rename_with(toupper, where(is.numeric))\n#&gt; # A tibble: 1 × 7\n#&gt;      X1 x2       X3 y1       Y2 y3       Y4\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     1 a         2 b         3 c         4\n\n\n5.4.3 relocate()\n\nrelocate() is a specialized function to move columns around. The default behavior is to move columns to the front, to the left.\n\ndf &lt;- tibble(w = 0, x = 1, y = \"a\", z = \"b\")\n\ndf %&gt;% relocate(y, z)\n#&gt; # A tibble: 1 × 4\n#&gt;   y     z         w     x\n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 a     b         0     1\n\n# Programatic movement\ndf %&gt;% relocate(where(is.character))\n#&gt; # A tibble: 1 × 4\n#&gt;   y     z         w     x\n#&gt;   &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 a     b         0     1\n\nIf you want to move columns to a different position use .before or .after:\n\ndf %&gt;% relocate(w, .after = y)\n#&gt; # A tibble: 1 × 4\n#&gt;       x y         w z    \n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;\n#&gt; 1     1 a         0 b\n\ndf %&gt;% relocate(w, .before = y)\n#&gt; # A tibble: 1 × 4\n#&gt;       x     w y     z    \n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1     1     0 a     b\n\nUse last_col() to move to the right-hand side:\n\ndf %&gt;% relocate(w, .after = last_col())\n#&gt; # A tibble: 1 × 4\n#&gt;       x y     z         w\n#&gt;   &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt; 1     1 a     b         0",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>dplyr 1.0.0</span>"
    ]
  },
  {
    "objectID": "01-dplyr-1.0.0.html#sec-across",
    "href": "01-dplyr-1.0.0.html#sec-across",
    "title": "5  dplyr 1.0.0",
    "section": "\n5.5 Working across columns",
    "text": "5.5 Working across columns\nSee Column-wise operations vignette and notes on the vignette\nUse of across() to replace and supersede _if(), _at() and _all() suffix versions of summarise() and mutate().\n\n5.5.1 Basic usage\nTwo main arguments of across()\n\n\n.cols: selects the columns you want to operate on using tidy select syntax.\n\n.fns: a function or list of functions to apply to each column.\n\nacross() uses tidyselect and so uses helper functions such as where(), starts_with() and can use c() to select multiple columns instead of the old function of vars().\n\nstarwars %&gt;% \n  summarise(across(where(is.character), n_distinct))\n#&gt; # A tibble: 1 × 8\n#&gt;    name hair_color skin_color eye_color   sex gender homeworld species\n#&gt;   &lt;int&gt;      &lt;int&gt;      &lt;int&gt;     &lt;int&gt; &lt;int&gt;  &lt;int&gt;     &lt;int&gt;   &lt;int&gt;\n#&gt; 1    87         12         31        15     5      3        49      38\n\nstarwars %&gt;% \n  summarise(across(c(sex, gender, homeworld), n_distinct))\n#&gt; # A tibble: 1 × 3\n#&gt;     sex gender homeworld\n#&gt;   &lt;int&gt;  &lt;int&gt;     &lt;int&gt;\n#&gt; 1     5      3        49\n\nYou can also apply a function with arguments, but with dplyr 1.1.0 you now need to use an anonymous function or lambda syntax.\n\nstarwars %&gt;% \n  group_by(homeworld) %&gt;% \n  filter(n() &gt; 1) %&gt;% \n  summarise(across(where(is.numeric), \\(x) mean(x, na.rm = TRUE)), n = n())\n#&gt; # A tibble: 10 × 5\n#&gt;    homeworld height  mass birth_year     n\n#&gt;    &lt;chr&gt;      &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt; &lt;int&gt;\n#&gt;  1 Alderaan    176.  64         43       3\n#&gt;  2 Corellia    175   78.5       25       2\n#&gt;  3 Coruscant   174.  50         91       3\n#&gt;  4 Kamino      208.  83.1       31.5     3\n#&gt;  5 Kashyyyk    231  124        200       2\n#&gt;  6 Mirial      168   53.1       49       2\n#&gt;  7 Naboo       177.  64.2       55      11\n#&gt;  8 Ryloth      179   55         48       2\n#&gt;  9 Tatooine    170.  85.4       54.6    10\n#&gt; 10 &lt;NA&gt;        139.  82        334.     10",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>dplyr 1.0.0</span>"
    ]
  },
  {
    "objectID": "01-dplyr-1.0.0.html#sec-rowwise",
    "href": "01-dplyr-1.0.0.html#sec-rowwise",
    "title": "5  dplyr 1.0.0",
    "section": "\n5.6 Working within rows",
    "text": "5.6 Working within rows\nSee Row-wise operations vignette and notes on the vignette.\nrowwise() works like group_by() in the sense that it doesn’t change what the data looks like; it changes how dplyr verbs operate on the data.\nExample of wanting to calculate mean of each students’ test scores:\n\ndf &lt;- tibble(\n  student_id = 1:4, \n  test1 = 10:13, \n  test2 = 20:23, \n  test3 = 30:33, \n  test4 = 40:43\n)\n\n# mutate() does not do what we want\ndf %&gt;% mutate(avg = mean(c(test1, test2, test3, test4)))\n#&gt; # A tibble: 4 × 6\n#&gt;   student_id test1 test2 test3 test4   avg\n#&gt;        &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n#&gt; 1          1    10    20    30    40  26.5\n#&gt; 2          2    11    21    31    41  26.5\n#&gt; 3          3    12    22    32    42  26.5\n#&gt; 4          4    13    23    33    43  26.5\n\n# change with rowwise\ndf %&gt;% \n  rowwise() %&gt;% \n  mutate(avg = mean(c(test1, test2, test3, test4)))\n#&gt; # A tibble: 4 × 6\n#&gt; # Rowwise: \n#&gt;   student_id test1 test2 test3 test4   avg\n#&gt;        &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n#&gt; 1          1    10    20    30    40    25\n#&gt; 2          2    11    21    31    41    26\n#&gt; 3          3    12    22    32    42    27\n#&gt; 4          4    13    23    33    43    28\n\nYou can also pair rowwise() with c_across() to use tidyselect functions. It is based on vec_c().\n\ndf %&gt;% \n  rowwise() %&gt;% \n    mutate(avg = mean(c_across(starts_with(\"test\"))))\n#&gt; # A tibble: 4 × 6\n#&gt; # Rowwise: \n#&gt;   student_id test1 test2 test3 test4   avg\n#&gt;        &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n#&gt; 1          1    10    20    30    40    25\n#&gt; 2          2    11    21    31    41    26\n#&gt; 3          3    12    22    32    42    27\n#&gt; 4          4    13    23    33    43    28",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>dplyr 1.0.0</span>"
    ]
  },
  {
    "objectID": "01-dplyr-1.1.0.html",
    "href": "01-dplyr-1.1.0.html",
    "title": "6  dplyr 1.1.0",
    "section": "",
    "text": "6.1 dplyr 1.1.0 Blog posts",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>dplyr 1.1.0</span>"
    ]
  },
  {
    "objectID": "01-dplyr-1.1.0.html#dplyr-1.1.0-blog-posts",
    "href": "01-dplyr-1.1.0.html#dplyr-1.1.0-blog-posts",
    "title": "6  dplyr 1.1.0",
    "section": "",
    "text": "dplyr 1.1.0 is coming soon\nJoins\nPer-operation grouping\nThe power of vctrs\npick(), reframe(), and arrange()",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>dplyr 1.1.0</span>"
    ]
  },
  {
    "objectID": "01-dplyr-1.1.0.html#resources",
    "href": "01-dplyr-1.1.0.html#resources",
    "title": "6  dplyr 1.1.0",
    "section": "\n6.2 Resources",
    "text": "6.2 Resources\n\n\nMine Çetinkaya-Rundel, What’s new in the tidyverse in 2023\n\nGood overview of the changes in dplyr and tidyverse discussed here.\n\n\n\n\nlibrary(dplyr)",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>dplyr 1.1.0</span>"
    ]
  },
  {
    "objectID": "01-dplyr-1.1.0.html#joins",
    "href": "01-dplyr-1.1.0.html#joins",
    "title": "6  dplyr 1.1.0",
    "section": "\n6.3 Joins",
    "text": "6.3 Joins\n\n6.3.1 Data\nData with two tables of transactions with company id and companies with information about the company.\n\ntransactions &lt;- tibble(\n  company = c(\"A\", \"A\", \"B\", \"B\"),\n  year = c(2019, 2020, 2021, 2023),\n  revenue = c(50, 4, 10, 12)\n)\n\ncompanies &lt;- tibble(\n  id = c(\"A\", \"B\"),\n  name = c(\"Patagonia\", \"RStudio\")\n)\n\n\n6.3.2 join_by()\n\nInstead of the syntax: by = c(\"company\" = \"id\") use function join_by(): by = join_by(company == id)\n\n# Previously\ntransactions |&gt; \n  inner_join(companies, by = c(\"company\" = \"id\"))\n#&gt; # A tibble: 4 × 4\n#&gt;   company  year revenue name     \n#&gt;   &lt;chr&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;    \n#&gt; 1 A        2019      50 Patagonia\n#&gt; 2 A        2020       4 Patagonia\n#&gt; 3 B        2021      10 RStudio  \n#&gt; 4 B        2023      12 RStudio\n\n# With join_by()\ntransactions |&gt; \n  inner_join(companies, by = join_by(company == id))\n#&gt; # A tibble: 4 × 4\n#&gt;   company  year revenue name     \n#&gt;   &lt;chr&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;    \n#&gt; 1 A        2019      50 Patagonia\n#&gt; 2 A        2020       4 Patagonia\n#&gt; 3 B        2021      10 RStudio  \n#&gt; 4 B        2023      12 RStudio\n\n\n6.3.3 Multiple matches\nAdd column to companies with information about founding date.\n\ncompanies &lt;- tibble(\n  id = c(\"A\", \"B\", \"B\"),\n  since = c(1973, 2009, 2022),\n  name = c(\"Patagonia\", \"RStudio\", \"Posit\")\n)\n\nWarning when multiple matches appear and extra rows are added.\n\ntransactions |&gt; \n  inner_join(companies, by = join_by(company == id))\n#&gt; Warning in inner_join(transactions, companies, by = join_by(company == id)): Detected an unexpected many-to-many relationship between `x` and `y`.\n#&gt; ℹ Row 3 of `x` matches multiple rows in `y`.\n#&gt; ℹ Row 1 of `y` matches multiple rows in `x`.\n#&gt; ℹ If a many-to-many relationship is expected, set `relationship =\n#&gt;   \"many-to-many\"` to silence this warning.\n#&gt; # A tibble: 6 × 5\n#&gt;   company  year revenue since name     \n#&gt;   &lt;chr&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    \n#&gt; 1 A        2019      50  1973 Patagonia\n#&gt; 2 A        2020       4  1973 Patagonia\n#&gt; 3 B        2021      10  2009 RStudio  \n#&gt; 4 B        2021      10  2022 Posit    \n#&gt; 5 B        2023      12  2009 RStudio  \n#&gt; 6 B        2023      12  2022 Posit\n\nSuppress warning with multiple = \"all\" or make it an error with multiple = \"error\".\n\ntransactions |&gt; \n  inner_join(companies, by = join_by(company == id),\n             multiple = \"error\")\n#&gt; Warning: Specifying `multiple = \"error\"` was deprecated in dplyr 1.1.1.\n#&gt; ℹ Please use `relationship = \"many-to-one\"` instead.\n#&gt; Error in `inner_join()`:\n#&gt; ! Each row in `x` must match at most 1 row in `y`.\n#&gt; ℹ Row 3 of `x` matches multiple rows in `y`.\n\n\n6.3.4 Inequality joins\nUse of inequality joins to help to fix the issue of multiple matches. Use of inequality expression in join_by(). In this case, we only want transactions to be linked to companies after they have been founded: year &gt;= since.\n\ntransactions |&gt;\n  inner_join(companies, join_by(company == id, year &gt;= since))\n#&gt; # A tibble: 5 × 5\n#&gt;   company  year revenue since name     \n#&gt;   &lt;chr&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    \n#&gt; 1 A        2019      50  1973 Patagonia\n#&gt; 2 A        2020       4  1973 Patagonia\n#&gt; 3 B        2021      10  2009 RStudio  \n#&gt; 4 B        2023      12  2009 RStudio  \n#&gt; 5 B        2023      12  2022 Posit\n\nThis eliminates the 2021 match to Posit, but inequality joins are still likely to return multiple matches because they are only bounded on one side.\n\n6.3.5 Rolling joins\nRolling joins are meant to help fix the issue of the one-sided nature of inequality joins. This can be done with the closest() helper to filter matches to those that are closest between year and since.\n\ntransactions |&gt;\n  inner_join(companies, join_by(company == id, closest(year &gt;= since)))\n#&gt; # A tibble: 4 × 5\n#&gt;   company  year revenue since name     \n#&gt;   &lt;chr&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    \n#&gt; 1 A        2019      50  1973 Patagonia\n#&gt; 2 A        2020       4  1973 Patagonia\n#&gt; 3 B        2021      10  2009 RStudio  \n#&gt; 4 B        2023      12  2022 Posit\n\n\n6.3.6 Unmatched rows\nCan catch unmatched rows with argument unmatched. Can set unmatched = \"error\" to catch it rows are dropper in inner_join().\n\n# Add row that will not be matched\ntransactions &lt;- transactions |&gt;\n  tibble::add_row(company = \"C\", year = 2023, revenue = 15)\n\n# Unmatched rows silently dropped\ntransactions |&gt;\n  inner_join(\n    companies, \n    join_by(company == id, closest(year &gt;= since))\n  )\n#&gt; # A tibble: 4 × 5\n#&gt;   company  year revenue since name     \n#&gt;   &lt;chr&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;    \n#&gt; 1 A        2019      50  1973 Patagonia\n#&gt; 2 A        2020       4  1973 Patagonia\n#&gt; 3 B        2021      10  2009 RStudio  \n#&gt; 4 B        2023      12  2022 Posit\n\n# Error with unmatched rows\ntransactions |&gt;\n  inner_join(\n    companies, \n    join_by(company == id, closest(year &gt;= since)),\n    unmatched = \"error\"\n  )\n#&gt; Error in `inner_join()`:\n#&gt; ! Each row of `x` must have a match in `y`.\n#&gt; ℹ Row 5 of `x` does not have a match.",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>dplyr 1.1.0</span>"
    ]
  },
  {
    "objectID": "01-dplyr-1.1.0.html#per-operation-grouping",
    "href": "01-dplyr-1.1.0.html#per-operation-grouping",
    "title": "6  dplyr 1.1.0",
    "section": "\n6.4 Per-operation grouping",
    "text": "6.4 Per-operation grouping\n\ntransactions &lt;- tibble(\n  company = c(\"A\", \"A\", \"A\", \"B\", \"B\", \"B\"),\n  year = c(2019, 2019, 2020, 2021, 2023, 2023),\n  revenue = c(20, 50, 4, 10, 12, 18)\n)\n\n\n6.4.1 Persistent grouping with group_by()\n\nGroups are maintained through other function calls, such as to mutate() or summarise().\n\ntransactions |&gt;\n  group_by(company, year) |&gt;\n  mutate(total = sum(revenue))\n#&gt; # A tibble: 6 × 4\n#&gt; # Groups:   company, year [4]\n#&gt;   company  year revenue total\n#&gt;   &lt;chr&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 A        2019      20    70\n#&gt; 2 A        2019      50    70\n#&gt; 3 A        2020       4     4\n#&gt; 4 B        2021      10    10\n#&gt; 5 B        2023      12    30\n#&gt; 6 B        2023      18    30\n\n\n6.4.2 Per-operation grouping with .by/by\n\nDocumentation\ndplyr 1.1.0 adds per-operation grouping within summarise(), mutate(), filter(), and some other dplyr verbs with the new .by argument.\n\ntransactions |&gt;\n  summarise(total = sum(revenue), .by = c(company, year))\n#&gt; # A tibble: 4 × 3\n#&gt;   company  year total\n#&gt;   &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 A        2019    70\n#&gt; 2 A        2020     4\n#&gt; 3 B        2021    10\n#&gt; 4 B        2023    30\n\n\n6.4.3 group_by() vs .by\n\n\nThe results are always ungrouped, (e.g. ) and tidyselect is used to group multiple columns.\nYou cannot create variables on the fly in .by, you must create them earlier in your pipeline, e.g., unlike df |&gt; group_by(month = floor_date(date, \"month\")).\nDifference in how the two ways deal with ordering rows from arrange().\n\n\n# Ordered tibble\ntransactions2 &lt;- transactions |&gt;\n  arrange(company, desc(year))\ntransactions2\n#&gt; # A tibble: 6 × 3\n#&gt;   company  year revenue\n#&gt;   &lt;chr&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n#&gt; 1 A        2020       4\n#&gt; 2 A        2019      20\n#&gt; 3 A        2019      50\n#&gt; 4 B        2023      12\n#&gt; 5 B        2023      18\n#&gt; 6 B        2021      10\n\n# `group_by()` re-sorts by grouping keys\ntransactions2 |&gt;\n  group_by(company, year) |&gt;\n  summarise(total = sum(revenue), .groups = \"drop\")\n#&gt; # A tibble: 4 × 3\n#&gt;   company  year total\n#&gt;   &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 A        2019    70\n#&gt; 2 A        2020     4\n#&gt; 3 B        2021    10\n#&gt; 4 B        2023    30\n\n# `.by` keeps the previous ordering\ntransactions2 |&gt;\n  summarise(total = sum(revenue), .by = c(company, year))\n#&gt; # A tibble: 4 × 3\n#&gt;   company  year total\n#&gt;   &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 A        2020     4\n#&gt; 2 A        2019    70\n#&gt; 3 B        2023    30\n#&gt; 4 B        2021    10",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>dplyr 1.1.0</span>"
    ]
  },
  {
    "objectID": "01-dplyr-1.1.0.html#the-power-of-vctrs",
    "href": "01-dplyr-1.1.0.html#the-power-of-vctrs",
    "title": "6  dplyr 1.1.0",
    "section": "\n6.5 The power of vctrs",
    "text": "6.5 The power of vctrs\n\n6.5.1 case_when()\n\nAbility to use regular NA in case_when() instead of specific class of NA. The following now just works.\n\nx &lt;- c(1, 12, -5, 6, -2, NA, 0)\n\ncase_when(\n  x &gt;= 10 ~ \"large\",\n  x &gt;= 0 ~ \"small\",\n  x &lt; 0 ~ NA\n)\n#&gt; [1] \"small\" \"large\" NA      \"small\" NA      NA      \"small\"\n\nNew .default argument for when none of the cases are met. The .default is always processed last, so the recommendation is to place it at the end of the list of cases. Now the negative values are labeled “other”.\n\ncase_when(\n  x &gt;= 10 ~ \"large\",\n  x &gt;= 0 ~ \"small\",\n  is.na(x) ~ \"missing\",\n  .default = \"other\"\n)\n#&gt; [1] \"small\"   \"large\"   \"other\"   \"small\"   \"other\"   \"missing\" \"small\"\n\n\n6.5.2 case_match()\nRemapping values with case_when() has been possible, but is a bit verbose.\n\nx &lt;- c(\"USA\", \"Canada\", \"Wales\", \"UK\", \"China\", NA, \"Mexico\", \"Russia\")\n\ncase_when(\n  x %in% c(\"USA\", \"Canada\", \"Mexico\") ~ \"North America\",\n  x %in% c(\"Wales\", \"UK\") ~ \"Europe\",\n  x %in% \"China\" ~ \"Asia\"\n)\n#&gt; [1] \"North America\" \"North America\" \"Europe\"        \"Europe\"       \n#&gt; [5] \"Asia\"          NA              \"North America\" NA\n\ncase_match() is a new function that removes the repetition involved with x %in%.\n\n#|label: case_match\ncase_match(\n  x,\n  c(\"USA\", \"Canada\", \"Mexico\") ~ \"North America\",\n  c(\"France\", \"UK\") ~ \"Europe\",\n  \"China\" ~ \"Asia\"\n)\n#&gt; [1] \"North America\" \"North America\" NA              \"Europe\"       \n#&gt; [5] \"Asia\"          NA              \"North America\" NA\n\ncase_match() is particularly helpful in a replacement helper function where you might want to change only a couple of values but leave everything else as is.\n\nreplace_match &lt;- function(x, ...) {\n  case_match(x, ..., .default = x, .ptype = x)\n}\n\nreplace_match(\n  x, \n  \"USA\" ~ \"United States\", \n  c(\"UK\", \"Wales\") ~ \"United Kingdom\",\n  NA ~ \"[Missing]\"\n)\n#&gt; [1] \"United States\"  \"Canada\"         \"United Kingdom\" \"United Kingdom\"\n#&gt; [5] \"China\"          \"[Missing]\"      \"Mexico\"         \"Russia\"\n\n\n6.5.3 consecutive_id()\n\nThe ability to create a consecutive id column linked to another id column so that only consecutive columns are collapsed with group_by() and summarise(). Create this with mutate(id = consecutive_id(name)).\n\ntranscript &lt;- tribble(\n  ~name, ~text,\n  \"Hadley\", \"I'll never learn Python.\",\n  \"Davis\", \"But aren't you speaking at PyCon?\",\n  \"Hadley\", \"So?\",\n  \"Hadley\", \"That doesn't influence my decision.\",\n  \"Hadley\", \"I'm not budging!\",\n  \"Mara\", \"Typical, Hadley. Stubborn as always.\",\n  \"Davis\", \"Fair enough!\",\n  \"Davis\", \"Let's move on.\"\n)\n\n# Create consecutive id column\ntranscript |&gt;\n  mutate(id = consecutive_id(name))\n#&gt; # A tibble: 8 × 3\n#&gt;   name   text                                    id\n#&gt;   &lt;chr&gt;  &lt;chr&gt;                                &lt;int&gt;\n#&gt; 1 Hadley I'll never learn Python.                 1\n#&gt; 2 Davis  But aren't you speaking at PyCon?        2\n#&gt; 3 Hadley So?                                      3\n#&gt; 4 Hadley That doesn't influence my decision.      3\n#&gt; 5 Hadley I'm not budging!                         3\n#&gt; 6 Mara   Typical, Hadley. Stubborn as always.     4\n#&gt; 7 Davis  Fair enough!                             5\n#&gt; 8 Davis  Let's move on.                           5\n\nNow you can do the grouping and summarize. You could do it just by id, but it is useful to group_by() name and id to keep the name in the summary table.\n\ntranscript |&gt;\n  mutate(id = consecutive_id(name)) |&gt;\n  summarise(text = stringr::str_flatten(text, collapse = \" \"), .by = c(id, name))\n#&gt; # A tibble: 5 × 3\n#&gt;      id name   text                                                    \n#&gt;   &lt;int&gt; &lt;chr&gt;  &lt;chr&gt;                                                   \n#&gt; 1     1 Hadley I'll never learn Python.                                \n#&gt; 2     2 Davis  But aren't you speaking at PyCon?                       \n#&gt; 3     3 Hadley So? That doesn't influence my decision. I'm not budging!\n#&gt; 4     4 Mara   Typical, Hadley. Stubborn as always.                    \n#&gt; 5     5 Davis  Fair enough! Let's move on.",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>dplyr 1.1.0</span>"
    ]
  },
  {
    "objectID": "01-dplyr-1.1.0.html#pick-reframe-and-arrange",
    "href": "01-dplyr-1.1.0.html#pick-reframe-and-arrange",
    "title": "6  dplyr 1.1.0",
    "section": "\n6.6 pick(), reframe(), and arrange()\n",
    "text": "6.6 pick(), reframe(), and arrange()\n\n\n6.6.1 pick()\n\npick() is a new function that is meant to be a compliment to across(). With across(), you typically apply a function to each column. With pick(), you typically apply a function to the full data frame of columns that you pick. In this way, pick() is replaceable with an equivalent call to tibble(). pick(a, c) creates a data frame that is the same as tibble(a = a, c = c).\n\ndf &lt;- tibble(\n  x_1 = c(1, 3, 2, 1, 2), \n  x_2 = 6:10, \n  w_4 = 11:15, \n  y_2 = c(5, 2, 4, 0, 6)\n)\n\n# For instance finding the number of columns selected\n# makes more semantic sense for pick() than across()\ndf |&gt;\n  summarise(\n    n_x = ncol(pick(starts_with(\"x\"))),\n    n_y = ncol(pick(starts_with(\"y\")))\n  )\n#&gt; # A tibble: 1 × 2\n#&gt;     n_x   n_y\n#&gt;   &lt;int&gt; &lt;int&gt;\n#&gt; 1     2     1\n\npick() is particularly useful in combination with ranking functions like dense_rank() that can take a data frame and rank the values.\n\ndf |&gt;\n  mutate(\n    rank1 = dense_rank(x_1), \n    rank2 = dense_rank(pick(x_1, y_2)) # Using `y_2` to break ties in `x_1`\n  )\n#&gt; # A tibble: 5 × 6\n#&gt;     x_1   x_2   w_4   y_2 rank1 rank2\n#&gt;   &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt;\n#&gt; 1     1     6    11     5     1     2\n#&gt; 2     3     7    12     2     3     5\n#&gt; 3     2     8    13     4     2     3\n#&gt; 4     1     9    14     0     1     1\n#&gt; 5     2    10    15     6     2     4\n\nYou can also use pick() as a bridge between tidy selection and data masking in functions. For instance, it is useful in creating a function with group_by(). See Data masking patters: Bridge patterns and the notes on the vignette.\n\nmy_group_by &lt;- function(data, cols) {\n  group_by(data, pick({{ cols }}))\n}\n\nmy_group_by(df, starts_with(\"x\"))\n#&gt; # A tibble: 5 × 4\n#&gt; # Groups:   x_1, x_2 [5]\n#&gt;     x_1   x_2   w_4   y_2\n#&gt;   &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;\n#&gt; 1     1     6    11     5\n#&gt; 2     3     7    12     2\n#&gt; 3     2     8    13     4\n#&gt; 4     1     9    14     0\n#&gt; 5     2    10    15     6\n\n\n6.6.2 reframe()\n\nreframe() is intended as a replacement for the ability to use summarise() to return multiple results per group that was introduced in dplyr 1.0.0. Now using summarise() to do this causes a warning. reframe() now takes on the role of “doing something” to each group with no restrictions on the number of rows returned per group.\nOne nice application of reframe() is computing quantiles at various probability thresholds.\n\ndf &lt;- tibble(\n  g = c(1, 1, 1, 2, 2),\n  x = c(4, 3, 6, 2, 8),\n  y = c(5, 1, 2, 8, 9)\n)\n\n# Helper function\nquantile_df &lt;- function(x, probs = c(0.25, 0.5, 0.75)) {\n  tibble(\n    value = quantile(x, probs, na.rm = TRUE),\n    prob = probs\n  )\n}\n\ndf |&gt;\n  reframe(quantile_df(x), .by = g)\n#&gt; # A tibble: 6 × 3\n#&gt;       g value  prob\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1   3.5  0.25\n#&gt; 2     1   4    0.5 \n#&gt; 3     1   5    0.75\n#&gt; 4     2   3.5  0.25\n#&gt; 5     2   5    0.5 \n#&gt; 6     2   6.5  0.75\n\nYou can apply such a function to multiple columns using across(), which returns a packed data frame. You can unnest this using the new .unpack argument from across().\n\ndf %&gt;%\n  reframe(across(x:y, quantile_df, .unpack = TRUE), .by = g)\n#&gt; # A tibble: 6 × 5\n#&gt;       g x_value x_prob y_value y_prob\n#&gt;   &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1     1     3.5   0.25    1.5    0.25\n#&gt; 2     1     4     0.5     2      0.5 \n#&gt; 3     1     5     0.75    3.5    0.75\n#&gt; 4     2     3.5   0.25    8.25   0.25\n#&gt; 5     2     5     0.5     8.5    0.5 \n#&gt; 6     2     6.5   0.75    8.75   0.75",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>dplyr 1.1.0</span>"
    ]
  },
  {
    "objectID": "01-forcats.html",
    "href": "01-forcats.html",
    "title": "7  forcats",
    "section": "",
    "text": "7.1 forcats resources\nThese notes use both the forcats vignette and the chapter from R for Data Science, but they focus more on the latter, which is more robust. The notes use the gss_cat data from forcats from the General Social Survey.\nlibrary(forcats)\nlibrary(dplyr)\nlibrary(ggplot2)",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>forcats</span>"
    ]
  },
  {
    "objectID": "01-forcats.html#sec-resources",
    "href": "01-forcats.html#sec-resources",
    "title": "7  forcats",
    "section": "",
    "text": "forcats website\nR for Data Science, Chapter 17: Factors\nIntroduction to forcats vignette\nMcNamara and Horton, “Wrangling categorical data in R”1",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>forcats</span>"
    ]
  },
  {
    "objectID": "01-forcats.html#sec-create",
    "href": "01-forcats.html#sec-create",
    "title": "7  forcats",
    "section": "\n7.2 Create factors",
    "text": "7.2 Create factors\nYou can create a factor from a character vector with base factor(), forcats::fct(), or base as.factor(), forcats::as_factor(). fct() is stricter than factor(); it errors if your specification of levels is inconsistent with the values in the character vector. as_factor() creates levels in the order in which they appear, not in alphabetical order by locale as in base R.\n\nfct(c(\"Dec\", \"Apr\", \"Jan\", \"Mar\"), levels = month.abb)\n#&gt; [1] Dec Apr Jan Mar\n#&gt; Levels: Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec\n\nYou can also create a factor when reading your data with readr::col_factor(). See the readr notes.\n\nlibrary(readr)\ncsv &lt;- \"\nmonth,value\nJan,12\nFeb,56\nMar,12\"\n\nread_csv(csv, col_types = list(month = col_factor(month.abb)))\n#&gt; # A tibble: 3 × 2\n#&gt;   month value\n#&gt;   &lt;fct&gt; &lt;dbl&gt;\n#&gt; 1 Jan      12\n#&gt; 2 Feb      56\n#&gt; 3 Mar      12\n\nWhen working with factors, the two most common operations are changing the order of the levels and changing the values of the levels.",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>forcats</span>"
    ]
  },
  {
    "objectID": "01-forcats.html#sec-order",
    "href": "01-forcats.html#sec-order",
    "title": "7  forcats",
    "section": "\n7.3 Modifying factor order",
    "text": "7.3 Modifying factor order\nModifying factor order is particularly useful for purposes of visualization so that the geoms are ordered by frequency or a specified value in the data.\nReordering functions:\n\nfct_infreq()\nfct_reorder()\nfct_reorder2()\nfct_relevel()\n\n\n7.3.1 fct_infreq()\n\nfct_infreq() is particularly useful for bar plots. It orders factor levels by the number of observations of each level, placing the largest first. It can be used with fct_rev() to reverse the order of the levels if you want smallest first.\n# fct_infreq\nggplot(gss_cat) +\n  geom_bar(aes(y = fct_infreq(marital)))\n\n# fct_rev\ngss_cat |&gt;\n  mutate(marital = marital |&gt; fct_infreq() |&gt; fct_rev()) |&gt;\n  ggplot() +\n  geom_bar(aes(y = marital))\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.3.2 fct_reorder()\n\nfct_reorder() reorders factor levels by sorting along another variable. This is only useful when factor levels have an arbitrary order such as alphabetical or first appearance.\nrelig_summary &lt;- gss_cat |&gt;\n  group_by(relig) |&gt;\n  summarize(\n    tvhours = mean(tvhours, na.rm = TRUE),\n    n = n()\n  )\n\n# Without reordering\nggplot(relig_summary) +\n  geom_point(aes(x = tvhours, y = relig))\n\n# Reorder relig levels by tvhours\nggplot(relig_summary) +\n  geom_point(aes(x = tvhours, y = fct_reorder(relig, tvhours)))\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.3.3 fct_reorder2()\n\nfct_reorder2() is useful for when a factor is mapped to a non-position aesthetic such as color. fct_reorder2(f, x, y) reorders the factor f by the y values associated with the largest x values. This makes the colors of the line at the far right of the plot line up with the legend.\n\nby_age &lt;- gss_cat |&gt;\n  filter(!is.na(age)) |&gt; \n  count(age, marital) |&gt;\n  group_by(age) |&gt;\n  mutate(prop = n / sum(n))\n\nggplot(by_age) +\n  geom_line(aes(x = age, y = prop, color = fct_reorder2(marital, age, prop)),\n            linewidth = 1) +\n  labs(color = \"marital\") \n\n\n\n\n\n\n\n\n7.3.4 fct_relevel()\n\nfct_relevel() manually moves levels. It can be used as a shortcut to move individual levels to the beginning of the order of levels. For instance, we can move “Not applicable” from the rincome variable to the front to be with the other non-answer types.\n\nrincome_summary &lt;- gss_cat |&gt;\n  group_by(rincome) |&gt;\n  summarize(\n    age = mean(age, na.rm = TRUE),\n    n = n()\n  )\n\nggplot(rincome_summary) +\n  geom_point(aes(x = age, y = fct_relevel(rincome, \"Not applicable\")))",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>forcats</span>"
    ]
  },
  {
    "objectID": "01-forcats.html#sec-level",
    "href": "01-forcats.html#sec-level",
    "title": "7  forcats",
    "section": "\n7.4 Modifying factor level",
    "text": "7.4 Modifying factor level\nModifying functions:\n\nfct_recode()\nfct_collapse()\nfct_lump_*()\n\n\n7.4.1 fct_recode()\n\nfct_recode() changes factor levels by hand. This is useful when the factor levels are abbreviations or shorthand that you want to change for presentation. fct_recode() will leave the levels that are not explicitly mentioned as is, and will warn you if you accidentally refer to a level that does not exist.\n\n# partyid levels are awkward\ngss_cat |&gt; count(partyid)\n#&gt; # A tibble: 10 × 2\n#&gt;    partyid                n\n#&gt;    &lt;fct&gt;              &lt;int&gt;\n#&gt;  1 No answer            154\n#&gt;  2 Don't know             1\n#&gt;  3 Other party          393\n#&gt;  4 Strong republican   2314\n#&gt;  5 Not str republican  3032\n#&gt;  6 Ind,near rep        1791\n#&gt;  7 Independent         4119\n#&gt;  8 Ind,near dem        2499\n#&gt;  9 Not str democrat    3690\n#&gt; 10 Strong democrat     3490\n\n# recode partyid levels\ngss_cat |&gt;\n  mutate(\n    partyid = fct_recode(partyid,\n      \"Republican, strong\"    = \"Strong republican\",\n      \"Republican, weak\"      = \"Not str republican\",\n      \"Independent, near rep\" = \"Ind,near rep\",\n      \"Independent, near dem\" = \"Ind,near dem\",\n      \"Democrat, weak\"        = \"Not str democrat\",\n      \"Democrat, strong\"      = \"Strong democrat\"\n    )\n  ) |&gt;\n  count(partyid)\n#&gt; # A tibble: 10 × 2\n#&gt;    partyid                   n\n#&gt;    &lt;fct&gt;                 &lt;int&gt;\n#&gt;  1 No answer               154\n#&gt;  2 Don't know                1\n#&gt;  3 Other party             393\n#&gt;  4 Republican, strong     2314\n#&gt;  5 Republican, weak       3032\n#&gt;  6 Independent, near rep  1791\n#&gt;  7 Independent            4119\n#&gt;  8 Independent, near dem  2499\n#&gt;  9 Democrat, weak         3690\n#&gt; 10 Democrat, strong       3490\n\n\n7.4.2 fct_collapse()\n\nYou can use fct_recode() to lump levels together, but you need to retype the new level multiple times. If you want to collapse multiple levels into a smaller number of levels, it is best to use fct_collapse().\n\ngss_cat |&gt;\n  mutate(\n    partyid = fct_collapse(partyid,\n      \"other\" = c(\"No answer\", \"Don't know\", \"Other party\"),\n      \"rep\" = c(\"Strong republican\", \"Not str republican\"),\n      \"ind\" = c(\"Ind,near rep\", \"Independent\", \"Ind,near dem\"),\n      \"dem\" = c(\"Not str democrat\", \"Strong democrat\")\n    )\n  ) |&gt;\n  count(partyid)\n#&gt; # A tibble: 4 × 2\n#&gt;   partyid     n\n#&gt;   &lt;fct&gt;   &lt;int&gt;\n#&gt; 1 other     548\n#&gt; 2 rep      5346\n#&gt; 3 ind      8409\n#&gt; 4 dem      7180\n\n\n7.4.3 fct_lump_*()\n\nUse the fct_lump_*() family of functions to quickly lump together small groups of factor levels to make a plot.\nfct_lump_lowfreq() progressively lumps the smallest groups categories into “Other”, always keeping “Other” as the smallest category. It is not overly useful in the case below, but it shows how it works.\n\ngss_cat |&gt;\n  mutate(relig = fct_lump_lowfreq(relig)) |&gt;\n  count(relig)\n#&gt; # A tibble: 2 × 2\n#&gt;   relig          n\n#&gt;   &lt;fct&gt;      &lt;int&gt;\n#&gt; 1 Protestant 10846\n#&gt; 2 Other      10637\n\nfct_lump_n() is more exact, allowing you to control the number of levels to end up with.\n\ngss_cat |&gt;\n  mutate(relig = fct_lump_n(relig, 10)) |&gt;\n  count(relig, sort = TRUE)\n#&gt; # A tibble: 10 × 2\n#&gt;    relig                       n\n#&gt;    &lt;fct&gt;                   &lt;int&gt;\n#&gt;  1 Protestant              10846\n#&gt;  2 Catholic                 5124\n#&gt;  3 None                     3523\n#&gt;  4 Christian                 689\n#&gt;  5 Other                     458\n#&gt;  6 Jewish                    388\n#&gt;  7 Buddhism                  147\n#&gt;  8 Inter-nondenominational   109\n#&gt;  9 Moslem/islam              104\n#&gt; 10 Orthodox-christian         95\n\nfct_lump_min() lumps levels that appear fewer than min times.\n\ngss_cat |&gt;\n  mutate(relig = fct_lump_min(relig, 100)) |&gt;\n  count(relig, sort = TRUE)\n#&gt; # A tibble: 9 × 2\n#&gt;   relig                       n\n#&gt;   &lt;fct&gt;                   &lt;int&gt;\n#&gt; 1 Protestant              10846\n#&gt; 2 Catholic                 5124\n#&gt; 3 None                     3523\n#&gt; 4 Christian                 689\n#&gt; 5 Other                     553\n#&gt; 6 Jewish                    388\n#&gt; 7 Buddhism                  147\n#&gt; 8 Inter-nondenominational   109\n#&gt; 9 Moslem/islam              104\n\nfct_lump_prop() lumps levels that appear in fewer than (or equal to) prop * n times.\n\ngss_cat |&gt;\n  mutate(relig = fct_lump_prop(relig, 0.01)) |&gt;\n  count(relig, sort = TRUE)\n#&gt; # A tibble: 6 × 2\n#&gt;   relig          n\n#&gt;   &lt;fct&gt;      &lt;int&gt;\n#&gt; 1 Protestant 10846\n#&gt; 2 Catholic    5124\n#&gt; 3 None        3523\n#&gt; 4 Other        913\n#&gt; 5 Christian    689\n#&gt; 6 Jewish       388\n\nfct_other() is a convenience function that manually recodes levels with “Other” if you want to do it by hand. You can either list the levels to keep or those to drop to convert to other.\n\ngss_cat |&gt;\n  mutate(relig = fct_other(relig, drop = c(\"Other eastern\"))) |&gt;\n  count(relig, sort = TRUE)\n#&gt; # A tibble: 14 × 2\n#&gt;    relig                       n\n#&gt;    &lt;fct&gt;                   &lt;int&gt;\n#&gt;  1 Protestant              10846\n#&gt;  2 Catholic                 5124\n#&gt;  3 None                     3523\n#&gt;  4 Christian                 689\n#&gt;  5 Jewish                    388\n#&gt;  6 Other                     256\n#&gt;  7 Buddhism                  147\n#&gt;  8 Inter-nondenominational   109\n#&gt;  9 Moslem/islam              104\n#&gt; 10 Orthodox-christian         95\n#&gt; 11 No answer                  93\n#&gt; 12 Hinduism                   71\n#&gt; 13 Native american            23\n#&gt; 14 Don't know                 15\n\n\n\n\n\nMcNamara, Amelia, and Nicholas J Horton. 2017. “Wrangling Categorical Data in R.” https://doi.org/10.7287/peerj.preprints.3163v2.",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>forcats</span>"
    ]
  },
  {
    "objectID": "01-forcats.html#footnotes",
    "href": "01-forcats.html#footnotes",
    "title": "7  forcats",
    "section": "",
    "text": "(McNamara and Horton 2017)↩︎",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>forcats</span>"
    ]
  },
  {
    "objectID": "01-lubridate.html",
    "href": "01-lubridate.html",
    "title": "8  Dates and times with lubridate",
    "section": "",
    "text": "8.1 Creating dates and date times",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dates and times with lubridate</span>"
    ]
  },
  {
    "objectID": "01-lubridate.html#sec-creating",
    "href": "01-lubridate.html#sec-creating",
    "title": "8  Dates and times with lubridate",
    "section": "",
    "text": "8.1.1 Getting the current date or time\n\n# lubridate\ntoday()\n#&gt; [1] \"2024-01-08\"\nnow()\n#&gt; [1] \"2024-01-08 16:51:52 MST\"\n\n# Base\nSys.Date()\n#&gt; [1] \"2024-01-08\"\nSys.time()\n#&gt; [1] \"2024-01-08 16:51:52 MST\"\n\n\n8.1.2 On import with readr\nIf your CSV contains an ISO8601 date or date-time, you do not need to do anything; readr will automatically recognize it.\nYou can also use col_date() with date components. Table Table 8.1 lists all the options.\n\n\nTable 8.1: All date formats understood by readr\n\n\n\nType\nCode\nMeaning\nExample\n\n\n\nYear\n%Y\n4 digit year\n2021\n\n\n\n%y\n2 digit year\n21\n\n\nMonth\n%m\nNumber\n2\n\n\n\n%b\nAbbreviated name\nFeb\n\n\n\n%B\nFull name\nFebruary\n\n\nDay\n%d\nTwo digits\n02\n\n\n\n%e\nOne or two digits\n2\n\n\nTime\n%H\n24-hour hour\n13\n\n\n\n%I\n12-hour hour\n1\n\n\n\n%p\nAM/PM\npm\n\n\n\n%M\nMinutes\n35\n\n\n\n%S\nSeconds\n45\n\n\n\n%OS\nSeconds with decimal component\n45.35\n\n\n\n%Z\nTime zone name\nAmerica/Chicago\n\n\n\n%z\nOffset from UTC\n+0800\n\n\nOther\n%.\nSkip one non-digit\n:\n\n\n\n%*\nSkip any number of non-digits\n\n\n\n\n\n\n\nSee the examples in the chapter on readr.\n\n8.1.3 From strings\nUsing lubridate helper functions that use y for year, m for month, and d for day.\n\nymd(\"2023-04-12\")\n#&gt; [1] \"2023-04-12\"\nmdy(\"April 12th, 2023\")\n#&gt; [1] \"2023-04-12\"\ndmy(\"12-Apr-2023\")\n#&gt; [1] \"2023-04-12\"\n\nFor a date time you add an underscore and h for hour, m for minute, and s for second.\n\nymd_hms(\"2023-04-12 09:32:24\")\n#&gt; [1] \"2023-04-12 09:32:24 UTC\"\nmdy_hm(\"04/12/2023 09:33\")\n#&gt; [1] \"2023-04-12 09:33:00 UTC\"\n\n\n8.1.4 From individual components\nUse of make_date()\n\nflights |&gt; \n  select(year, month, day, hour, minute)\n#&gt; # A tibble: 336,776 × 5\n#&gt;     year month   day  hour minute\n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt;\n#&gt;  1  2013     1     1     5     15\n#&gt;  2  2013     1     1     5     29\n#&gt;  3  2013     1     1     5     40\n#&gt;  4  2013     1     1     5     45\n#&gt;  5  2013     1     1     6      0\n#&gt;  6  2013     1     1     5     58\n#&gt;  7  2013     1     1     6      0\n#&gt;  8  2013     1     1     6      0\n#&gt;  9  2013     1     1     6      0\n#&gt; 10  2013     1     1     6      0\n#&gt; # ℹ 336,766 more rows\n\nflights |&gt; \n  select(year, month, day, hour, minute) |&gt; \n  mutate(departure = make_datetime(year, month, day, hour, minute))\n#&gt; # A tibble: 336,776 × 6\n#&gt;     year month   day  hour minute departure          \n#&gt;    &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dttm&gt;             \n#&gt;  1  2013     1     1     5     15 2013-01-01 05:15:00\n#&gt;  2  2013     1     1     5     29 2013-01-01 05:29:00\n#&gt;  3  2013     1     1     5     40 2013-01-01 05:40:00\n#&gt;  4  2013     1     1     5     45 2013-01-01 05:45:00\n#&gt;  5  2013     1     1     6      0 2013-01-01 06:00:00\n#&gt;  6  2013     1     1     5     58 2013-01-01 05:58:00\n#&gt;  7  2013     1     1     6      0 2013-01-01 06:00:00\n#&gt;  8  2013     1     1     6      0 2013-01-01 06:00:00\n#&gt;  9  2013     1     1     6      0 2013-01-01 06:00:00\n#&gt; 10  2013     1     1     6      0 2013-01-01 06:00:00\n#&gt; # ℹ 336,766 more rows\n\nflights lists most of the times in an odd format with hours and minutes combined into a single integer, so that 05:17 is 517. This can be split into hours and minutes with modulus arithmetic: h = x %/% 100 and m = x %% 100. We can create a function to create date times for departure and arrival times.\n\nmake_datetime_100 &lt;- function(year, month, day, time) {\n  make_datetime(year, month, day, time %/% 100, time %% 100)\n}\n\nflights_dt &lt;- flights |&gt; \n  filter(!is.na(dep_time), !is.na(arr_time)) |&gt; \n  mutate(\n    dep_time = make_datetime_100(year, month, day, dep_time),\n    arr_time = make_datetime_100(year, month, day, arr_time),\n    sched_dep_time = make_datetime_100(year, month, day, sched_dep_time),\n    sched_arr_time = make_datetime_100(year, month, day, sched_arr_time)\n  ) |&gt; \n  select(origin, dest, ends_with(\"delay\"), ends_with(\"time\"))\n\nflights_dt\n#&gt; # A tibble: 328,063 × 9\n#&gt;    origin dest  dep_delay arr_delay dep_time            sched_dep_time     \n#&gt;    &lt;chr&gt;  &lt;chr&gt;     &lt;dbl&gt;     &lt;dbl&gt; &lt;dttm&gt;              &lt;dttm&gt;             \n#&gt;  1 EWR    IAH           2        11 2013-01-01 05:17:00 2013-01-01 05:15:00\n#&gt;  2 LGA    IAH           4        20 2013-01-01 05:33:00 2013-01-01 05:29:00\n#&gt;  3 JFK    MIA           2        33 2013-01-01 05:42:00 2013-01-01 05:40:00\n#&gt;  4 JFK    BQN          -1       -18 2013-01-01 05:44:00 2013-01-01 05:45:00\n#&gt;  5 LGA    ATL          -6       -25 2013-01-01 05:54:00 2013-01-01 06:00:00\n#&gt;  6 EWR    ORD          -4        12 2013-01-01 05:54:00 2013-01-01 05:58:00\n#&gt;  7 EWR    FLL          -5        19 2013-01-01 05:55:00 2013-01-01 06:00:00\n#&gt;  8 LGA    IAD          -3       -14 2013-01-01 05:57:00 2013-01-01 06:00:00\n#&gt;  9 JFK    MCO          -3        -8 2013-01-01 05:57:00 2013-01-01 06:00:00\n#&gt; 10 LGA    ORD          -2         8 2013-01-01 05:58:00 2013-01-01 06:00:00\n#&gt; # ℹ 328,053 more rows\n#&gt; # ℹ 3 more variables: arr_time &lt;dttm&gt;, sched_arr_time &lt;dttm&gt;, air_time &lt;dbl&gt;\n\n\n8.1.5 From other types\nUse of as_datetime() and as_date() to switch between date-time and date.\n\nas_datetime(today())\n#&gt; [1] \"2024-01-08 UTC\"\nas_date(now())\n#&gt; [1] \"2024-01-08\"\n\nTo convert Unix Epoch to dates use as_datetime() if the offset is given in seconds and as_date() if it is given in days.",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dates and times with lubridate</span>"
    ]
  },
  {
    "objectID": "01-lubridate.html#sec-components",
    "href": "01-lubridate.html#sec-components",
    "title": "8  Dates and times with lubridate",
    "section": "\n8.2 Date-time components",
    "text": "8.2 Date-time components\n\n8.2.1 Getting components\nUse of helper functions to get components of a date or date-time:\n\nyear()\nmonth()\n\nmday() day of the month\n\nyday() day of the year\n\nwday() day of the week\nhour()\nminute()\nsecond()\n\n\ndatetime &lt;- ymd_hms(\"2023-04-12 09:49:56\")\n\nyear(datetime)\n#&gt; [1] 2023\nmonth(datetime)\n#&gt; [1] 4\nmday(datetime)\n#&gt; [1] 12\n\nyday(datetime)\n#&gt; [1] 102\nwday(datetime)\n#&gt; [1] 4\n\nFor month() and wday() you can set label = TRUE to return the abbreviated name of the month or day of the week. Set abbr = FALSE to return the full name.\n\nmonth(datetime, label = TRUE)\n#&gt; [1] Apr\n#&gt; 12 Levels: Jan &lt; Feb &lt; Mar &lt; Apr &lt; May &lt; Jun &lt; Jul &lt; Aug &lt; Sep &lt; ... &lt; Dec\nwday(datetime, label = TRUE, abbr = FALSE)\n#&gt; [1] Wednesday\n#&gt; 7 Levels: Sunday &lt; Monday &lt; Tuesday &lt; Wednesday &lt; Thursday &lt; ... &lt; Saturday\n\nThis can be used to plot flight departures by days of the week.\n\nflights_dt |&gt; \n  mutate(wday = wday(dep_time, label = TRUE)) |&gt; \n  ggplot(aes(x = wday)) +\n  geom_bar()\n\n\n\n\n\n\n\n\n8.2.2 Rounding\nUse of floor_date(), round_date(), and ceiling_date() to round dates to a given unit.\nValid units for rounding: second, minute, hour, day, week, month, bimonth, quarter, season, halfyear and year, or a Period object.\nWith rounding you can plot the number of flights per week:\n\nflights_dt |&gt; \n  count(week = floor_date(dep_time, \"week\")) |&gt; \n  ggplot(aes(x = week, y = n)) +\n  geom_line() + \n  geom_point()\n\n\n\n\n\n\n\n\n8.2.3 Modifying components\nModifying individual components:\n\ndatetime\n#&gt; [1] \"2023-04-12 09:49:56 UTC\"\n\nyear(datetime) &lt;- 2030\nmonth(datetime) &lt;- 01\nhour(datetime) &lt;- hour(datetime) + 1\ndatetime\n#&gt; [1] \"2030-01-12 10:49:56 UTC\"\n\nOr you can create a new date-time with update():\n\nupdate(datetime, year = 2023, month = 04, hour = 10, minute = 23)\n#&gt; [1] \"2023-04-12 10:23:56 UTC\"",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dates and times with lubridate</span>"
    ]
  },
  {
    "objectID": "01-lubridate.html#sec-spans",
    "href": "01-lubridate.html#sec-spans",
    "title": "8  Dates and times with lubridate",
    "section": "\n8.3 Time spans",
    "text": "8.3 Time spans\nArithmetic with math leads to the use of three classes that represent time spans.\n\n\nDurations: represent an exact number of seconds.\n\nPeriods: represent human units like weeks and months.\n\nIntervals: represent a starting and ending point.\n\n\n8.3.1 Durations\nArithmetic with dates in R creates a difftime object, which records a time span of seconds, minutes, hours, days, or weeks. This can lead to ambiguity, so lubridate provides Duration, which always records time spans in seconds.\n\n# Base difftime\nage &lt;- today() - ymd(\"1983-03-28\")\nage\n#&gt; Time difference of 14896 days\n\n# duration\nas.duration(age)\n#&gt; [1] \"1287014400s (~40.78 years)\"\n\nDurations have a variety of constructors.\n\ndminutes(10)\n#&gt; [1] \"600s (~10 minutes)\"\nddays(0:5)\n#&gt; [1] \"0s\"                \"86400s (~1 days)\"  \"172800s (~2 days)\"\n#&gt; [4] \"259200s (~3 days)\" \"345600s (~4 days)\" \"432000s (~5 days)\"\n\nNote that because durations are seconds there can be some ambiguity with larger units. Months cannot be calculated and years are set to an average of 365.25 days.\n\n8.3.2 Periods\nTo deal with the ambiguities of Duration lubridate implements the [Period type](https://lubridate.tidyverse.org/reference/index.html#periods. Period constructors:\n\nseconds()\nminutes()\nhours()\ndays()\nweeks()\nmonths()\nyears()\n\n\nhours(c(12, 24))\n#&gt; [1] \"12H 0M 0S\" \"24H 0M 0S\"\ndays(7)\n#&gt; [1] \"7d 0H 0M 0S\"\n10 * (months(6) + days(1))\n#&gt; [1] \"60m 10d 0H 0M 0S\"\n\nCompared to durations, periods are more likely to do what you expect:\n\n# A leap year\nymd(\"2024-01-01\") + dyears(1)\n#&gt; [1] \"2024-12-31 06:00:00 UTC\"\nymd(\"2024-01-01\") + years(1)\n#&gt; [1] \"2025-01-01\"\n\n# Daylight Savings Time\none_am &lt;- ymd_hms(\"2026-03-08 01:00:00\", tz = \"America/New_York\")\none_am + ddays(1)\n#&gt; [1] \"2026-03-09 02:00:00 EDT\"\none_am + days(1)\n#&gt; [1] \"2026-03-09 01:00:00 EDT\"\n\nCan use periods to fix a problem in the flights_dt data. Overnight flights appear to arrive before they depart because the date was calculated on the departure date. This can be fixed by adding days(1) to the arrival times of overnight flights using the fact that TRUE == 1.\n\n# Number of overnight flights\nflights_dt |&gt; \n  filter(arr_time &lt; dep_time) |&gt; \n  nrow()\n#&gt; [1] 10633\n\nflights_dt &lt;- flights_dt |&gt; \n  mutate(\n    overnight = arr_time &lt; dep_time,\n    arr_time = arr_time + days(overnight),\n    sched_arr_time = sched_arr_time + days(overnight)\n  )\n\n# Now fixed\nflights_dt |&gt; \n  filter(arr_time &lt; dep_time) |&gt; \n  nrow()\n#&gt; [1] 0\n\n\n8.3.3 Intervals\nFor accurate measurement between specific dates and date-times you can use intervals.\nCreate an intervalby writing start %--% end:\n\n# Periods use estimates of length\nyears(1) / days(1)\n#&gt; [1] 365.25\n\n# Intervals are specific\ny2023 &lt;- ymd(\"2023-01-01\") %--% ymd(\"2024-01-01\")\ny2024 &lt;- ymd(\"2024-01-01\") %--% ymd(\"2025-01-01\")\n\ny2023 / days(1)\n#&gt; [1] 365\ny2024 / days(1)\n#&gt; [1] 366",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dates and times with lubridate</span>"
    ]
  },
  {
    "objectID": "01-lubridate.html#sec-zones",
    "href": "01-lubridate.html#sec-zones",
    "title": "8  Dates and times with lubridate",
    "section": "\n8.4 Time zones",
    "text": "8.4 Time zones\nR uses the international standard IANA time zones. These use a consistent naming scheme {area}/{location}, typically in the form {continent}/{city} or {ocean}/{city}. These two pieces of information are useful for recording the history of how time zones might change in different places. You can see this in the IANA database of time zones.\n\n# Locale time zone\nSys.timezone()\n#&gt; [1] \"America/Mazatlan\"\n\n# List of time zones\nhead(OlsonNames())\n#&gt; [1] \"Africa/Abidjan\"     \"Africa/Accra\"       \"Africa/Addis_Ababa\"\n#&gt; [4] \"Africa/Algiers\"     \"Africa/Asmara\"      \"Africa/Asmera\"\n\nTime zones only affect printing, not the recording of the actual time.\n\nx &lt;- ymd_hms(\"2023-04-12 11:23:00\", tz = \"America/New_York\")\ny &lt;- ymd_hms(\"2023-04-12 17:23:00\", tz = \"Europe/Copenhagen\")\n\nx - y\n#&gt; Time difference of 0 secs\n\nlubridate uses UTC (Coordinated Universal Time) as a default. UTC is roughly equivalent to GMT (Greenwich Mean Time), but it does not have DST, which makes a convenient representation for computation.\nYou can change time zones by either changing how it is displayed or altering the underlying instant in time. c() drops time zones and displays them in your locale.\n\n# Convert to local time zone\nz &lt;- c(x, y)\n\n# Change time zone representation\nza &lt;- with_tz(z, tzone = \"Australia/Lord_Howe\")\nza\n#&gt; [1] \"2023-04-13 01:53:00 +1030\" \"2023-04-13 01:53:00 +1030\"\n\nz - za\n#&gt; Time differences in secs\n#&gt; [1] 0 0\n\n# Change instant and time zone\nzb &lt;- force_tz(z, tzone = \"Australia/Lord_Howe\")\nzb\n#&gt; [1] \"2023-04-12 11:23:00 +1030\" \"2023-04-12 11:23:00 +1030\"\n\nz - zb\n#&gt; Time differences in hours\n#&gt; [1] 14.5 14.5",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Dates and times with lubridate</span>"
    ]
  },
  {
    "objectID": "01-tidy-data.html",
    "href": "01-tidy-data.html",
    "title": "9  Tidy data",
    "section": "",
    "text": "9.1 Tidy data: Definition\n“Tidy data is a standard way of mapping the meaning of a dataset to its structure. A dataset is messy or tidy depending on how rows, columns and tables are matched up with observations, variables and types.”",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tidy data</span>"
    ]
  },
  {
    "objectID": "01-tidy-data.html#sec-definition",
    "href": "01-tidy-data.html#sec-definition",
    "title": "9  Tidy data",
    "section": "",
    "text": "Every column is a variable.\nEvery row is an observation.\nEvery cell is a single value.",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tidy data</span>"
    ]
  },
  {
    "objectID": "01-tidy-data.html#sec-structure",
    "href": "01-tidy-data.html#sec-structure",
    "title": "9  Tidy data",
    "section": "\n9.2 The structure and semantics of data",
    "text": "9.2 The structure and semantics of data\nStructure of rows and columns does little to help us define whether data is tidy or not and how they relate to each other. This can be seen in representing some typical data from a classroom in two different ways that are typical for how such data might be entered.\n\nclassroom &lt;- tribble(\n  ~name,    ~quiz1, ~quiz2, ~test1,\n  \"Billy\",  NA,     \"D\",    \"C\",\n  \"Suzy\",   \"F\",    NA,     NA,\n  \"Lionel\", \"B\",    \"C\",    \"B\",\n  \"Jenny\",  \"A\",    \"A\",    \"B\"\n  )\nclassroom\n#&gt; # A tibble: 4 × 4\n#&gt;   name   quiz1 quiz2 test1\n#&gt;   &lt;chr&gt;  &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;\n#&gt; 1 Billy  &lt;NA&gt;  D     C    \n#&gt; 2 Suzy   F     &lt;NA&gt;  &lt;NA&gt; \n#&gt; 3 Lionel B     C     B    \n#&gt; 4 Jenny  A     A     B\n\ntribble(\n  ~assessment, ~Billy, ~Suzy, ~Lionel, ~Jenny,\n  \"quiz1\",     NA,     \"F\",   \"B\",     \"A\",\n  \"quiz2\",     \"D\",    NA,    \"C\",     \"A\",\n  \"test1\",     \"C\",    NA,    \"B\",     \"B\"\n  )\n#&gt; # A tibble: 3 × 5\n#&gt;   assessment Billy Suzy  Lionel Jenny\n#&gt;   &lt;chr&gt;      &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;\n#&gt; 1 quiz1      &lt;NA&gt;  F     B      A    \n#&gt; 2 quiz2      D     &lt;NA&gt;  C      A    \n#&gt; 3 test1      C     &lt;NA&gt;  B      B\n\nTo better define tidy data we can break data into values organized into observations and variables.\n\nValues: Usually either numbers (if quantitative) or strings (if qualitative).\nVariable: contains all values that measure the same underlying attribute (like height, temperature, duration) across units.\nObservation: contains all values measured on the same unit (like a person, or a day, or a race) across attributes.\n\nThe consequence of this definition of tidy data can be seen by making the classroom data tidy.\n\nclassroom |&gt; \n  pivot_longer(quiz1:test1, names_to = \"assessment\", values_to = \"grade\") |&gt; \n  arrange(name, assessment)\n#&gt; # A tibble: 12 × 3\n#&gt;    name   assessment grade\n#&gt;    &lt;chr&gt;  &lt;chr&gt;      &lt;chr&gt;\n#&gt;  1 Billy  quiz1      &lt;NA&gt; \n#&gt;  2 Billy  quiz2      D    \n#&gt;  3 Billy  test1      C    \n#&gt;  4 Jenny  quiz1      A    \n#&gt;  5 Jenny  quiz2      A    \n#&gt;  6 Jenny  test1      B    \n#&gt;  7 Lionel quiz1      B    \n#&gt;  8 Lionel quiz2      C    \n#&gt;  9 Lionel test1      B    \n#&gt; 10 Suzy   quiz1      F    \n#&gt; 11 Suzy   quiz2      &lt;NA&gt; \n#&gt; 12 Suzy   test1      &lt;NA&gt;\n\nThis structure of data is more repetitive, but it is easier to compute on and break down into variables and observations:\n\nVariables: name, type of assessment, and grade\n\nObservations: The grade given to each student for each test.\n\nIt is often trivial to define variables and observations in a given context, but it is difficult to do so in general. Whether a value should be a different onservation or a different variable is often dependent upon the context of the data.\n“Tidy data is particularly well suited for vectorised programming languages like R, because the layout ensures that values of different variables from the same observation are always paired.”",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tidy data</span>"
    ]
  },
  {
    "objectID": "01-tidy-data.html#sec-messy-data",
    "href": "01-tidy-data.html#sec-messy-data",
    "title": "9  Tidy data",
    "section": "\n9.3 Tidying messy datasets",
    "text": "9.3 Tidying messy datasets\nFive types of messy data:\n\nColumn headers are values, not variable names\nMultiple variables stored in one column\nVariables are stored in both rows and columns\nMultiple types in one table\nOne type in multiple tables\n\n\n9.3.1 Column headers are values, not variable names\nHaving values in column headers can be a nice way to present data and can be efficient for computing if you can perform matrix expressions on the data.\n\nrelig_income\n#&gt; # A tibble: 18 × 11\n#&gt;    religion `&lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\n#&gt;    &lt;chr&gt;      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n#&gt;  1 Agnostic      27        34        60        81        76       137        122\n#&gt;  2 Atheist       12        27        37        52        35        70         73\n#&gt;  3 Buddhist      27        21        30        34        33        58         62\n#&gt;  4 Catholic     418       617       732       670       638      1116        949\n#&gt;  5 Don’t k…      15        14        15        11        10        35         21\n#&gt;  6 Evangel…     575       869      1064       982       881      1486        949\n#&gt;  7 Hindu          1         9         7         9        11        34         47\n#&gt;  8 Histori…     228       244       236       238       197       223        131\n#&gt;  9 Jehovah…      20        27        24        24        21        30         15\n#&gt; 10 Jewish        19        19        25        25        30        95         69\n#&gt; 11 Mainlin…     289       495       619       655       651      1107        939\n#&gt; 12 Mormon        29        40        48        51        56       112         85\n#&gt; 13 Muslim         6         7         9        10         9        23         16\n#&gt; 14 Orthodox      13        17        23        32        32        47         38\n#&gt; 15 Other C…       9         7        11        13        13        14         18\n#&gt; 16 Other F…      20        33        40        46        49        63         46\n#&gt; 17 Other W…       5         2         3         4         2         7          3\n#&gt; 18 Unaffil…     217       299       374       365       341       528        407\n#&gt; # ℹ 3 more variables: `$100-150k` &lt;dbl&gt;, `&gt;150k` &lt;dbl&gt;,\n#&gt; #   `Don't know/refused` &lt;dbl&gt;\n\nThe structure of the data frame is 11 columns that are actually variables, 18 religious groups, and the frequencies of the two other variables. To tidy the data the data frame needs to be pivoted to a longer format in which the column names into a key-value pairs.\n\nrelig_income |&gt; \n  pivot_longer(-religion, names_to = \"income\", values_to = \"frequency\")\n#&gt; # A tibble: 180 × 3\n#&gt;    religion income             frequency\n#&gt;    &lt;chr&gt;    &lt;chr&gt;                  &lt;dbl&gt;\n#&gt;  1 Agnostic &lt;$10k                     27\n#&gt;  2 Agnostic $10-20k                   34\n#&gt;  3 Agnostic $20-30k                   60\n#&gt;  4 Agnostic $30-40k                   81\n#&gt;  5 Agnostic $40-50k                   76\n#&gt;  6 Agnostic $50-75k                  137\n#&gt;  7 Agnostic $75-100k                 122\n#&gt;  8 Agnostic $100-150k                109\n#&gt;  9 Agnostic &gt;150k                     84\n#&gt; 10 Agnostic Don't know/refused        96\n#&gt; # ℹ 170 more rows\n\nA good example of this kind of data is found in billboard, which records the ranking of songs after they crack the Billboard top 100 for 75 weeks. This form is not tidy, but it is good for data entry, as it reduces duplication of data. Here, there is a bit of extra tidying to do to make the variables more conducive to the tidy structure.\n\nbillboard\n#&gt; # A tibble: 317 × 79\n#&gt;    artist     track date.entered   wk1   wk2   wk3   wk4   wk5   wk6   wk7   wk8\n#&gt;    &lt;chr&gt;      &lt;chr&gt; &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1 2 Pac      Baby… 2000-02-26      87    82    72    77    87    94    99    NA\n#&gt;  2 2Ge+her    The … 2000-09-02      91    87    92    NA    NA    NA    NA    NA\n#&gt;  3 3 Doors D… Kryp… 2000-04-08      81    70    68    67    66    57    54    53\n#&gt;  4 3 Doors D… Loser 2000-10-21      76    76    72    69    67    65    55    59\n#&gt;  5 504 Boyz   Wobb… 2000-04-15      57    34    25    17    17    31    36    49\n#&gt;  6 98^0       Give… 2000-08-19      51    39    34    26    26    19     2     2\n#&gt;  7 A*Teens    Danc… 2000-07-08      97    97    96    95   100    NA    NA    NA\n#&gt;  8 Aaliyah    I Do… 2000-01-29      84    62    51    41    38    35    35    38\n#&gt;  9 Aaliyah    Try … 2000-03-18      59    53    38    28    21    18    16    14\n#&gt; 10 Adams, Yo… Open… 2000-08-26      76    76    74    69    68    67    61    58\n#&gt; # ℹ 307 more rows\n#&gt; # ℹ 68 more variables: wk9 &lt;dbl&gt;, wk10 &lt;dbl&gt;, wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;,\n#&gt; #   wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;,\n#&gt; #   wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;,\n#&gt; #   wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, wk28 &lt;dbl&gt;, wk29 &lt;dbl&gt;, wk30 &lt;dbl&gt;,\n#&gt; #   wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, wk34 &lt;dbl&gt;, wk35 &lt;dbl&gt;, wk36 &lt;dbl&gt;,\n#&gt; #   wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;, wk40 &lt;dbl&gt;, wk41 &lt;dbl&gt;, wk42 &lt;dbl&gt;, …\n\nbillboard_long &lt;- billboard |&gt; \n  pivot_longer(\n    wk1:wk76, \n    names_to = \"week\", \n    values_to = \"rank\", \n    values_drop_na = TRUE\n  ) |&gt; \n  mutate(\n    week = as.integer(gsub(\"wk\", \"\", week)),\n    date = as.Date(date.entered) + 7 * (week - 1),\n    date.entered = NULL\n  )\nbillboard_long \n#&gt; # A tibble: 5,307 × 5\n#&gt;    artist  track                    week  rank date      \n#&gt;    &lt;chr&gt;   &lt;chr&gt;                   &lt;int&gt; &lt;dbl&gt; &lt;date&gt;    \n#&gt;  1 2 Pac   Baby Don't Cry (Keep...     1    87 2000-02-26\n#&gt;  2 2 Pac   Baby Don't Cry (Keep...     2    82 2000-03-04\n#&gt;  3 2 Pac   Baby Don't Cry (Keep...     3    72 2000-03-11\n#&gt;  4 2 Pac   Baby Don't Cry (Keep...     4    77 2000-03-18\n#&gt;  5 2 Pac   Baby Don't Cry (Keep...     5    87 2000-03-25\n#&gt;  6 2 Pac   Baby Don't Cry (Keep...     6    94 2000-04-01\n#&gt;  7 2 Pac   Baby Don't Cry (Keep...     7    99 2000-04-08\n#&gt;  8 2Ge+her The Hardest Part Of ...     1    91 2000-09-02\n#&gt;  9 2Ge+her The Hardest Part Of ...     2    87 2000-09-09\n#&gt; 10 2Ge+her The Hardest Part Of ...     3    92 2000-09-16\n#&gt; # ℹ 5,297 more rows\n\n\n9.3.2 Multiple variables stored in one column\nSometimes there are more than one variable stored in each column. This is the case in the tb (tuberculosis) that comes from the World Health Organization. It shows tuberculosis cases by country, year, and demographic group that includes both gender m or f and age group.\n\ntb &lt;- read_csv(\"data/tb.csv\")\n#&gt; Rows: 5769 Columns: 22\n#&gt; ── Column specification ────────────────────────────────────────────────────────\n#&gt; Delimiter: \",\"\n#&gt; chr  (1): iso2\n#&gt; dbl (21): year, m04, m514, m014, m1524, m2534, m3544, m4554, m5564, m65, mu,...\n#&gt; \n#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\ntb\n#&gt; # A tibble: 5,769 × 22\n#&gt;    iso2   year   m04  m514  m014 m1524 m2534 m3544 m4554 m5564   m65    mu   f04\n#&gt;    &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1 AD     1989    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n#&gt;  2 AD     1990    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n#&gt;  3 AD     1991    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n#&gt;  4 AD     1992    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n#&gt;  5 AD     1993    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n#&gt;  6 AD     1994    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA    NA\n#&gt;  7 AD     1996    NA    NA     0     0     0     4     1     0     0    NA    NA\n#&gt;  8 AD     1997    NA    NA     0     0     1     2     2     1     6    NA    NA\n#&gt;  9 AD     1998    NA    NA     0     0     0     1     0     0     0    NA    NA\n#&gt; 10 AD     1999    NA    NA     0     0     0     1     1     0     0    NA    NA\n#&gt; # ℹ 5,759 more rows\n#&gt; # ℹ 9 more variables: f514 &lt;dbl&gt;, f014 &lt;dbl&gt;, f1524 &lt;dbl&gt;, f2534 &lt;dbl&gt;,\n#&gt; #   f3544 &lt;dbl&gt;, f4554 &lt;dbl&gt;, f5564 &lt;dbl&gt;, f65 &lt;dbl&gt;, fu &lt;dbl&gt;\n\nThe transformation to pivot longer and split the header variable can be done in a single step by supplying multiple column names to names_to and also supplying a grouped regular expression to names_pattern to split the variable after the first character.\n\ntb %&gt;% pivot_longer(\n  !c(iso2, year), \n  names_to = c(\"sex\", \"age\"), \n  names_pattern = \"(.)(.+)\",\n  values_to = \"n\", \n  values_drop_na = TRUE\n)\n#&gt; # A tibble: 35,750 × 5\n#&gt;    iso2   year sex   age       n\n#&gt;    &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt;  1 AD     1996 m     014       0\n#&gt;  2 AD     1996 m     1524      0\n#&gt;  3 AD     1996 m     2534      0\n#&gt;  4 AD     1996 m     3544      4\n#&gt;  5 AD     1996 m     4554      1\n#&gt;  6 AD     1996 m     5564      0\n#&gt;  7 AD     1996 m     65        0\n#&gt;  8 AD     1996 f     014       0\n#&gt;  9 AD     1996 f     1524      1\n#&gt; 10 AD     1996 f     2534      1\n#&gt; # ℹ 35,740 more rows\n\n\n9.3.3 Variables are stored in both rows and columns\nA complex form of messy data is when variables are stored in both rows and columns. This occurs in weather data recording max and min temperatures in day columns.\n\nweather &lt;- read_csv(\"data/weather.csv\")\n#&gt; Rows: 22 Columns: 35\n#&gt; ── Column specification ────────────────────────────────────────────────────────\n#&gt; Delimiter: \",\"\n#&gt; chr  (2): id, element\n#&gt; dbl (25): year, month, d1, d2, d3, d4, d5, d6, d7, d8, d10, d11, d13, d14, d...\n#&gt; lgl  (8): d9, d12, d18, d19, d20, d21, d22, d24\n#&gt; \n#&gt; ℹ Use `spec()` to retrieve the full column specification for this data.\n#&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\nweather\n#&gt; # A tibble: 22 × 35\n#&gt;    id       year month element    d1    d2    d3    d4    d5    d6    d7    d8\n#&gt;    &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1 MX17004  2010     1 tmax       NA  NA    NA      NA  NA      NA    NA    NA\n#&gt;  2 MX17004  2010     1 tmin       NA  NA    NA      NA  NA      NA    NA    NA\n#&gt;  3 MX17004  2010     2 tmax       NA  27.3  24.1    NA  NA      NA    NA    NA\n#&gt;  4 MX17004  2010     2 tmin       NA  14.4  14.4    NA  NA      NA    NA    NA\n#&gt;  5 MX17004  2010     3 tmax       NA  NA    NA      NA  32.1    NA    NA    NA\n#&gt;  6 MX17004  2010     3 tmin       NA  NA    NA      NA  14.2    NA    NA    NA\n#&gt;  7 MX17004  2010     4 tmax       NA  NA    NA      NA  NA      NA    NA    NA\n#&gt;  8 MX17004  2010     4 tmin       NA  NA    NA      NA  NA      NA    NA    NA\n#&gt;  9 MX17004  2010     5 tmax       NA  NA    NA      NA  NA      NA    NA    NA\n#&gt; 10 MX17004  2010     5 tmin       NA  NA    NA      NA  NA      NA    NA    NA\n#&gt; # ℹ 12 more rows\n#&gt; # ℹ 23 more variables: d9 &lt;lgl&gt;, d10 &lt;dbl&gt;, d11 &lt;dbl&gt;, d12 &lt;lgl&gt;, d13 &lt;dbl&gt;,\n#&gt; #   d14 &lt;dbl&gt;, d15 &lt;dbl&gt;, d16 &lt;dbl&gt;, d17 &lt;dbl&gt;, d18 &lt;lgl&gt;, d19 &lt;lgl&gt;,\n#&gt; #   d20 &lt;lgl&gt;, d21 &lt;lgl&gt;, d22 &lt;lgl&gt;, d23 &lt;dbl&gt;, d24 &lt;lgl&gt;, d25 &lt;dbl&gt;,\n#&gt; #   d26 &lt;dbl&gt;, d27 &lt;dbl&gt;, d28 &lt;dbl&gt;, d29 &lt;dbl&gt;, d30 &lt;dbl&gt;, d31 &lt;dbl&gt;\n\nTo deal with this dual nature of the data we need to pivot the day variables longer to get the temperature readings in a column and then pivot the element column wider to split the temperature readings between min and max.\n\n# Pivot-longer: day columns\nweather_longer &lt;- weather |&gt; \n  pivot_longer(\n    d1:d31, \n    names_to = \"day\", \n    values_to = \"value\", \n    values_drop_na = TRUE\n  ) |&gt; \n  mutate(\n    date = ymd(paste(year, month, gsub(\"d\", \"\", day), sep = \"-\"))\n  ) |&gt; \n  select(id, date, element, value) |&gt; \n  arrange(date)\nweather_longer\n#&gt; # A tibble: 66 × 4\n#&gt;    id      date       element value\n#&gt;    &lt;chr&gt;   &lt;date&gt;     &lt;chr&gt;   &lt;dbl&gt;\n#&gt;  1 MX17004 2010-01-30 tmax     27.8\n#&gt;  2 MX17004 2010-01-30 tmin     14.5\n#&gt;  3 MX17004 2010-02-02 tmax     27.3\n#&gt;  4 MX17004 2010-02-02 tmin     14.4\n#&gt;  5 MX17004 2010-02-03 tmax     24.1\n#&gt;  6 MX17004 2010-02-03 tmin     14.4\n#&gt;  7 MX17004 2010-02-11 tmax     29.7\n#&gt;  8 MX17004 2010-02-11 tmin     13.4\n#&gt;  9 MX17004 2010-02-23 tmax     29.9\n#&gt; 10 MX17004 2010-02-23 tmin     10.7\n#&gt; # ℹ 56 more rows\n\n# Pivot-wider: element column\nweather_longer |&gt; \n  pivot_wider(names_from = element, values_from = value)\n#&gt; # A tibble: 33 × 4\n#&gt;    id      date        tmax  tmin\n#&gt;    &lt;chr&gt;   &lt;date&gt;     &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1 MX17004 2010-01-30  27.8  14.5\n#&gt;  2 MX17004 2010-02-02  27.3  14.4\n#&gt;  3 MX17004 2010-02-03  24.1  14.4\n#&gt;  4 MX17004 2010-02-11  29.7  13.4\n#&gt;  5 MX17004 2010-02-23  29.9  10.7\n#&gt;  6 MX17004 2010-03-05  32.1  14.2\n#&gt;  7 MX17004 2010-03-10  34.5  16.8\n#&gt;  8 MX17004 2010-03-16  31.1  17.6\n#&gt;  9 MX17004 2010-04-27  36.3  16.7\n#&gt; 10 MX17004 2010-05-27  33.2  18.2\n#&gt; # ℹ 23 more rows\n\n\n9.3.4 Multiple types in one table\nThis occurs when multiple observational units are stored on one table instead of in multiple tables. One simple example of this is in the billboard data where there is information about both the song and its ranking on the billboard list. This leads to duplication of information about the artist in this case. It would be better to divide this information into two tables linked through a song id.\n\n# Song table\nsong &lt;- billboard_long |&gt; \n  distinct(artist, track) |&gt;\n  mutate(song_id = row_number())\nsong\n#&gt; # A tibble: 317 × 3\n#&gt;    artist         track                   song_id\n#&gt;    &lt;chr&gt;          &lt;chr&gt;                     &lt;int&gt;\n#&gt;  1 2 Pac          Baby Don't Cry (Keep...       1\n#&gt;  2 2Ge+her        The Hardest Part Of ...       2\n#&gt;  3 3 Doors Down   Kryptonite                    3\n#&gt;  4 3 Doors Down   Loser                         4\n#&gt;  5 504 Boyz       Wobble Wobble                 5\n#&gt;  6 98^0           Give Me Just One Nig...       6\n#&gt;  7 A*Teens        Dancing Queen                 7\n#&gt;  8 Aaliyah        I Don't Wanna                 8\n#&gt;  9 Aaliyah        Try Again                     9\n#&gt; 10 Adams, Yolanda Open My Heart                10\n#&gt; # ℹ 307 more rows\n\n# Rank table\nrank &lt;- billboard_long |&gt; \n  left_join(song, c(\"artist\", \"track\")) |&gt;\n  select(song_id, date, week, rank)\nrank\n#&gt; # A tibble: 5,307 × 4\n#&gt;    song_id date        week  rank\n#&gt;      &lt;int&gt; &lt;date&gt;     &lt;int&gt; &lt;dbl&gt;\n#&gt;  1       1 2000-02-26     1    87\n#&gt;  2       1 2000-03-04     2    82\n#&gt;  3       1 2000-03-11     3    72\n#&gt;  4       1 2000-03-18     4    77\n#&gt;  5       1 2000-03-25     5    87\n#&gt;  6       1 2000-04-01     6    94\n#&gt;  7       1 2000-04-08     7    99\n#&gt;  8       2 2000-09-02     1    91\n#&gt;  9       2 2000-09-09     2    87\n#&gt; 10       2 2000-09-16     3    92\n#&gt; # ℹ 5,297 more rows\n\n\n9.3.5 One type in multiple tables\nSometimes an observational unit is spread among many tables that might be split by a variable such as person, year, location, etc. The fix for this is to bring the tables together and tidy:\n\nRead the files into a list of tables.\nFor each table, add a new column that records the original file name (the file name is often the value of an important variable).\nCombine all tables into a single table.\n\nThis can be done with purrr\n\npaths &lt;- dir(\"data\", pattern = \"\\\\.csv$\", full.names = TRUE)\nnames(paths) &lt;- basename(paths)\nmap_dfr(paths, read.csv, stringsAsFactors = FALSE, .id = \"filename\")\n\n\n\n\n\nWickham, Hadley. 2014. “Tidy Data.” Journal of Statistical Software 59 (10). https://doi.org/10.18637/jss.v059.i10.",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tidy data</span>"
    ]
  },
  {
    "objectID": "01-tidyr-pivoting.html",
    "href": "01-tidyr-pivoting.html",
    "title": "10  tidyr: Pivoting",
    "section": "",
    "text": "10.1 Longer\npivot_longer() makes datasets longer by increasing the number of rows and decreasing the number of columns.\npivot_longer() arguments:",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>tidyr: Pivoting</span>"
    ]
  },
  {
    "objectID": "01-tidyr-pivoting.html#sec-longer",
    "href": "01-tidyr-pivoting.html#sec-longer",
    "title": "10  tidyr: Pivoting",
    "section": "",
    "text": "data\n\ncols: Columns to pivot into longer format.\n\nnames_to: The new column or columns to create from the information stored in the column names of data specified by cols.\n\nvalues_to: The name of the column to create from the data stored in cell values.\n\nnames_prefix: A regular expression used to remove matching text from the start of each variable name.\n\nnames_transform: Either a single function applied to all columns or a list of column name-function pairs.\n\nnames_sep, names_pattern: Control how the column name is broken up when multiple names are passed to names_to.\n\n\nnames_sep: Either a numeric vector of where to split or regular expression.\n\nnames_pattern: A regular expression containing matching groups.\n\n\n\n\n10.1.1 String data in column names\nData: relig_income\n\nrelig_income\n#&gt; # A tibble: 18 × 11\n#&gt;    religion `&lt;$10k` `$10-20k` `$20-30k` `$30-40k` `$40-50k` `$50-75k` `$75-100k`\n#&gt;    &lt;chr&gt;      &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;\n#&gt;  1 Agnostic      27        34        60        81        76       137        122\n#&gt;  2 Atheist       12        27        37        52        35        70         73\n#&gt;  3 Buddhist      27        21        30        34        33        58         62\n#&gt;  4 Catholic     418       617       732       670       638      1116        949\n#&gt;  5 Don’t k…      15        14        15        11        10        35         21\n#&gt;  6 Evangel…     575       869      1064       982       881      1486        949\n#&gt;  7 Hindu          1         9         7         9        11        34         47\n#&gt;  8 Histori…     228       244       236       238       197       223        131\n#&gt;  9 Jehovah…      20        27        24        24        21        30         15\n#&gt; 10 Jewish        19        19        25        25        30        95         69\n#&gt; 11 Mainlin…     289       495       619       655       651      1107        939\n#&gt; 12 Mormon        29        40        48        51        56       112         85\n#&gt; 13 Muslim         6         7         9        10         9        23         16\n#&gt; 14 Orthodox      13        17        23        32        32        47         38\n#&gt; 15 Other C…       9         7        11        13        13        14         18\n#&gt; 16 Other F…      20        33        40        46        49        63         46\n#&gt; 17 Other W…       5         2         3         4         2         7          3\n#&gt; 18 Unaffil…     217       299       374       365       341       528        407\n#&gt; # ℹ 3 more variables: `$100-150k` &lt;dbl&gt;, `&gt;150k` &lt;dbl&gt;,\n#&gt; #   `Don't know/refused` &lt;dbl&gt;\n\n# Pivot all columns except religion\nrelig_income |&gt; \n  pivot_longer(\n    cols = !religion, \n    names_to = \"income\", \n    values_to = \"count\"\n  )\n#&gt; # A tibble: 180 × 3\n#&gt;    religion income             count\n#&gt;    &lt;chr&gt;    &lt;chr&gt;              &lt;dbl&gt;\n#&gt;  1 Agnostic &lt;$10k                 27\n#&gt;  2 Agnostic $10-20k               34\n#&gt;  3 Agnostic $20-30k               60\n#&gt;  4 Agnostic $30-40k               81\n#&gt;  5 Agnostic $40-50k               76\n#&gt;  6 Agnostic $50-75k              137\n#&gt;  7 Agnostic $75-100k             122\n#&gt;  8 Agnostic $100-150k            109\n#&gt;  9 Agnostic &gt;150k                 84\n#&gt; 10 Agnostic Don't know/refused    96\n#&gt; # ℹ 170 more rows\n\n\n10.1.2 Numeric data in column names\nData: billboard\nUse of arguments names_prefix to strip away prefix in column names of wk and names_transform to convert character to integer.\n\nbillboard\n#&gt; # A tibble: 317 × 79\n#&gt;    artist     track date.entered   wk1   wk2   wk3   wk4   wk5   wk6   wk7   wk8\n#&gt;    &lt;chr&gt;      &lt;chr&gt; &lt;date&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1 2 Pac      Baby… 2000-02-26      87    82    72    77    87    94    99    NA\n#&gt;  2 2Ge+her    The … 2000-09-02      91    87    92    NA    NA    NA    NA    NA\n#&gt;  3 3 Doors D… Kryp… 2000-04-08      81    70    68    67    66    57    54    53\n#&gt;  4 3 Doors D… Loser 2000-10-21      76    76    72    69    67    65    55    59\n#&gt;  5 504 Boyz   Wobb… 2000-04-15      57    34    25    17    17    31    36    49\n#&gt;  6 98^0       Give… 2000-08-19      51    39    34    26    26    19     2     2\n#&gt;  7 A*Teens    Danc… 2000-07-08      97    97    96    95   100    NA    NA    NA\n#&gt;  8 Aaliyah    I Do… 2000-01-29      84    62    51    41    38    35    35    38\n#&gt;  9 Aaliyah    Try … 2000-03-18      59    53    38    28    21    18    16    14\n#&gt; 10 Adams, Yo… Open… 2000-08-26      76    76    74    69    68    67    61    58\n#&gt; # ℹ 307 more rows\n#&gt; # ℹ 68 more variables: wk9 &lt;dbl&gt;, wk10 &lt;dbl&gt;, wk11 &lt;dbl&gt;, wk12 &lt;dbl&gt;,\n#&gt; #   wk13 &lt;dbl&gt;, wk14 &lt;dbl&gt;, wk15 &lt;dbl&gt;, wk16 &lt;dbl&gt;, wk17 &lt;dbl&gt;, wk18 &lt;dbl&gt;,\n#&gt; #   wk19 &lt;dbl&gt;, wk20 &lt;dbl&gt;, wk21 &lt;dbl&gt;, wk22 &lt;dbl&gt;, wk23 &lt;dbl&gt;, wk24 &lt;dbl&gt;,\n#&gt; #   wk25 &lt;dbl&gt;, wk26 &lt;dbl&gt;, wk27 &lt;dbl&gt;, wk28 &lt;dbl&gt;, wk29 &lt;dbl&gt;, wk30 &lt;dbl&gt;,\n#&gt; #   wk31 &lt;dbl&gt;, wk32 &lt;dbl&gt;, wk33 &lt;dbl&gt;, wk34 &lt;dbl&gt;, wk35 &lt;dbl&gt;, wk36 &lt;dbl&gt;,\n#&gt; #   wk37 &lt;dbl&gt;, wk38 &lt;dbl&gt;, wk39 &lt;dbl&gt;, wk40 &lt;dbl&gt;, wk41 &lt;dbl&gt;, wk42 &lt;dbl&gt;, …\n\nbillboard |&gt;\n  pivot_longer(\n    cols = starts_with(\"wk\"), \n    names_to = \"week\", \n    names_prefix = \"wk\",\n    names_transform = as.integer,\n    values_to = \"rank\",\n    values_drop_na = TRUE,\n  )\n#&gt; # A tibble: 5,307 × 5\n#&gt;    artist  track                   date.entered  week  rank\n#&gt;    &lt;chr&gt;   &lt;chr&gt;                   &lt;date&gt;       &lt;int&gt; &lt;dbl&gt;\n#&gt;  1 2 Pac   Baby Don't Cry (Keep... 2000-02-26       1    87\n#&gt;  2 2 Pac   Baby Don't Cry (Keep... 2000-02-26       2    82\n#&gt;  3 2 Pac   Baby Don't Cry (Keep... 2000-02-26       3    72\n#&gt;  4 2 Pac   Baby Don't Cry (Keep... 2000-02-26       4    77\n#&gt;  5 2 Pac   Baby Don't Cry (Keep... 2000-02-26       5    87\n#&gt;  6 2 Pac   Baby Don't Cry (Keep... 2000-02-26       6    94\n#&gt;  7 2 Pac   Baby Don't Cry (Keep... 2000-02-26       7    99\n#&gt;  8 2Ge+her The Hardest Part Of ... 2000-09-02       1    91\n#&gt;  9 2Ge+her The Hardest Part Of ... 2000-09-02       2    87\n#&gt; 10 2Ge+her The Hardest Part Of ... 2000-09-02       3    92\n#&gt; # ℹ 5,297 more rows\n\n\n10.1.3 Many variables in column names\nData who\ncolumns from new_sp_m014 to newrel_f65 encode four variables in their names:\n\nThe new_/new prefix indicates these are counts of new cases.\n\nsp/rel/ep describe how the case was diagnosed.\n\nm/f gives the gender.\n\n014/1524/2535/3544/4554/65 supplies the age range.\n\nTo deal with this:\n\nSpecifying multiple column names in names_to.\nSeparate column values with either names_sep or names_pattern.\nUse of readr functions to convert the gender and age to factors. This is faster than using mutate() afterwards.\n\n\nwho\n#&gt; # A tibble: 7,240 × 60\n#&gt;    country  iso2  iso3   year new_sp_m014 new_sp_m1524 new_sp_m2534 new_sp_m3544\n#&gt;    &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;       &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;        &lt;dbl&gt;\n#&gt;  1 Afghani… AF    AFG    1980          NA           NA           NA           NA\n#&gt;  2 Afghani… AF    AFG    1981          NA           NA           NA           NA\n#&gt;  3 Afghani… AF    AFG    1982          NA           NA           NA           NA\n#&gt;  4 Afghani… AF    AFG    1983          NA           NA           NA           NA\n#&gt;  5 Afghani… AF    AFG    1984          NA           NA           NA           NA\n#&gt;  6 Afghani… AF    AFG    1985          NA           NA           NA           NA\n#&gt;  7 Afghani… AF    AFG    1986          NA           NA           NA           NA\n#&gt;  8 Afghani… AF    AFG    1987          NA           NA           NA           NA\n#&gt;  9 Afghani… AF    AFG    1988          NA           NA           NA           NA\n#&gt; 10 Afghani… AF    AFG    1989          NA           NA           NA           NA\n#&gt; # ℹ 7,230 more rows\n#&gt; # ℹ 52 more variables: new_sp_m4554 &lt;dbl&gt;, new_sp_m5564 &lt;dbl&gt;,\n#&gt; #   new_sp_m65 &lt;dbl&gt;, new_sp_f014 &lt;dbl&gt;, new_sp_f1524 &lt;dbl&gt;,\n#&gt; #   new_sp_f2534 &lt;dbl&gt;, new_sp_f3544 &lt;dbl&gt;, new_sp_f4554 &lt;dbl&gt;,\n#&gt; #   new_sp_f5564 &lt;dbl&gt;, new_sp_f65 &lt;dbl&gt;, new_sn_m014 &lt;dbl&gt;,\n#&gt; #   new_sn_m1524 &lt;dbl&gt;, new_sn_m2534 &lt;dbl&gt;, new_sn_m3544 &lt;dbl&gt;,\n#&gt; #   new_sn_m4554 &lt;dbl&gt;, new_sn_m5564 &lt;dbl&gt;, new_sn_m65 &lt;dbl&gt;, …\n\nwho |&gt;\n  pivot_longer(\n    cols = new_sp_m014:newrel_f65,\n    names_to = c(\"diagnosis\", \"gender\", \"age\"), \n    names_pattern = \"new_?(.*)_(.)(.*)\",\n    names_transform = list(\n      gender = ~ readr::parse_factor(.x, levels = c(\"f\", \"m\")),\n      age = ~ readr::parse_factor(\n        .x,\n        levels = c(\"014\", \"1524\", \"2534\", \"3544\", \"4554\", \"5564\", \"65\"), \n        ordered = TRUE\n      )\n    ),\n    values_to = \"count\",\n)\n#&gt; # A tibble: 405,440 × 8\n#&gt;    country     iso2  iso3   year diagnosis gender age   count\n#&gt;    &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt;     &lt;fct&gt;  &lt;ord&gt; &lt;dbl&gt;\n#&gt;  1 Afghanistan AF    AFG    1980 sp        m      014      NA\n#&gt;  2 Afghanistan AF    AFG    1980 sp        m      1524     NA\n#&gt;  3 Afghanistan AF    AFG    1980 sp        m      2534     NA\n#&gt;  4 Afghanistan AF    AFG    1980 sp        m      3544     NA\n#&gt;  5 Afghanistan AF    AFG    1980 sp        m      4554     NA\n#&gt;  6 Afghanistan AF    AFG    1980 sp        m      5564     NA\n#&gt;  7 Afghanistan AF    AFG    1980 sp        m      65       NA\n#&gt;  8 Afghanistan AF    AFG    1980 sp        f      014      NA\n#&gt;  9 Afghanistan AF    AFG    1980 sp        f      1524     NA\n#&gt; 10 Afghanistan AF    AFG    1980 sp        f      2534     NA\n#&gt; # ℹ 405,430 more rows\n\n\n10.1.4 Multiple observations per row\nData: household\nUse of \".value\" in names_to to indicate that part of the column name specifies the “value” being measured and so should be used as a variable name.\n\nhousehold\n#&gt; # A tibble: 5 × 5\n#&gt;   family dob_child1 dob_child2 name_child1 name_child2\n#&gt;    &lt;int&gt; &lt;date&gt;     &lt;date&gt;     &lt;chr&gt;       &lt;chr&gt;      \n#&gt; 1      1 1998-11-26 2000-01-29 Susan       Jose       \n#&gt; 2      2 1996-06-22 NA         Mark        &lt;NA&gt;       \n#&gt; 3      3 2002-07-11 2004-04-05 Sam         Seth       \n#&gt; 4      4 2004-10-10 2009-08-27 Craig       Khai       \n#&gt; 5      5 2000-12-05 2005-02-28 Parker      Gracie\n\nhousehold |&gt;\n  pivot_longer(\n    cols = !family, \n    names_to = c(\".value\", \"child\"), \n    names_sep = \"_\", \n    values_drop_na = TRUE\n  )\n#&gt; # A tibble: 9 × 4\n#&gt;   family child  dob        name  \n#&gt;    &lt;int&gt; &lt;chr&gt;  &lt;date&gt;     &lt;chr&gt; \n#&gt; 1      1 child1 1998-11-26 Susan \n#&gt; 2      1 child2 2000-01-29 Jose  \n#&gt; 3      2 child1 1996-06-22 Mark  \n#&gt; 4      3 child1 2002-07-11 Sam   \n#&gt; 5      3 child2 2004-04-05 Seth  \n#&gt; 6      4 child1 2004-10-10 Craig \n#&gt; 7      4 child2 2009-08-27 Khai  \n#&gt; 8      5 child1 2000-12-05 Parker\n#&gt; 9      5 child2 2005-02-28 Gracie\n\nData: anscombe\nUse of cols_vary = \"slowest\" to group values from columns x1 and y1 together,.\n\nanscombe\n#&gt;    x1 x2 x3 x4    y1   y2    y3    y4\n#&gt; 1  10 10 10  8  8.04 9.14  7.46  6.58\n#&gt; 2   8  8  8  8  6.95 8.14  6.77  5.76\n#&gt; 3  13 13 13  8  7.58 8.74 12.74  7.71\n#&gt; 4   9  9  9  8  8.81 8.77  7.11  8.84\n#&gt; 5  11 11 11  8  8.33 9.26  7.81  8.47\n#&gt; 6  14 14 14  8  9.96 8.10  8.84  7.04\n#&gt; 7   6  6  6  8  7.24 6.13  6.08  5.25\n#&gt; 8   4  4  4 19  4.26 3.10  5.39 12.50\n#&gt; 9  12 12 12  8 10.84 9.13  8.15  5.56\n#&gt; 10  7  7  7  8  4.82 7.26  6.42  7.91\n#&gt; 11  5  5  5  8  5.68 4.74  5.73  6.89\n\nanscombe |&gt;\n  pivot_longer(\n    cols = everything(), \n    cols_vary = \"slowest\",\n    names_to = c(\".value\", \"set\"), \n    names_pattern = \"(.)(.)\"\n  )\n#&gt; # A tibble: 44 × 3\n#&gt;    set       x     y\n#&gt;    &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1 1        10  8.04\n#&gt;  2 1         8  6.95\n#&gt;  3 1        13  7.58\n#&gt;  4 1         9  8.81\n#&gt;  5 1        11  8.33\n#&gt;  6 1        14  9.96\n#&gt;  7 1         6  7.24\n#&gt;  8 1         4  4.26\n#&gt;  9 1        12 10.8 \n#&gt; 10 1         7  4.82\n#&gt; # ℹ 34 more rows",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>tidyr: Pivoting</span>"
    ]
  },
  {
    "objectID": "01-tidyr-pivoting.html#sec-wider",
    "href": "01-tidyr-pivoting.html#sec-wider",
    "title": "10  tidyr: Pivoting",
    "section": "\n10.2 Wider",
    "text": "10.2 Wider\npivot_wider() makes a dataset wider by increasing the number of columns and decreasing the number of rows.\npivot_wider() arguments:\n\ndata\n\nnames_from: Column used to create column names.\n\nvalues_from: Column used to create cell values.\n\nvalues_fill: Default value instead of NA.\n\nvalues_fn: A function applied to the value in each cell in the output.\n\nYou will typically use this when the combination of id_cols and names_from columns does not uniquely identify an observation.\n\n\n\nnames_prefix: String added to the start of every variable name.\n\nnames_sep: If names_from or values_from contains multiple variables, this will be used to join their values together into a single string to use as a column name.\n\nnames_glue: Instead of names_sep and names_prefix, you can supply a glue specification that uses the names_from columns (and special .value) to create custom column names.\n\nnames_expand: Whether to make implicit factor levels explicit.\n\nid_cols: A set of columns that uniquely identify each observation.\n\nid_expand: Whether to make implicit factor levels explicit in id_cols.\n\nunused_fn: A function applied to summarize the values from the unused columns (i.e. columns not identified by id_cols, names_from, or values_from).\n\n\n10.2.1 Capture-recapture data\nData: fish_encounters\n\nfish_encounters\n#&gt; # A tibble: 114 × 3\n#&gt;    fish  station  seen\n#&gt;    &lt;fct&gt; &lt;fct&gt;   &lt;int&gt;\n#&gt;  1 4842  Release     1\n#&gt;  2 4842  I80_1       1\n#&gt;  3 4842  Lisbon      1\n#&gt;  4 4842  Rstr        1\n#&gt;  5 4842  Base_TD     1\n#&gt;  6 4842  BCE         1\n#&gt;  7 4842  BCW         1\n#&gt;  8 4842  BCE2        1\n#&gt;  9 4842  BCW2        1\n#&gt; 10 4842  MAE         1\n#&gt; # ℹ 104 more rows\n\nfish_encounters |&gt;\n  pivot_wider(\n    names_from = station, \n    values_from = seen,\n    values_fill = 0\n  )\n#&gt; # A tibble: 19 × 12\n#&gt;    fish  Release I80_1 Lisbon  Rstr Base_TD   BCE   BCW  BCE2  BCW2   MAE   MAW\n#&gt;    &lt;fct&gt;   &lt;int&gt; &lt;int&gt;  &lt;int&gt; &lt;int&gt;   &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt;\n#&gt;  1 4842        1     1      1     1       1     1     1     1     1     1     1\n#&gt;  2 4843        1     1      1     1       1     1     1     1     1     1     1\n#&gt;  3 4844        1     1      1     1       1     1     1     1     1     1     1\n#&gt;  4 4845        1     1      1     1       1     0     0     0     0     0     0\n#&gt;  5 4847        1     1      1     0       0     0     0     0     0     0     0\n#&gt;  6 4848        1     1      1     1       0     0     0     0     0     0     0\n#&gt;  7 4849        1     1      0     0       0     0     0     0     0     0     0\n#&gt;  8 4850        1     1      0     1       1     1     1     0     0     0     0\n#&gt;  9 4851        1     1      0     0       0     0     0     0     0     0     0\n#&gt; 10 4854        1     1      0     0       0     0     0     0     0     0     0\n#&gt; 11 4855        1     1      1     1       1     0     0     0     0     0     0\n#&gt; 12 4857        1     1      1     1       1     1     1     1     1     0     0\n#&gt; 13 4858        1     1      1     1       1     1     1     1     1     1     1\n#&gt; 14 4859        1     1      1     1       1     0     0     0     0     0     0\n#&gt; 15 4861        1     1      1     1       1     1     1     1     1     1     1\n#&gt; 16 4862        1     1      1     1       1     1     1     1     1     0     0\n#&gt; 17 4863        1     1      0     0       0     0     0     0     0     0     0\n#&gt; 18 4864        1     1      0     0       0     0     0     0     0     0     0\n#&gt; 19 4865        1     1      1     0       0     0     0     0     0     0     0\n\n\n10.2.2 Aggregation\nData: warpbreaks\nUse of values_fn to create aggregate when pivot_wider() matches multiple cells.\n\nwarpbreaks &lt;- warpbreaks |&gt;\n  as_tibble() |&gt;\n  select(wool, tension, breaks)\nwarpbreaks\n#&gt; # A tibble: 54 × 3\n#&gt;    wool  tension breaks\n#&gt;    &lt;fct&gt; &lt;fct&gt;    &lt;dbl&gt;\n#&gt;  1 A     L           26\n#&gt;  2 A     L           30\n#&gt;  3 A     L           54\n#&gt;  4 A     L           25\n#&gt;  5 A     L           70\n#&gt;  6 A     L           52\n#&gt;  7 A     L           51\n#&gt;  8 A     L           26\n#&gt;  9 A     L           67\n#&gt; 10 A     M           18\n#&gt; # ℹ 44 more rows\n\n# Multiple matches creates list columns\nwarpbreaks |&gt;\n  pivot_wider(\n    names_from = wool, \n    values_from = breaks\n  )\n#&gt; Warning: Values from `breaks` are not uniquely identified; output will contain\n#&gt; list-cols.\n#&gt; • Use `values_fn = list` to suppress this warning.\n#&gt; • Use `values_fn = {summary_fun}` to summarise duplicates.\n#&gt; • Use the following dplyr code to identify duplicates.\n#&gt;   {data} %&gt;%\n#&gt;   dplyr::group_by(tension, wool) %&gt;%\n#&gt;   dplyr::summarise(n = dplyr::n(), .groups = \"drop\") %&gt;%\n#&gt;   dplyr::filter(n &gt; 1L)\n#&gt; # A tibble: 3 × 3\n#&gt;   tension A         B        \n#&gt;   &lt;fct&gt;   &lt;list&gt;    &lt;list&gt;   \n#&gt; 1 L       &lt;dbl [9]&gt; &lt;dbl [9]&gt;\n#&gt; 2 M       &lt;dbl [9]&gt; &lt;dbl [9]&gt;\n#&gt; 3 H       &lt;dbl [9]&gt; &lt;dbl [9]&gt;\n\n# values_fn to summarise values\nwarpbreaks |&gt;\n  pivot_wider(\n    names_from = wool, \n    values_from = breaks,\n    values_fn = mean\n  )\n#&gt; # A tibble: 3 × 3\n#&gt;   tension     A     B\n#&gt;   &lt;fct&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 L        44.6  28.2\n#&gt; 2 M        24    28.8\n#&gt; 3 H        24.6  18.8\n\n\n10.2.3 Generate column name from multiple variables\nData: production\nTake tidy data and widen to have one column for each combination of two columns. Do this by specifying multiple variables for names_from.\nControl how the column names are constructed with names_sep and names_prefix, or the workhorse names_glue\n\n# Create tidy data\nproduction &lt;- \n  expand_grid(\n    product = c(\"A\", \"B\"), \n    country = c(\"AI\", \"EI\"), \n    year = 2000:2014\n  ) %&gt;%\n  filter((product == \"A\" & country == \"AI\") | product == \"B\") %&gt;% \n  mutate(production = rnorm(nrow(.)))\nproduction\n#&gt; # A tibble: 45 × 4\n#&gt;    product country  year production\n#&gt;    &lt;chr&gt;   &lt;chr&gt;   &lt;int&gt;      &lt;dbl&gt;\n#&gt;  1 A       AI       2000      0.961\n#&gt;  2 A       AI       2001      0.608\n#&gt;  3 A       AI       2002      0.991\n#&gt;  4 A       AI       2003      0.309\n#&gt;  5 A       AI       2004     -0.197\n#&gt;  6 A       AI       2005      0.526\n#&gt;  7 A       AI       2006     -1.33 \n#&gt;  8 A       AI       2007     -0.838\n#&gt;  9 A       AI       2008     -1.66 \n#&gt; 10 A       AI       2009      1.11 \n#&gt; # ℹ 35 more rows\n\n# With names_sep and names_prefix\nproduction |&gt; \n  pivot_wider(\n    names_from = c(product, country), \n    values_from = production,\n    names_sep = \".\",\n    names_prefix = \"prod.\"\n  )\n#&gt; # A tibble: 15 × 4\n#&gt;     year prod.A.AI prod.B.AI prod.B.EI\n#&gt;    &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n#&gt;  1  2000     0.961   -0.397     0.778 \n#&gt;  2  2001     0.608    1.77     -0.116 \n#&gt;  3  2002     0.991    0.222     1.34  \n#&gt;  4  2003     0.309   -1.16      0.292 \n#&gt;  5  2004    -0.197    0.135    -0.699 \n#&gt;  6  2005     0.526   -0.360    -0.126 \n#&gt;  7  2006    -1.33     0.217     1.48  \n#&gt;  8  2007    -0.838   -0.0331    0.0260\n#&gt;  9  2008    -1.66    -1.03      0.806 \n#&gt; 10  2009     1.11    -0.195     1.77  \n#&gt; 11  2010    -0.659   -1.38     -0.361 \n#&gt; 12  2011     1.08    -0.485    -0.591 \n#&gt; 13  2012     1.08    -0.680     0.648 \n#&gt; 14  2013    -0.674    0.535     0.202 \n#&gt; 15  2014    -0.214   -1.20     -1.09\n\n# With names_glue\nproduction |&gt; \n  pivot_wider(\n    names_from = c(product, country), \n    values_from = production,\n    names_glue = \"prod_{product}_{country}\"\n  )\n#&gt; # A tibble: 15 × 4\n#&gt;     year prod_A_AI prod_B_AI prod_B_EI\n#&gt;    &lt;int&gt;     &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;\n#&gt;  1  2000     0.961   -0.397     0.778 \n#&gt;  2  2001     0.608    1.77     -0.116 \n#&gt;  3  2002     0.991    0.222     1.34  \n#&gt;  4  2003     0.309   -1.16      0.292 \n#&gt;  5  2004    -0.197    0.135    -0.699 \n#&gt;  6  2005     0.526   -0.360    -0.126 \n#&gt;  7  2006    -1.33     0.217     1.48  \n#&gt;  8  2007    -0.838   -0.0331    0.0260\n#&gt;  9  2008    -1.66    -1.03      0.806 \n#&gt; 10  2009     1.11    -0.195     1.77  \n#&gt; 11  2010    -0.659   -1.38     -0.361 \n#&gt; 12  2011     1.08    -0.485    -0.591 \n#&gt; 13  2012     1.08    -0.680     0.648 \n#&gt; 14  2013    -0.674    0.535     0.202 \n#&gt; 15  2014    -0.214   -1.20     -1.09\n\n\n10.2.4 Tidy census\nData: us_rent_income\n\nus_rent_income\n#&gt; # A tibble: 104 × 5\n#&gt;    GEOID NAME       variable estimate   moe\n#&gt;    &lt;chr&gt; &lt;chr&gt;      &lt;chr&gt;       &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1 01    Alabama    income      24476   136\n#&gt;  2 01    Alabama    rent          747     3\n#&gt;  3 02    Alaska     income      32940   508\n#&gt;  4 02    Alaska     rent         1200    13\n#&gt;  5 04    Arizona    income      27517   148\n#&gt;  6 04    Arizona    rent          972     4\n#&gt;  7 05    Arkansas   income      23789   165\n#&gt;  8 05    Arkansas   rent          709     5\n#&gt;  9 06    California income      29454   109\n#&gt; 10 06    California rent         1358     3\n#&gt; # ℹ 94 more rows\n\nus_rent_income |&gt; \n  pivot_wider(\n    names_from = variable, \n    values_from = c(estimate, moe)\n  )\n#&gt; # A tibble: 52 × 6\n#&gt;    GEOID NAME                 estimate_income estimate_rent moe_income moe_rent\n#&gt;    &lt;chr&gt; &lt;chr&gt;                          &lt;dbl&gt;         &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 01    Alabama                        24476           747        136        3\n#&gt;  2 02    Alaska                         32940          1200        508       13\n#&gt;  3 04    Arizona                        27517           972        148        4\n#&gt;  4 05    Arkansas                       23789           709        165        5\n#&gt;  5 06    California                     29454          1358        109        3\n#&gt;  6 08    Colorado                       32401          1125        109        5\n#&gt;  7 09    Connecticut                    35326          1123        195        5\n#&gt;  8 10    Delaware                       31560          1076        247       10\n#&gt;  9 11    District of Columbia           43198          1424        681       17\n#&gt; 10 12    Florida                        25952          1077         70        3\n#&gt; # ℹ 42 more rows\n\nSee Section 10.4.2 for a different way to do this with a spec.\n\n10.2.5 Implicit missing values\nData: Factor of weekdays\nWhen you want to turn a column of factor data into column names. pivot_wider() defaults to generating columns from the data that exists, but you might want to include columns from all possible factor levels. Use names_expand to make implicit factor levels explicit.\n\n# Data\nweekdays &lt;- c(\"Mon\", \"Tue\", \"Wed\", \"Thu\", \"Fri\", \"Sat\", \"Sun\")\ndaily &lt;- tibble(\n  day = factor(c(\"Tue\", \"Thu\", \"Fri\", \"Mon\"), levels = weekdays),\n  value = c(2, 3, 1, 5)\n)\ndaily\n#&gt; # A tibble: 4 × 2\n#&gt;   day   value\n#&gt;   &lt;fct&gt; &lt;dbl&gt;\n#&gt; 1 Tue       2\n#&gt; 2 Thu       3\n#&gt; 3 Fri       1\n#&gt; 4 Mon       5\n\ndaily |&gt; \n  pivot_wider(\n    names_from = day, \n    values_from = value, \n    names_expand = TRUE\n  )\n#&gt; # A tibble: 1 × 7\n#&gt;     Mon   Tue   Wed   Thu   Fri   Sat   Sun\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     5     2    NA     3     1    NA    NA\n\nData: Factor and year data\nIf multiple names_from columns are provided, names_expand will generate a Cartesian product of all possible combinations of the names_from values.\n\n# Data\npercentages &lt;- tibble(\n  year = c(2018, 2019, 2020, 2020),\n  type = factor(c(\"A\", \"B\", \"A\", \"B\"), levels = c(\"A\", \"B\")),\n  percentage = c(100, 100, 40, 60)\n)\npercentages\n#&gt; # A tibble: 4 × 3\n#&gt;    year type  percentage\n#&gt;   &lt;dbl&gt; &lt;fct&gt;      &lt;dbl&gt;\n#&gt; 1  2018 A            100\n#&gt; 2  2019 B            100\n#&gt; 3  2020 A             40\n#&gt; 4  2020 B             60\n\npercentages |&gt; \n  pivot_wider(\n    names_from = c(type, year),\n    values_from = percentage,\n    names_expand = TRUE,\n    values_fill = 0\n  )\n#&gt; # A tibble: 1 × 6\n#&gt;   A_2018 A_2019 A_2020 B_2018 B_2019 B_2020\n#&gt;    &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1    100      0     40      0    100     60\n\nData: Missing factor levels in id_cols\nMissing rows in factor instead of missing columns as above. Need to use id_expand = TRUE.\n\ndaily &lt;- mutate(daily, type = factor(c(\"A\", \"B\", \"B\", \"A\")))\ndaily\n#&gt; # A tibble: 4 × 3\n#&gt;   day   value type \n#&gt;   &lt;fct&gt; &lt;dbl&gt; &lt;fct&gt;\n#&gt; 1 Tue       2 A    \n#&gt; 2 Thu       3 B    \n#&gt; 3 Fri       1 B    \n#&gt; 4 Mon       5 A\n\ndaily |&gt; \n  pivot_wider(\n    names_from = type, \n    values_from = value,\n    values_fill = 0,\n    id_expand = TRUE\n  )\n#&gt; # A tibble: 7 × 3\n#&gt;   day       A     B\n#&gt;   &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1 Mon       5     0\n#&gt; 2 Tue       2     0\n#&gt; 3 Wed       0     0\n#&gt; 4 Thu       0     3\n#&gt; 5 Fri       0     1\n#&gt; 6 Sat       0     0\n#&gt; 7 Sun       0     0\n\n\n10.2.6 Unused columns\nIssue of retaining some data in a column that is not related to the pivoting process. Use of unused_fn to apply a function to unused columns instead of dropping them. You can retain the information by creating a list column.\n\n# Data\nupdates &lt;- tibble(\n  county = c(\"Wake\", \"Wake\", \"Wake\", \"Guilford\", \"Guilford\"),\n  date = c(as.Date(\"2023-01-01\") + 0:2, as.Date(\"2023-01-03\") + 0:1),\n  system = c(\"A\", \"B\", \"C\", \"A\", \"C\"),\n  value = c(3.2, 4, 5.5, 2, 1.2)\n)\nupdates\n#&gt; # A tibble: 5 × 4\n#&gt;   county   date       system value\n#&gt;   &lt;chr&gt;    &lt;date&gt;     &lt;chr&gt;  &lt;dbl&gt;\n#&gt; 1 Wake     2023-01-01 A        3.2\n#&gt; 2 Wake     2023-01-02 B        4  \n#&gt; 3 Wake     2023-01-03 C        5.5\n#&gt; 4 Guilford 2023-01-03 A        2  \n#&gt; 5 Guilford 2023-01-04 C        1.2\n\n# max\nupdates |&gt; \n  pivot_wider(\n    id_cols = county, \n    names_from = system, \n    values_from = value,\n    unused_fn = list(date = max)\n  )\n#&gt; # A tibble: 2 × 5\n#&gt;   county       A     B     C date      \n#&gt;   &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt;    \n#&gt; 1 Wake       3.2     4   5.5 2023-01-03\n#&gt; 2 Guilford   2      NA   1.2 2023-01-04\n\n# list column\nupdates |&gt; \n  pivot_wider(\n    id_cols = county, \n    names_from = system, \n    values_from = value,\n    unused_fn = list(date = list)\n  )\n#&gt; # A tibble: 2 × 5\n#&gt;   county       A     B     C date      \n#&gt;   &lt;chr&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;list&gt;    \n#&gt; 1 Wake       3.2     4   5.5 &lt;date [3]&gt;\n#&gt; 2 Guilford   2      NA   1.2 &lt;date [2]&gt;\n\n\n10.2.7 Contact list\nContact list with variable number of fields per contact. Can use cumsum() to create unique id based on first value for each person (name).\n\n# Data\ncontacts &lt;- tribble(\n  ~field, ~value,\n  \"name\", \"Jiena McLellan\",\n  \"company\", \"Toyota\", \n  \"name\", \"John Smith\", \n  \"company\", \"google\", \n  \"email\", \"john@google.com\",\n  \"name\", \"Huxley Ratcliffe\"\n)\n# Create unique id\ncontacts &lt;- contacts |&gt; \n  mutate(person_id = cumsum(field == \"name\"))\ncontacts\n#&gt; # A tibble: 6 × 3\n#&gt;   field   value            person_id\n#&gt;   &lt;chr&gt;   &lt;chr&gt;                &lt;int&gt;\n#&gt; 1 name    Jiena McLellan           1\n#&gt; 2 company Toyota                   1\n#&gt; 3 name    John Smith               2\n#&gt; 4 company google                   2\n#&gt; 5 email   john@google.com          2\n#&gt; 6 name    Huxley Ratcliffe         3\n\ncontacts |&gt; \n  pivot_wider(\n    names_from = field, \n    values_from = value\n  )\n#&gt; # A tibble: 3 × 4\n#&gt;   person_id name             company email          \n#&gt;       &lt;int&gt; &lt;chr&gt;            &lt;chr&gt;   &lt;chr&gt;          \n#&gt; 1         1 Jiena McLellan   Toyota  &lt;NA&gt;           \n#&gt; 2         2 John Smith       google  john@google.com\n#&gt; 3         3 Huxley Ratcliffe &lt;NA&gt;    &lt;NA&gt;",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>tidyr: Pivoting</span>"
    ]
  },
  {
    "objectID": "01-tidyr-pivoting.html#sec-longer-wider",
    "href": "01-tidyr-pivoting.html#sec-longer-wider",
    "title": "10  tidyr: Pivoting",
    "section": "\n10.3 Longer, then wider",
    "text": "10.3 Longer, then wider\n\n10.3.1 World bank\nData: world_bank_pop\nProblems:\n\nYear variables are column names: pivot_longer().\n\nindicator column contains multiple variables.\nThis creates variable column with two variables that should be widened: pivot_wider()\n\nMake new column names lowercase: dplyr::rename_with()\n\n\n\nworld_bank_pop\n#&gt; # A tibble: 1,064 × 20\n#&gt;    country indicator      `2000`  `2001`  `2002`  `2003`  `2004`  `2005`  `2006`\n#&gt;    &lt;chr&gt;   &lt;chr&gt;           &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;\n#&gt;  1 ABW     SP.URB.TOTL    4.16e4 4.20e+4 4.22e+4 4.23e+4 4.23e+4 4.24e+4 4.26e+4\n#&gt;  2 ABW     SP.URB.GROW    1.66e0 9.56e-1 4.01e-1 1.97e-1 9.46e-2 1.94e-1 3.67e-1\n#&gt;  3 ABW     SP.POP.TOTL    8.91e4 9.07e+4 9.18e+4 9.27e+4 9.35e+4 9.45e+4 9.56e+4\n#&gt;  4 ABW     SP.POP.GROW    2.54e0 1.77e+0 1.19e+0 9.97e-1 9.01e-1 1.00e+0 1.18e+0\n#&gt;  5 AFE     SP.URB.TOTL    1.16e8 1.20e+8 1.24e+8 1.29e+8 1.34e+8 1.39e+8 1.44e+8\n#&gt;  6 AFE     SP.URB.GROW    3.60e0 3.66e+0 3.72e+0 3.71e+0 3.74e+0 3.81e+0 3.81e+0\n#&gt;  7 AFE     SP.POP.TOTL    4.02e8 4.12e+8 4.23e+8 4.34e+8 4.45e+8 4.57e+8 4.70e+8\n#&gt;  8 AFE     SP.POP.GROW    2.58e0 2.59e+0 2.61e+0 2.62e+0 2.64e+0 2.67e+0 2.70e+0\n#&gt;  9 AFG     SP.URB.TOTL    4.31e6 4.36e+6 4.67e+6 5.06e+6 5.30e+6 5.54e+6 5.83e+6\n#&gt; 10 AFG     SP.URB.GROW    1.86e0 1.15e+0 6.86e+0 7.95e+0 4.59e+0 4.47e+0 5.03e+0\n#&gt; # ℹ 1,054 more rows\n#&gt; # ℹ 11 more variables: `2007` &lt;dbl&gt;, `2008` &lt;dbl&gt;, `2009` &lt;dbl&gt;, `2010` &lt;dbl&gt;,\n#&gt; #   `2011` &lt;dbl&gt;, `2012` &lt;dbl&gt;, `2013` &lt;dbl&gt;, `2014` &lt;dbl&gt;, `2015` &lt;dbl&gt;,\n#&gt; #   `2016` &lt;dbl&gt;, `2017` &lt;dbl&gt;\n\n# 1. Pivot longer\nworld_bank_pop |&gt; \n  pivot_longer(\n    cols = `2000`:`2017`, \n    names_to = \"year\", \n    values_to = \"value\"\n  ) |&gt; \n# 2. separate indicator column\n  separate(indicator, c(NA, \"area\", \"variable\")) |&gt; \n# 3. pivot variable column wider\n  pivot_wider(\n    names_from = variable, \n    values_from = value,\n  ) |&gt; \n# 4. Make new column names lowercase\n  rename_with(tolower)\n#&gt; # A tibble: 9,576 × 5\n#&gt;    country area  year   totl   grow\n#&gt;    &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt;\n#&gt;  1 ABW     URB   2000  41625 1.66  \n#&gt;  2 ABW     URB   2001  42025 0.956 \n#&gt;  3 ABW     URB   2002  42194 0.401 \n#&gt;  4 ABW     URB   2003  42277 0.197 \n#&gt;  5 ABW     URB   2004  42317 0.0946\n#&gt;  6 ABW     URB   2005  42399 0.194 \n#&gt;  7 ABW     URB   2006  42555 0.367 \n#&gt;  8 ABW     URB   2007  42729 0.408 \n#&gt;  9 ABW     URB   2008  42906 0.413 \n#&gt; 10 ABW     URB   2009  43079 0.402 \n#&gt; # ℹ 9,566 more rows\n\n\n10.3.2 Multi-choice\nGoing from data that has choice number as columns to whether an individual selected that choice or not.\n\nMake data longer, while eliminating NAs to only have choices that were made.\nAdd logical column with TRUEs.\nPivot data wider and fill in missing observations with FALSE.\n\n\n# Data\nmulti &lt;- tribble(\n  ~id, ~choice1, ~choice2, ~choice3,\n  1, \"A\", \"B\", \"C\",\n  2, \"C\", \"B\",  NA,\n  3, \"D\",  NA,  NA,\n  4, \"B\", \"D\",  NA\n)\nmulti\n#&gt; # A tibble: 4 × 4\n#&gt;      id choice1 choice2 choice3\n#&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;  \n#&gt; 1     1 A       B       C      \n#&gt; 2     2 C       B       &lt;NA&gt;   \n#&gt; 3     3 D       &lt;NA&gt;    &lt;NA&gt;   \n#&gt; 4     4 B       D       &lt;NA&gt;\n\n# 1. Pivot longer\nmulti |&gt; \n  pivot_longer(\n    cols = !id, \n    values_drop_na = TRUE\n  ) |&gt;\n# 2. Add col whether choice was made\n  mutate(checked = TRUE) |&gt; \n# 3. Pivot wider\n  pivot_wider(\n    id_cols = id,\n    names_from = value, \n    values_from = checked, \n    values_fill = FALSE\n  )\n#&gt; # A tibble: 4 × 5\n#&gt;      id A     B     C     D    \n#&gt;   &lt;dbl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt; &lt;lgl&gt;\n#&gt; 1     1 TRUE  TRUE  TRUE  FALSE\n#&gt; 2     2 FALSE TRUE  TRUE  FALSE\n#&gt; 3     3 FALSE FALSE FALSE TRUE \n#&gt; 4     4 FALSE TRUE  FALSE TRUE",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>tidyr: Pivoting</span>"
    ]
  },
  {
    "objectID": "01-tidyr-pivoting.html#sec-specs",
    "href": "01-tidyr-pivoting.html#sec-specs",
    "title": "10  tidyr: Pivoting",
    "section": "\n10.4 Manual specs",
    "text": "10.4 Manual specs\nTo gain more control over pivoting, you can instead create a “spec” data frame that describes exactly how data stored in the column names becomes variables (and vice versa). This section focuses on the use of build_longer_spec(), pivot_longer_spec(), build_wider_spec(), and pivot_wider_spec().\nA spec data frame created by build_longer_spec() or build_wider_spec() with special columns called .name for the name of the columns and .value for the name of the column that the values in the cells will go into. There is also one column in spec for each column present in the long format of the data that is not present in the wide format of the data. This corresponds to the names_to argument in pivot_longer() and the names_from argument in pivot_wider().\n\nrelig_income |&gt; \n  build_longer_spec(\n    cols = !religion, \n    names_to = \"income\",\n    values_to = \"count\"\n  )\n#&gt; # A tibble: 10 × 3\n#&gt;    .name              .value income            \n#&gt;    &lt;chr&gt;              &lt;chr&gt;  &lt;chr&gt;             \n#&gt;  1 &lt;$10k              count  &lt;$10k             \n#&gt;  2 $10-20k            count  $10-20k           \n#&gt;  3 $20-30k            count  $20-30k           \n#&gt;  4 $30-40k            count  $30-40k           \n#&gt;  5 $40-50k            count  $40-50k           \n#&gt;  6 $50-75k            count  $50-75k           \n#&gt;  7 $75-100k           count  $75-100k          \n#&gt;  8 $100-150k          count  $100-150k         \n#&gt;  9 &gt;150k              count  &gt;150k             \n#&gt; 10 Don't know/refused count  Don't know/refused\n\n\n10.4.1 Longer\nData: relig_income\nWith a spec the process for pivoting is two steps. Creating a spec and then pivoting the spec. This does the same as Section 10.1.1.\n\n# Build spec\nspec &lt;- relig_income |&gt; \n  build_longer_spec(\n    cols = !religion, \n    names_to = \"income\",\n    values_to = \"count\"\n  )\nspec\n#&gt; # A tibble: 10 × 3\n#&gt;    .name              .value income            \n#&gt;    &lt;chr&gt;              &lt;chr&gt;  &lt;chr&gt;             \n#&gt;  1 &lt;$10k              count  &lt;$10k             \n#&gt;  2 $10-20k            count  $10-20k           \n#&gt;  3 $20-30k            count  $20-30k           \n#&gt;  4 $30-40k            count  $30-40k           \n#&gt;  5 $40-50k            count  $40-50k           \n#&gt;  6 $50-75k            count  $50-75k           \n#&gt;  7 $75-100k           count  $75-100k          \n#&gt;  8 $100-150k          count  $100-150k         \n#&gt;  9 &gt;150k              count  &gt;150k             \n#&gt; 10 Don't know/refused count  Don't know/refused\n\n# Pivot with spec\npivot_longer_spec(relig_income, spec)\n#&gt; # A tibble: 180 × 3\n#&gt;    religion income             count\n#&gt;    &lt;chr&gt;    &lt;chr&gt;              &lt;dbl&gt;\n#&gt;  1 Agnostic &lt;$10k                 27\n#&gt;  2 Agnostic $10-20k               34\n#&gt;  3 Agnostic $20-30k               60\n#&gt;  4 Agnostic $30-40k               81\n#&gt;  5 Agnostic $40-50k               76\n#&gt;  6 Agnostic $50-75k              137\n#&gt;  7 Agnostic $75-100k             122\n#&gt;  8 Agnostic $100-150k            109\n#&gt;  9 Agnostic &gt;150k                 84\n#&gt; 10 Agnostic Don't know/refused    96\n#&gt; # ℹ 170 more rows\n\n\n10.4.2 Wider\nData: us_rent_income\nAbility to improve the widening of the data from Section 10.2.4 through the use of a spec. Change the names of the columns from the default of estimate_income, estimate_rent, moe_income, and moe_rent to income, rent, income_moe, and rent_moe.\n\n# Default spec\nspec1 &lt;- us_rent_income |&gt; \n  build_wider_spec(\n    names_from = variable, \n    values_from = c(estimate, moe)\n  )\nspec1\n#&gt; # A tibble: 4 × 3\n#&gt;   .name           .value   variable\n#&gt;   &lt;chr&gt;           &lt;chr&gt;    &lt;chr&gt;   \n#&gt; 1 estimate_income estimate income  \n#&gt; 2 estimate_rent   estimate rent    \n#&gt; 3 moe_income      moe      income  \n#&gt; 4 moe_rent        moe      rent\n\n# Modify spec with mutate on .names\nspec2 &lt;- spec1 |&gt;\n  mutate(\n    .name = paste0(variable, ifelse(.value == \"moe\", \"_moe\", \"\"))\n  )\nspec2\n#&gt; # A tibble: 4 × 3\n#&gt;   .name      .value   variable\n#&gt;   &lt;chr&gt;      &lt;chr&gt;    &lt;chr&gt;   \n#&gt; 1 income     estimate income  \n#&gt; 2 rent       estimate rent    \n#&gt; 3 income_moe moe      income  \n#&gt; 4 rent_moe   moe      rent\n\n# Pivot with spec\nus_rent_income |&gt; \n  pivot_wider_spec(spec2)\n#&gt; # A tibble: 52 × 6\n#&gt;    GEOID NAME                 income  rent income_moe rent_moe\n#&gt;    &lt;chr&gt; &lt;chr&gt;                 &lt;dbl&gt; &lt;dbl&gt;      &lt;dbl&gt;    &lt;dbl&gt;\n#&gt;  1 01    Alabama               24476   747        136        3\n#&gt;  2 02    Alaska                32940  1200        508       13\n#&gt;  3 04    Arizona               27517   972        148        4\n#&gt;  4 05    Arkansas              23789   709        165        5\n#&gt;  5 06    California            29454  1358        109        3\n#&gt;  6 08    Colorado              32401  1125        109        5\n#&gt;  7 09    Connecticut           35326  1123        195        5\n#&gt;  8 10    Delaware              31560  1076        247       10\n#&gt;  9 11    District of Columbia  43198  1424        681       17\n#&gt; 10 12    Florida               25952  1077         70        3\n#&gt; # ℹ 42 more rows\n\n\n10.4.3 By hand\nData: construction\nThe column names in the data are two different kinds of variables: units and region. This can be described by creating a spec by hand.\n\nspec &lt;- tribble(\n  ~.name,            ~.value, ~units,  ~region,     \n  \"1 unit\",          \"n\",     \"1\",     NA,          \n  \"2 to 4 units\",    \"n\",     \"2-4\",   NA,          \n  \"5 units or more\", \"n\",     \"5+\",    NA,          \n  \"Northeast\",       \"n\",     NA,      \"Northeast\", \n  \"Midwest\",         \"n\",     NA,      \"Midwest\",   \n  \"South\",           \"n\",     NA,      \"South\",     \n  \"West\",            \"n\",     NA,      \"West\",      \n)\n\nconstruction |&gt; pivot_longer_spec(spec)\n#&gt; # A tibble: 63 × 5\n#&gt;     Year Month    units region        n\n#&gt;    &lt;dbl&gt; &lt;chr&gt;    &lt;chr&gt; &lt;chr&gt;     &lt;dbl&gt;\n#&gt;  1  2018 January  1     &lt;NA&gt;        859\n#&gt;  2  2018 January  2-4   &lt;NA&gt;         NA\n#&gt;  3  2018 January  5+    &lt;NA&gt;        348\n#&gt;  4  2018 January  &lt;NA&gt;  Northeast   114\n#&gt;  5  2018 January  &lt;NA&gt;  Midwest     169\n#&gt;  6  2018 January  &lt;NA&gt;  South       596\n#&gt;  7  2018 January  &lt;NA&gt;  West        339\n#&gt;  8  2018 February 1     &lt;NA&gt;        882\n#&gt;  9  2018 February 2-4   &lt;NA&gt;         NA\n#&gt; 10  2018 February 5+    &lt;NA&gt;        400\n#&gt; # ℹ 53 more rows\n\nSince there is no overlap between the units and region data, it would actually be better to place them in two separate tables.\n\n10.4.4 Theory\nThe same spec is used for pivot_longer() and pivot_wider(). You can see this through the symmetry of the two functions.\n\nconstruction |&gt; \n  pivot_longer_spec(spec) |&gt; \n  pivot_wider_spec(spec)\n#&gt; # A tibble: 9 × 9\n#&gt;    Year Month  `1 unit` `2 to 4 units` `5 units or more` Northeast Midwest South\n#&gt;   &lt;dbl&gt; &lt;chr&gt;     &lt;dbl&gt;          &lt;dbl&gt;             &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1  2018 Janua…      859             NA               348       114     169   596\n#&gt; 2  2018 Febru…      882             NA               400       138     160   655\n#&gt; 3  2018 March       862             NA               356       150     154   595\n#&gt; 4  2018 April       797             NA               447       144     196   613\n#&gt; 5  2018 May         875             NA               364        90     169   673\n#&gt; 6  2018 June        867             NA               342        76     170   610\n#&gt; 7  2018 July        829             NA               360       108     183   594\n#&gt; 8  2018 August      939             NA               286        90     205   649\n#&gt; 9  2018 Septe…      835             NA               304       117     175   560\n#&gt; # ℹ 1 more variable: West &lt;dbl&gt;",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>tidyr: Pivoting</span>"
    ]
  },
  {
    "objectID": "01-tidyr-rectangling.html",
    "href": "01-tidyr-rectangling.html",
    "title": "11  tidyr: Rectandling",
    "section": "",
    "text": "11.1 GitHub users\nData: gh_users\nEach user is a named list, where each element represents a column.\nusers &lt;- tibble(user = gh_users)\nusers\n#&gt; # A tibble: 6 × 1\n#&gt;   user             \n#&gt;   &lt;list&gt;           \n#&gt; 1 &lt;named list [30]&gt;\n#&gt; 2 &lt;named list [30]&gt;\n#&gt; 3 &lt;named list [30]&gt;\n#&gt; 4 &lt;named list [30]&gt;\n#&gt; 5 &lt;named list [30]&gt;\n#&gt; 6 &lt;named list [30]&gt;\n\n# names in list\nnames(users$user[[1]])\n#&gt;  [1] \"login\"               \"id\"                  \"avatar_url\"         \n#&gt;  [4] \"gravatar_id\"         \"url\"                 \"html_url\"           \n#&gt;  [7] \"followers_url\"       \"following_url\"       \"gists_url\"          \n#&gt; [10] \"starred_url\"         \"subscriptions_url\"   \"organizations_url\"  \n#&gt; [13] \"repos_url\"           \"events_url\"          \"received_events_url\"\n#&gt; [16] \"type\"                \"site_admin\"          \"name\"               \n#&gt; [19] \"company\"             \"blog\"                \"location\"           \n#&gt; [22] \"email\"               \"hireable\"            \"bio\"                \n#&gt; [25] \"public_repos\"        \"public_gists\"        \"followers\"          \n#&gt; [28] \"following\"           \"created_at\"          \"updated_at\"\nunnest_wider(): takes every component and makes a new column.\nusers |&gt; unnest_wider(user)\n#&gt; # A tibble: 6 × 30\n#&gt;   login     id avatar_url gravatar_id url   html_url followers_url following_url\n#&gt;   &lt;chr&gt;  &lt;int&gt; &lt;chr&gt;      &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;    &lt;chr&gt;         &lt;chr&gt;        \n#&gt; 1 gabo… 6.60e5 https://a… \"\"          http… https:/… https://api.… https://api.…\n#&gt; 2 jenn… 5.99e5 https://a… \"\"          http… https:/… https://api.… https://api.…\n#&gt; 3 jtle… 1.57e6 https://a… \"\"          http… https:/… https://api.… https://api.…\n#&gt; 4 juli… 1.25e7 https://a… \"\"          http… https:/… https://api.… https://api.…\n#&gt; 5 leep… 3.51e6 https://a… \"\"          http… https:/… https://api.… https://api.…\n#&gt; 6 masa… 8.36e6 https://a… \"\"          http… https:/… https://api.… https://api.…\n#&gt; # ℹ 22 more variables: gists_url &lt;chr&gt;, starred_url &lt;chr&gt;,\n#&gt; #   subscriptions_url &lt;chr&gt;, organizations_url &lt;chr&gt;, repos_url &lt;chr&gt;,\n#&gt; #   events_url &lt;chr&gt;, received_events_url &lt;chr&gt;, type &lt;chr&gt;, site_admin &lt;lgl&gt;,\n#&gt; #   name &lt;chr&gt;, company &lt;chr&gt;, blog &lt;chr&gt;, location &lt;chr&gt;, email &lt;chr&gt;,\n#&gt; #   hireable &lt;lgl&gt;, bio &lt;chr&gt;, public_repos &lt;int&gt;, public_gists &lt;int&gt;,\n#&gt; #   followers &lt;int&gt;, following &lt;int&gt;, created_at &lt;chr&gt;, updated_at &lt;chr&gt;\nhoist(): pulls out selected components using the same syntax as purrr::pluck(). It moves components out of the inner list into the top-level data frame as columns.\nusers |&gt; hoist(user, \n  followers = \"followers\", \n  login = \"login\", \n  url = \"html_url\"\n)\n#&gt; # A tibble: 6 × 4\n#&gt;   followers login       url                            user             \n#&gt;       &lt;int&gt; &lt;chr&gt;       &lt;chr&gt;                          &lt;list&gt;           \n#&gt; 1       303 gaborcsardi https://github.com/gaborcsardi &lt;named list [27]&gt;\n#&gt; 2       780 jennybc     https://github.com/jennybc     &lt;named list [27]&gt;\n#&gt; 3      3958 jtleek      https://github.com/jtleek      &lt;named list [27]&gt;\n#&gt; 4       115 juliasilge  https://github.com/juliasilge  &lt;named list [27]&gt;\n#&gt; 5       213 leeper      https://github.com/leeper      &lt;named list [27]&gt;\n#&gt; 6        34 masalmon    https://github.com/masalmon    &lt;named list [27]&gt;",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>tidyr: Rectandling</span>"
    ]
  },
  {
    "objectID": "01-tidyr-rectangling.html#sec-gh-repos",
    "href": "01-tidyr-rectangling.html#sec-gh-repos",
    "title": "11  tidyr: Rectandling",
    "section": "\n11.2 GitHub repos",
    "text": "11.2 GitHub repos\nData: gh_repos\ngh_repos is a list of repositories that belong to six different users.\n\nrepos &lt;- tibble(repo = gh_repos)\nrepos\n#&gt; # A tibble: 6 × 1\n#&gt;   repo       \n#&gt;   &lt;list&gt;     \n#&gt; 1 &lt;list [30]&gt;\n#&gt; 2 &lt;list [30]&gt;\n#&gt; 3 &lt;list [30]&gt;\n#&gt; 4 &lt;list [26]&gt;\n#&gt; 5 &lt;list [30]&gt;\n#&gt; 6 &lt;list [30]&gt;\n\nFirst need to use unnest_longer() because the first level of the list is a list of observations.\n\nrepos &lt;- repos |&gt; unnest_longer(repo)\nrepos\n#&gt; # A tibble: 176 × 1\n#&gt;    repo             \n#&gt;    &lt;list&gt;           \n#&gt;  1 &lt;named list [68]&gt;\n#&gt;  2 &lt;named list [68]&gt;\n#&gt;  3 &lt;named list [68]&gt;\n#&gt;  4 &lt;named list [68]&gt;\n#&gt;  5 &lt;named list [68]&gt;\n#&gt;  6 &lt;named list [68]&gt;\n#&gt;  7 &lt;named list [68]&gt;\n#&gt;  8 &lt;named list [68]&gt;\n#&gt;  9 &lt;named list [68]&gt;\n#&gt; 10 &lt;named list [68]&gt;\n#&gt; # ℹ 166 more rows\n\nThen we can use unnest_wider() or hoist(). This uses login = c(\"owner\", \"login\") to reach two levels deep inside of a list.\n\nrepos |&gt; hoist(repo, \n  login = c(\"owner\", \"login\"), \n  name = \"name\",\n  homepage = \"homepage\",\n  watchers = \"watchers_count\"\n)\n#&gt; # A tibble: 176 × 5\n#&gt;    login       name        homepage watchers repo             \n#&gt;    &lt;chr&gt;       &lt;chr&gt;       &lt;chr&gt;       &lt;int&gt; &lt;list&gt;           \n#&gt;  1 gaborcsardi after       &lt;NA&gt;            5 &lt;named list [65]&gt;\n#&gt;  2 gaborcsardi argufy      &lt;NA&gt;           19 &lt;named list [65]&gt;\n#&gt;  3 gaborcsardi ask         &lt;NA&gt;            5 &lt;named list [65]&gt;\n#&gt;  4 gaborcsardi baseimports &lt;NA&gt;            0 &lt;named list [65]&gt;\n#&gt;  5 gaborcsardi citest      &lt;NA&gt;            0 &lt;named list [65]&gt;\n#&gt;  6 gaborcsardi clisymbols  \"\"             18 &lt;named list [65]&gt;\n#&gt;  7 gaborcsardi cmaker      &lt;NA&gt;            0 &lt;named list [65]&gt;\n#&gt;  8 gaborcsardi cmark       &lt;NA&gt;            0 &lt;named list [65]&gt;\n#&gt;  9 gaborcsardi conditions  &lt;NA&gt;            0 &lt;named list [65]&gt;\n#&gt; 10 gaborcsardi crayon      &lt;NA&gt;           52 &lt;named list [65]&gt;\n#&gt; # ℹ 166 more rows",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>tidyr: Rectandling</span>"
    ]
  },
  {
    "objectID": "01-tidyr-rectangling.html#sec-got",
    "href": "01-tidyr-rectangling.html#sec-got",
    "title": "11  tidyr: Rectandling",
    "section": "\n11.3 Game of Thrones characters",
    "text": "11.3 Game of Thrones characters\nData: got_chars\ngot_chars has a similar structure to gh_users: it is a list of named lists, where each element of the inner list describes some attribute of a GoT character.\n\nchars &lt;- tibble(char = got_chars)\nchars\n#&gt; # A tibble: 30 × 1\n#&gt;    char             \n#&gt;    &lt;list&gt;           \n#&gt;  1 &lt;named list [18]&gt;\n#&gt;  2 &lt;named list [18]&gt;\n#&gt;  3 &lt;named list [18]&gt;\n#&gt;  4 &lt;named list [18]&gt;\n#&gt;  5 &lt;named list [18]&gt;\n#&gt;  6 &lt;named list [18]&gt;\n#&gt;  7 &lt;named list [18]&gt;\n#&gt;  8 &lt;named list [18]&gt;\n#&gt;  9 &lt;named list [18]&gt;\n#&gt; 10 &lt;named list [18]&gt;\n#&gt; # ℹ 20 more rows\n\nchars &lt;- chars |&gt; unnest_wider(char)\nchars\n#&gt; # A tibble: 30 × 18\n#&gt;    url           id name  gender culture born  died  alive titles aliases father\n#&gt;    &lt;chr&gt;      &lt;int&gt; &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; &lt;lgl&gt; &lt;list&gt; &lt;list&gt;  &lt;chr&gt; \n#&gt;  1 https://w…  1022 Theo… Male   \"Ironb… \"In … \"\"    TRUE  &lt;chr&gt;  &lt;chr&gt;   \"\"    \n#&gt;  2 https://w…  1052 Tyri… Male   \"\"      \"In … \"\"    TRUE  &lt;chr&gt;  &lt;chr&gt;   \"\"    \n#&gt;  3 https://w…  1074 Vict… Male   \"Ironb… \"In … \"\"    TRUE  &lt;chr&gt;  &lt;chr&gt;   \"\"    \n#&gt;  4 https://w…  1109 Will  Male   \"\"      \"\"    \"In … FALSE &lt;chr&gt;  &lt;chr&gt;   \"\"    \n#&gt;  5 https://w…  1166 Areo… Male   \"Norvo… \"In … \"\"    TRUE  &lt;chr&gt;  &lt;chr&gt;   \"\"    \n#&gt;  6 https://w…  1267 Chett Male   \"\"      \"At … \"In … FALSE &lt;chr&gt;  &lt;chr&gt;   \"\"    \n#&gt;  7 https://w…  1295 Cres… Male   \"\"      \"In … \"In … FALSE &lt;chr&gt;  &lt;chr&gt;   \"\"    \n#&gt;  8 https://w…   130 Aria… Female \"Dorni… \"In … \"\"    TRUE  &lt;chr&gt;  &lt;chr&gt;   \"\"    \n#&gt;  9 https://w…  1303 Daen… Female \"Valyr… \"In … \"\"    TRUE  &lt;chr&gt;  &lt;chr&gt;   \"\"    \n#&gt; 10 https://w…  1319 Davo… Male   \"Weste… \"In … \"\"    TRUE  &lt;chr&gt;  &lt;chr&gt;   \"\"    \n#&gt; # ℹ 20 more rows\n#&gt; # ℹ 7 more variables: mother &lt;chr&gt;, spouse &lt;chr&gt;, allegiances &lt;list&gt;,\n#&gt; #   books &lt;list&gt;, povBooks &lt;list&gt;, tvSeries &lt;list&gt;, playedBy &lt;list&gt;\n\nThe difference with gh_users is that many of the resulting columns are themselves list columns. What you do next is an issue of what you want to do in your analysis.\nMaybe you want a row for every book and TV series that the character appears in:\n\nchars |&gt; \n  select(name, books, tvSeries) |&gt; \n  pivot_longer(c(books, tvSeries),\n               names_to = \"media\",\n               values_to = \"value\") |&gt; \n  unnest_longer(value)\n#&gt; # A tibble: 179 × 3\n#&gt;    name             media    value            \n#&gt;    &lt;chr&gt;            &lt;chr&gt;    &lt;chr&gt;            \n#&gt;  1 Theon Greyjoy    books    A Game of Thrones\n#&gt;  2 Theon Greyjoy    books    A Storm of Swords\n#&gt;  3 Theon Greyjoy    books    A Feast for Crows\n#&gt;  4 Theon Greyjoy    tvSeries Season 1         \n#&gt;  5 Theon Greyjoy    tvSeries Season 2         \n#&gt;  6 Theon Greyjoy    tvSeries Season 3         \n#&gt;  7 Theon Greyjoy    tvSeries Season 4         \n#&gt;  8 Theon Greyjoy    tvSeries Season 5         \n#&gt;  9 Theon Greyjoy    tvSeries Season 6         \n#&gt; 10 Tyrion Lannister books    A Feast for Crows\n#&gt; # ℹ 169 more rows\n\nMaybe you want to build a table that lets you match title to name:\n\nchars |&gt; \n  select(name, title = titles) |&gt; \n  unnest_longer(title)\n#&gt; # A tibble: 59 × 2\n#&gt;    name              title                                                 \n#&gt;    &lt;chr&gt;             &lt;chr&gt;                                                 \n#&gt;  1 Theon Greyjoy     \"Prince of Winterfell\"                                \n#&gt;  2 Theon Greyjoy     \"Lord of the Iron Islands (by law of the green lands)\"\n#&gt;  3 Tyrion Lannister  \"Acting Hand of the King (former)\"                    \n#&gt;  4 Tyrion Lannister  \"Master of Coin (former)\"                             \n#&gt;  5 Victarion Greyjoy \"Lord Captain of the Iron Fleet\"                      \n#&gt;  6 Victarion Greyjoy \"Master of the Iron Victory\"                          \n#&gt;  7 Will              \"\"                                                    \n#&gt;  8 Areo Hotah        \"Captain of the Guard at Sunspear\"                    \n#&gt;  9 Chett             \"\"                                                    \n#&gt; 10 Cressen           \"Maester\"                                             \n#&gt; # ℹ 49 more rows",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>tidyr: Rectandling</span>"
    ]
  },
  {
    "objectID": "01-tidyr-rectangling.html#sec-geocode",
    "href": "01-tidyr-rectangling.html#sec-geocode",
    "title": "11  tidyr: Rectandling",
    "section": "\n11.4 Geocoding with Google",
    "text": "11.4 Geocoding with Google\nData: gmaps_cities\ngmaps_cities is a tibble with a list column of lists of various depths. To deal with this, you need to alternate between various unnest_longer() and unnest_wider() or hoist() to get at different types of data.\n\ngmaps_cities\n#&gt; # A tibble: 5 × 2\n#&gt;   city       json            \n#&gt;   &lt;chr&gt;      &lt;list&gt;          \n#&gt; 1 Houston    &lt;named list [2]&gt;\n#&gt; 2 Washington &lt;named list [2]&gt;\n#&gt; 3 New York   &lt;named list [2]&gt;\n#&gt; 4 Chicago    &lt;named list [2]&gt;\n#&gt; 5 Arlington  &lt;named list [2]&gt;\n\njson is a list-column of named lists, so it makes sense to start with unnest_wider():\n\ngmaps_cities |&gt;\n  unnest_wider(json)\n#&gt; # A tibble: 5 × 3\n#&gt;   city       results    status\n#&gt;   &lt;chr&gt;      &lt;list&gt;     &lt;chr&gt; \n#&gt; 1 Houston    &lt;list [1]&gt; OK    \n#&gt; 2 Washington &lt;list [2]&gt; OK    \n#&gt; 3 New York   &lt;list [1]&gt; OK    \n#&gt; 4 Chicago    &lt;list [1]&gt; OK    \n#&gt; 5 Arlington  &lt;list [2]&gt; OK\n\nThe results column is a list of lists. Most are length 1, but some are length 2, so we need to use unnest_longer() to add these observations. These, can then be unnested wider to get at various columns.\n\nrepurrrsive::gmaps_cities |&gt;\n  unnest_wider(json) |&gt; \n  unnest_longer(results) |&gt; \n  unnest_wider(results)\n#&gt; # A tibble: 7 × 7\n#&gt;   city  address_components formatted_address geometry     place_id types  status\n#&gt;   &lt;chr&gt; &lt;list&gt;             &lt;chr&gt;             &lt;list&gt;       &lt;chr&gt;    &lt;list&gt; &lt;chr&gt; \n#&gt; 1 Hous… &lt;list [4]&gt;         Houston, TX, USA  &lt;named list&gt; ChIJAYW… &lt;list&gt; OK    \n#&gt; 2 Wash… &lt;list [2]&gt;         Washington, USA   &lt;named list&gt; ChIJ-bD… &lt;list&gt; OK    \n#&gt; 3 Wash… &lt;list [4]&gt;         Washington, DC, … &lt;named list&gt; ChIJW-T… &lt;list&gt; OK    \n#&gt; 4 New … &lt;list [3]&gt;         New York, NY, USA &lt;named list&gt; ChIJOwg… &lt;list&gt; OK    \n#&gt; 5 Chic… &lt;list [4]&gt;         Chicago, IL, USA  &lt;named list&gt; ChIJ7cv… &lt;list&gt; OK    \n#&gt; 6 Arli… &lt;list [4]&gt;         Arlington, TX, U… &lt;named list&gt; ChIJ05g… &lt;list&gt; OK    \n#&gt; 7 Arli… &lt;list [4]&gt;         Arlington, VA, U… &lt;named list&gt; ChIJD6e… &lt;list&gt; OK\n\nTo get at lat/lng data we need to go through location:\n\ngmaps_cities |&gt;\n  unnest_wider(json) |&gt;\n  unnest_longer(results) |&gt;\n  unnest_wider(results) |&gt;\n  unnest_wider(geometry) |&gt;\n  unnest_wider(location)\n#&gt; # A tibble: 7 × 11\n#&gt;   city       address_components formatted_address   bounds         lat    lng\n#&gt;   &lt;chr&gt;      &lt;list&gt;             &lt;chr&gt;               &lt;list&gt;       &lt;dbl&gt;  &lt;dbl&gt;\n#&gt; 1 Houston    &lt;list [4]&gt;         Houston, TX, USA    &lt;named list&gt;  29.8  -95.4\n#&gt; 2 Washington &lt;list [2]&gt;         Washington, USA     &lt;named list&gt;  47.8 -121. \n#&gt; 3 Washington &lt;list [4]&gt;         Washington, DC, USA &lt;named list&gt;  38.9  -77.0\n#&gt; 4 New York   &lt;list [3]&gt;         New York, NY, USA   &lt;named list&gt;  40.7  -74.0\n#&gt; 5 Chicago    &lt;list [4]&gt;         Chicago, IL, USA    &lt;named list&gt;  41.9  -87.6\n#&gt; 6 Arlington  &lt;list [4]&gt;         Arlington, TX, USA  &lt;named list&gt;  32.7  -97.1\n#&gt; 7 Arlington  &lt;list [4]&gt;         Arlington, VA, USA  &lt;named list&gt;  38.9  -77.1\n#&gt; # ℹ 5 more variables: location_type &lt;chr&gt;, viewport &lt;list&gt;, place_id &lt;chr&gt;,\n#&gt; #   types &lt;list&gt;, status &lt;chr&gt;\n\nOr use hoist() to dive deeply to get directly to lat and lng:\n\ngmaps_cities |&gt;\n  hoist(json,\n    lat = list(\"results\", 1, \"geometry\", \"location\", \"lat\"),\n    lng = list(\"results\", 1, \"geometry\", \"location\", \"lng\")\n  )\n#&gt; # A tibble: 5 × 4\n#&gt;   city         lat    lng json            \n#&gt;   &lt;chr&gt;      &lt;dbl&gt;  &lt;dbl&gt; &lt;list&gt;          \n#&gt; 1 Houston     29.8  -95.4 &lt;named list [2]&gt;\n#&gt; 2 Washington  47.8 -121.  &lt;named list [2]&gt;\n#&gt; 3 New York    40.7  -74.0 &lt;named list [2]&gt;\n#&gt; 4 Chicago     41.9  -87.6 &lt;named list [2]&gt;\n#&gt; 5 Arlington   32.7  -97.1 &lt;named list [2]&gt;",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>tidyr: Rectandling</span>"
    ]
  },
  {
    "objectID": "01-tidyr-rectangling.html#sec-discography",
    "href": "01-tidyr-rectangling.html#sec-discography",
    "title": "11  tidyr: Rectandling",
    "section": "\n11.5 Sharla Gelfand’s discography",
    "text": "11.5 Sharla Gelfand’s discography\nData: discog\n\ndiscs &lt;- tibble(disc = discog) |&gt; \n  unnest_wider(disc) |&gt; \n  mutate(date_added = as.POSIXct(strptime(date_added, \"%Y-%m-%dT%H:%M:%S\"))) \ndiscs\n#&gt; # A tibble: 155 × 5\n#&gt;    instance_id date_added          basic_information       id rating\n#&gt;          &lt;int&gt; &lt;dttm&gt;              &lt;list&gt;               &lt;int&gt;  &lt;int&gt;\n#&gt;  1   354823933 2019-02-16 17:48:59 &lt;named list [11]&gt;  7496378      0\n#&gt;  2   354092601 2019-02-13 14:13:11 &lt;named list [11]&gt;  4490852      0\n#&gt;  3   354091476 2019-02-13 14:07:23 &lt;named list [11]&gt;  9827276      0\n#&gt;  4   351244906 2019-02-02 11:39:58 &lt;named list [11]&gt;  9769203      0\n#&gt;  5   351244801 2019-02-02 11:39:37 &lt;named list [11]&gt;  7237138      0\n#&gt;  6   351052065 2019-02-01 20:40:53 &lt;named list [11]&gt; 13117042      0\n#&gt;  7   350315345 2019-01-29 15:48:37 &lt;named list [11]&gt;  7113575      0\n#&gt;  8   350315103 2019-01-29 15:47:22 &lt;named list [11]&gt; 10540713      0\n#&gt;  9   350314507 2019-01-29 15:44:08 &lt;named list [11]&gt; 11260950      0\n#&gt; 10   350314047 2019-01-29 15:41:35 &lt;named list [11]&gt; 11726853      0\n#&gt; # ℹ 145 more rows\n\nNeed to drop id column because this information is repeated in the basic_information list. Can either get rid of id or use hoist().\n\ndiscs |&gt; \n  select(!id) |&gt; \n  unnest_wider(basic_information)\n#&gt; # A tibble: 155 × 14\n#&gt;    instance_id date_added          labels  year master_url  artists     id thumb\n#&gt;          &lt;int&gt; &lt;dttm&gt;              &lt;list&gt; &lt;int&gt; &lt;chr&gt;       &lt;list&gt;   &lt;int&gt; &lt;chr&gt;\n#&gt;  1   354823933 2019-02-16 17:48:59 &lt;list&gt;  2015 &lt;NA&gt;        &lt;list&gt;  7.50e6 \"htt…\n#&gt;  2   354092601 2019-02-13 14:13:11 &lt;list&gt;  2013 https://ap… &lt;list&gt;  4.49e6 \"htt…\n#&gt;  3   354091476 2019-02-13 14:07:23 &lt;list&gt;  2017 https://ap… &lt;list&gt;  9.83e6 \"htt…\n#&gt;  4   351244906 2019-02-02 11:39:58 &lt;list&gt;  2017 https://ap… &lt;list&gt;  9.77e6 \"htt…\n#&gt;  5   351244801 2019-02-02 11:39:37 &lt;list&gt;  2015 https://ap… &lt;list&gt;  7.24e6 \"htt…\n#&gt;  6   351052065 2019-02-01 20:40:53 &lt;list&gt;  2019 https://ap… &lt;list&gt;  1.31e7 \"htt…\n#&gt;  7   350315345 2019-01-29 15:48:37 &lt;list&gt;  2014 https://ap… &lt;list&gt;  7.11e6 \"htt…\n#&gt;  8   350315103 2019-01-29 15:47:22 &lt;list&gt;  2015 https://ap… &lt;list&gt;  1.05e7 \"htt…\n#&gt;  9   350314507 2019-01-29 15:44:08 &lt;list&gt;  2017 https://ap… &lt;list&gt;  1.13e7 \"\"   \n#&gt; 10   350314047 2019-01-29 15:41:35 &lt;list&gt;  2017 &lt;NA&gt;        &lt;list&gt;  1.17e7 \"htt…\n#&gt; # ℹ 145 more rows\n#&gt; # ℹ 6 more variables: title &lt;chr&gt;, formats &lt;list&gt;, cover_image &lt;chr&gt;,\n#&gt; #   resource_url &lt;chr&gt;, master_id &lt;int&gt;, rating &lt;int&gt;\n\n# Or hoist\ndiscs |&gt; \n  hoist(basic_information,\n    title = \"title\",\n    year = \"year\",\n    label = list(\"labels\", 1, \"name\"),\n    artist = list(\"artists\", 1, \"name\")\n  )\n#&gt; # A tibble: 155 × 9\n#&gt;    instance_id date_added          title     year label artist basic_information\n#&gt;          &lt;int&gt; &lt;dttm&gt;              &lt;chr&gt;    &lt;int&gt; &lt;chr&gt; &lt;chr&gt;  &lt;list&gt;           \n#&gt;  1   354823933 2019-02-16 17:48:59 Demo      2015 Tobi… Mollot &lt;named list [9]&gt; \n#&gt;  2   354092601 2019-02-13 14:13:11 Observa…  2013 La V… Una B… &lt;named list [9]&gt; \n#&gt;  3   354091476 2019-02-13 14:07:23 I         2017 La V… S.H.I… &lt;named list [9]&gt; \n#&gt;  4   351244906 2019-02-02 11:39:58 Oído Ab…  2017 La V… Rata … &lt;named list [9]&gt; \n#&gt;  5   351244801 2019-02-02 11:39:37 A Cat's…  2015 Kato… Ivy (… &lt;named list [9]&gt; \n#&gt;  6   351052065 2019-02-01 20:40:53 Tashme    2019 High… Tashme &lt;named list [9]&gt; \n#&gt;  7   350315345 2019-01-29 15:48:37 Demo      2014 Mind… Desgr… &lt;named list [9]&gt; \n#&gt;  8   350315103 2019-01-29 15:47:22 Let The…  2015 Not … Phant… &lt;named list [9]&gt; \n#&gt;  9   350314507 2019-01-29 15:44:08 Sub Spa…  2017 Not … Sub S… &lt;named list [9]&gt; \n#&gt; 10   350314047 2019-01-29 15:41:35 Demo      2017 Pres… Small… &lt;named list [9]&gt; \n#&gt; # ℹ 145 more rows\n#&gt; # ℹ 2 more variables: id &lt;int&gt;, rating &lt;int&gt;",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>tidyr: Rectandling</span>"
    ]
  },
  {
    "objectID": "01-purrr.html",
    "href": "01-purrr.html",
    "title": "12  purrr",
    "section": "",
    "text": "12.1 purrr resources\nlibrary(purrr)",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>purrr</span>"
    ]
  },
  {
    "objectID": "01-purrr.html#sec-resources",
    "href": "01-purrr.html#sec-resources",
    "title": "12  purrr",
    "section": "",
    "text": "purrr website\npurrr 1.0.0 blog post\npurrr 1.0.0 - Hadley Wickham video\npurrr::walk() this way",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>purrr</span>"
    ]
  },
  {
    "objectID": "01-purrr.html#sec-map-family",
    "href": "01-purrr.html#sec-map-family",
    "title": "12  purrr",
    "section": "\n12.2 Map family",
    "text": "12.2 Map family\n\n12.2.1 Functions\n\n\nmap() always returns a list.\n\nmap_lgl(), map_int(), map_dbl(), and map_chr() return an atomic vector of the indicated type (or die trying).\n\nmap_vec(.ptype = NULL) simplifies to the common type of the output. It works with most types of simple vectors like Date, POSIXct, factors, etc.\n\nwalk(): calls .f for its side-effect and returns the input .x.\n\n12.2.2 Arguments\n\n\n.f options\n\nA named function: mean\n\nAnonymous function: \\(x) x + 1\n\nFormula: ~ .x + 1\n\nA string, integer, or list as short hand for pluck()\n\n\n\n\n.progress: Whether to have a progress bar\n\n.default: specifies value for elements that are missing or NULL.\n\nThe preference from purrr 1.0.0 is to use anonymous function style instead of formula or using ... to put in arguments.\n\n12.2.3 map()\n\n\n# Random generation of vector with the normal distribution of set mean\n1:5 |&gt;\n  map(\\(x) rnorm(n = 10, mean = x))\n#&gt; [[1]]\n#&gt;  [1] -1.2330706  0.7444393  2.4552033  2.3080622 -1.3509777  1.2861627\n#&gt;  [7] -0.8937846  1.1150449  0.5775427  1.0976453\n#&gt; \n#&gt; [[2]]\n#&gt;  [1]  1.7014398  1.0040024  2.0220898 -0.4113552  2.0727388  1.4441715\n#&gt;  [7] -0.6858499  2.3231469  2.6053517  2.7881240\n#&gt; \n#&gt; [[3]]\n#&gt;  [1] 3.374639 1.078416 3.468923 3.416896 4.082143 4.825970 2.098419 3.404699\n#&gt;  [9] 2.186966 3.668954\n#&gt; \n#&gt; [[4]]\n#&gt;  [1] 3.145787 4.350311 3.202518 4.013772 3.605510 3.251420 1.686825 3.362793\n#&gt;  [9] 3.681291 4.796950\n#&gt; \n#&gt; [[5]]\n#&gt;  [1] 6.305505 5.302494 6.199307 5.612322 6.773631 5.688255 5.063160 7.106426\n#&gt;  [9] 3.801539 5.028287\n\n# Simplify output to a vector instead of a list\n# by computing the mean of the distributions\n1:5 |&gt;\n  map(\\(x) rnorm(n = 10, mean = x)) |&gt; \n  map_dbl(mean)\n#&gt; [1] 0.4142382 2.3074282 2.9051373 4.5171249 5.3758250\n\n\n12.2.4 pluck() style\nUse string, integer, or list as short hand for pluck(). See Section 12.5.1 on using pluck().\n\n\n\"idx\" short hand for \\(x) pluck(x, \"idx\")\n\n\n1 short hand for \\(x) pluck(x, 1)\n\n\nlist(\"idx\", 1) short hand for \\(x) pluck(x, \"idx\", 1)\n\nUse .default argument to specify elements that are missing or NULL\n\nNeed to change .default = NA to use map_dbl() or map_int()\n\n\n\n\n\n# Extract by name or position\nl1 &lt;- list(list(a = 1L), list(a = NULL, b = 2L), list(b = 3L))\n\n# name: elements named \"b\"\nl1 |&gt; map_int(\"b\", .default = NA)\n#&gt; [1] NA  2  3\n\n# position: 2nd element\nl1 |&gt; map_int(2, .default = NA)\n#&gt; [1] NA  2 NA\n\n# Supply multiple values to index deeply into a list\nl2 &lt;- list(\n  list(num = 1:3,     letters[1:3]),\n  list(num = 101:103, letters[4:6]),\n  list()\n)\n# map vs pluck\nl2 |&gt; map(c(2, 2))\n#&gt; [[1]]\n#&gt; [1] \"b\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"e\"\n#&gt; \n#&gt; [[3]]\n#&gt; NULL\nl2 |&gt; map(\\(x) pluck(x, 2, 2))\n#&gt; [[1]]\n#&gt; [1] \"b\"\n#&gt; \n#&gt; [[2]]\n#&gt; [1] \"e\"\n#&gt; \n#&gt; [[3]]\n#&gt; NULL\n\n# Use a list to mixes numeric indices and names\nl2 |&gt; map_int(list(\"num\", 3), .default = NA)\n#&gt; [1]   3 103  NA\n\n\n12.2.5 map() with data frames\n\n# Calculate on data frame columns and turn into list or vector\nmtcars |&gt; map_dbl(sum)\n#&gt;      mpg      cyl     disp       hp     drat       wt     qsec       vs \n#&gt;  642.900  198.000 7383.100 4694.000  115.090  102.952  571.160   14.000 \n#&gt;       am     gear     carb \n#&gt;   13.000  118.000   90.000",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>purrr</span>"
    ]
  },
  {
    "objectID": "01-purrr.html#sec-map-variant",
    "href": "01-purrr.html#sec-map-variant",
    "title": "12  purrr",
    "section": "\n12.3 Map variants",
    "text": "12.3 Map variants\n\n12.3.1 map_if() and map_at()\n\nConditionally apply function to some elements of x.\n\n\nmap_if(.x, .p, .f, .else = NULL) and map_at(.x, .at, .f)\n\n\n\niris |&gt; map_if(is.factor, as.character, .else = as.integer) |&gt; str()\n#&gt; List of 5\n#&gt;  $ Sepal.Length: int [1:150] 5 4 4 4 5 5 4 5 4 4 ...\n#&gt;  $ Sepal.Width : int [1:150] 3 3 3 3 3 3 3 3 2 3 ...\n#&gt;  $ Petal.Length: int [1:150] 1 1 1 1 1 1 1 1 1 1 ...\n#&gt;  $ Petal.Width : int [1:150] 0 0 0 0 0 0 0 0 0 0 ...\n#&gt;  $ Species     : chr [1:150] \"setosa\" \"setosa\" \"setosa\" \"setosa\" ...\n\n# Use numeric vector of positions select elements to change:\niris |&gt; map_at(c(4, 5), is.numeric) |&gt; str()\n#&gt; List of 5\n#&gt;  $ Sepal.Length: num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n#&gt;  $ Sepal.Width : num [1:150] 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n#&gt;  $ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n#&gt;  $ Petal.Width : logi TRUE\n#&gt;  $ Species     : logi FALSE\n\n# Use vector of names to specify which elements to change:\niris |&gt; map_at(\"Species\", toupper) |&gt; str()\n#&gt; List of 5\n#&gt;  $ Sepal.Length: num [1:150] 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...\n#&gt;  $ Sepal.Width : num [1:150] 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...\n#&gt;  $ Petal.Length: num [1:150] 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...\n#&gt;  $ Petal.Width : num [1:150] 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...\n#&gt;  $ Species     : chr [1:150] \"SETOSA\" \"SETOSA\" \"SETOSA\" \"SETOSA\" ...\n\n\n12.3.2 map_depth(.x, .depth, .f)\n\nMap or modify elements at a given depth\n\n\nmap_depth() or modify_depth()\n\n\n.depth argument\n\n\nmap_depth(x, 0, fun) is equivalent to fun(x).\n\nmap_depth(x, 1, fun) is equivalent to x &lt;- map(x, fun)\n\n\nmap_depth(x, 2, fun) is equivalent to x &lt;- map(x, \\(y) map(y, fun))\n\n\n\n\n\nx &lt;- list(a = list(foo = 1:2, bar = 3:4), b = list(baz = 5:6))\n\nx |&gt; map_depth(2, sum) |&gt; str()\n#&gt; List of 2\n#&gt;  $ a:List of 2\n#&gt;   ..$ foo: int 3\n#&gt;   ..$ bar: int 7\n#&gt;  $ b:List of 1\n#&gt;   ..$ baz: int 11\n\n\n12.3.3 map2(.x, .y, .f)\n\nMap over two inputs\n\n\nmap2_lgl(), map2_int(), map2_dbl(), map2_chr(), map2_vec(), and walk2()\n\n\n\nx &lt;- list(1, 1, 1)\ny &lt;- list(10, 20, 30)\n\nmap2(x, y, \\(x, y) x + y)\n#&gt; [[1]]\n#&gt; [1] 11\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 21\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 31\n\nmap2_dbl(x, y, \\(x, y) x + y)\n#&gt; [1] 11 21 31\n\n\n12.3.4 pmap(.l, .f)\n\nMap over multiple input simultaneously\n\n\npmap_lgl(), pmap_int(), pmap_dbl(), pmap_chr(), pmap_vec(), and pwalk()\n\n\n\nx &lt;- list(1, 1, 1)\ny &lt;- list(10, 20, 30)\nz &lt;- list(100, 200, 300)\n\npmap(list(x, y, z), sum)\n#&gt; [[1]]\n#&gt; [1] 111\n#&gt; \n#&gt; [[2]]\n#&gt; [1] 221\n#&gt; \n#&gt; [[3]]\n#&gt; [1] 331\n\npmap_dbl(list(x, y, z), sum)\n#&gt; [1] 111 221 331\n\n\n12.3.5 imap(.x, .f)\n\nApply a function to each element of a vector and its index.\n\nShort hand for map2(x, names(x), ...) if x has names, or map2(x, seq_along(x), ...) if it does not.\n\nimap_lgl(), imap_chr(), imap_int(), imap_dbl(), and iwalk()\n\n\n\n# Note that the order is value then index\nimap_chr(sample(10), paste)\n#&gt;  [1] \"5 1\"  \"8 2\"  \"6 3\"  \"4 4\"  \"2 5\"  \"9 6\"  \"10 7\" \"7 8\"  \"1 9\"  \"3 10\"\n\n# Use anonymous function to reverse value/index order in output\nimap_chr(sample(10), \\(x, idx) paste0(idx, \": \", x))\n#&gt;  [1] \"1: 7\"  \"2: 4\"  \"3: 2\"  \"4: 8\"  \"5: 3\"  \"6: 9\"  \"7: 1\"  \"8: 10\" \"9: 6\" \n#&gt; [10] \"10: 5\"\n\n# Name of column and calculated value of column\niwalk(mtcars, \\(x, idx) cat(idx, \": \", median(x), \"\\n\", sep = \"\"))\n#&gt; mpg: 19.2\n#&gt; cyl: 6\n#&gt; disp: 196.3\n#&gt; hp: 123\n#&gt; drat: 3.695\n#&gt; wt: 3.325\n#&gt; qsec: 17.71\n#&gt; vs: 0\n#&gt; am: 0\n#&gt; gear: 4\n#&gt; carb: 2\n\n\n12.3.6 modify(.x, .f)\n\nModify elements of .x by .f. Unlike map() family, modify() always returns an object of the same type.\n\n\nmodify() is a shortcut for x[[i]] &lt;- f(x[[i]]); return(x)\n\n\nmodify2(), modify_if(), modify_at()\n\nVery similar to map() family.",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>purrr</span>"
    ]
  },
  {
    "objectID": "01-purrr.html#sec-predicate",
    "href": "01-purrr.html#sec-predicate",
    "title": "12  purrr",
    "section": "\n12.4 Predicate functionals",
    "text": "12.4 Predicate functionals\nA predicate function is a function that either returns TRUE or FALSE. The predicate functionals take a vector and a predicate function and do something useful.\n\n12.4.1 keep(), discard(), compact()\n\nBy predicate function\n\n\nkeep(): keep elements\n\ndiscard(): discard elements\n\n\nset.seed(24)\n# Create a list of 5 values from 1:10\nx &lt;- rep(10, 10) |&gt;\n  map(\\(x) sample(x, size = 5))\n\n# Keep\nx |&gt; keep(\\(x) mean(x) &gt; 6)\n#&gt; [[1]]\n#&gt; [1] 10  6  9  8  2\n#&gt; \n#&gt; [[2]]\n#&gt; [1]  3  6  9 10  4\n\n# Discard\nx |&gt; discard(\\(x) mean(x) &gt; 6) |&gt; length()\n#&gt; [1] 8\n\nBy name or position\n\n\nkeep_at(): keep by name or position\n\ndiscard_at(): discard by name or position\n\n\nx &lt;- c(a = 1, b = 2, cat = 10, dog = 15, elephant = 5, e = 10)\nx |&gt; keep_at(letters)\n#&gt;  a  b  e \n#&gt;  1  2 10\nx |&gt; discard_at(letters)\n#&gt;      cat      dog elephant \n#&gt;       10       15        5\n\ncompact(): discards elements that are NULL or that have length zero\n\nlist(a = \"a\", b = NULL, c = integer(0), d = NA, e = list()) |&gt;\n  compact()\n#&gt; $a\n#&gt; [1] \"a\"\n#&gt; \n#&gt; $d\n#&gt; [1] NA\n\n\n12.4.2 detect()\n\nFind the value or position of the first match\n\ndetect()\ndetect_index()\n\n.direction argument\n\n\n\"forward\": starts at the beginning of the vector and move towards the end.\n\n\"backward\": starts at the end of the vector and moves towards the beginning.\n\n\n\n\nis_even &lt;- function(x) x %% 2 == 0\n\n3:10 |&gt; detect(is_even)\n#&gt; [1] 4\n3:10 |&gt; detect_index(is_even)\n#&gt; [1] 2\n\n# If you need to find all values, use keep()\n3:10 |&gt; keep(is_even)\n#&gt; [1]  4  6  8 10\n\n# If you need to find all positions, use map_lgl()\n3:10 |&gt; map_lgl(is_even) |&gt; which()\n#&gt; [1] 2 4 6 8\n\n\n12.4.3 every(), some(), none()\n\nDo every, some, or none of the elements of a list satisfy a predicate?\n\n\nsome(): TRUE when .p is TRUE for at least one element.\n\nevery(): TRUE when .p is TRUE for all elements.\n\nnone(): TRUE when .p is FALSE for all elements.\n\n\nx &lt;- list(0:10, 5.5)\nevery(x, is.integer)\n#&gt; [1] FALSE\nsome(x, is.integer)\n#&gt; [1] TRUE\nnone(x, is.character)\n#&gt; [1] TRUE\n\n\n12.4.4 has_element()\n\nhas_element(.x, .y): Does a list contain an object?\n\nx &lt;- list(1:10, 5, 9.9)\nx |&gt; has_element(1:10)\n#&gt; [1] TRUE\nx |&gt; has_element(3)\n#&gt; [1] FALSE",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>purrr</span>"
    ]
  },
  {
    "objectID": "01-purrr.html#sec-plucking",
    "href": "01-purrr.html#sec-plucking",
    "title": "12  purrr",
    "section": "\n12.5 Plucking",
    "text": "12.5 Plucking\n\n12.5.1 pluck()\n\npluck(.x, ...) implements a generalized form of [[ that allow you to index deeply and flexibly into data structures. It always succeeds, returning .default if the index you are trying to access does not exist or is NULL.\nYou can use a combination of numeric positions, vector or list names, and accessor functions.\n\n\npluck(x, 1) is equivalent to x[[1]]\n\n\npluck(x, 1, 2) is equivalent to x[[1]][[2]]\n\n\n\nx &lt;- list(\n  list(\"a\", list(1, elt = \"foo\")),\n  list(\"b\", list(2, elt = \"bar\"))\n)\n# equivalent to `x[[1]][[2]]`\npluck(x, 1, 2)\n#&gt; [[1]]\n#&gt; [1] 1\n#&gt; \n#&gt; $elt\n#&gt; [1] \"foo\"\n\n# Combine numeric positions with names\npluck(x, 1, 2, \"elt\")\n#&gt; [1] \"foo\"\n\n# By default returns `NULL` when an element does not exist\npluck(x, 10)\n#&gt; NULL\n\n# You can supply a default value for non-existing elements\npluck(x, 10, .default = NA)\n#&gt; [1] NA\n\nCan assign values with pluck() &lt;- x\n\npluck(x, 1, 2, 2) &lt;- \"kook\"\npluck(x, 1, 2, 2)\n#&gt; [1] \"kook\"\n\n\n12.5.2 chuck()\n\nchuck() is the same as pluck() but throws an error if the index does not exist.\n\nchuck(x, 1, 2, 2)\n#&gt; [1] \"kook\"\n\n# pluck vs chuck\npluck(x, 10)\n#&gt; NULL\nchuck(x, 10)\n#&gt; Error in `chuck()`:\n#&gt; ! Index 1 exceeds the length of plucked object (10 &gt; 2).\n\n\n12.5.3 assign_in() and modify_in()\n\nModify values in a pluck location.\n\n\nassign_in(x, where, value): Assigns a value to a pluck location.\n\nmodify_in(.x, .where, .f): Applies a function to a pluck location.\n\nwhere/.where arguments are a pluck location as a numeric vector of positions, a character vector of names, or a list combining both.\n\n\n# Return \"kook\" back to \"foo\"\npluck(x, 1, 2, 2)\n#&gt; [1] \"kook\"\nx &lt;- assign_in(x, c(1, 2, 2), \"foo\")\npluck(x, 1, 2, 2)\n#&gt; [1] \"foo\"\n\n# Modify a location by a function\npluck(x, 1, 2, \"elt\")\n#&gt; [1] \"foo\"\nx &lt;- modify_in(x, list(1, 2, \"elt\"), toupper)\npluck(x, 1, 2, \"elt\")\n#&gt; [1] \"FOO\"",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>purrr</span>"
    ]
  },
  {
    "objectID": "01-purrr.html#sec-transform",
    "href": "01-purrr.html#sec-transform",
    "title": "12  purrr",
    "section": "\n12.6 Transforming lists and vectors",
    "text": "12.6 Transforming lists and vectors\n\n12.6.1 list_flatten()\n\nRemoves a single level of hierarchy from a list; the output is always a list. Lists are flattened from outside to inside so the outermost list is flattened and inner lists are maintained.\nlist_flatten() supersedes flatten() in purrr 1.0.0.\n\nx &lt;- list(1, list(2, 3), list(4, list(5)))\nstr(x)\n#&gt; List of 3\n#&gt;  $ : num 1\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 2\n#&gt;   ..$ : num 3\n#&gt;  $ :List of 2\n#&gt;   ..$ : num 4\n#&gt;   ..$ :List of 1\n#&gt;   .. ..$ : num 5\n\n# 2nd-level lists are flattened\n# 3rd-level lists made into 2nd level\nx |&gt; list_flatten() |&gt; str()\n#&gt; List of 5\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : num 3\n#&gt;  $ : num 4\n#&gt;  $ :List of 1\n#&gt;   ..$ : num 5\n\n# Flat lists are left as is\nlist(1, 2, 3, 4, 5) |&gt; list_flatten() |&gt; str()\n#&gt; List of 5\n#&gt;  $ : num 1\n#&gt;  $ : num 2\n#&gt;  $ : num 3\n#&gt;  $ : num 4\n#&gt;  $ : num 5\n\n\n12.6.2 list_c()\n\nConcatenate the elements of a list to produce a vector. This allows elements in a list to be different lengths, breaking the one-to-one mapping between input and output of map() family of functions. Optional argument ptype to provide a prototype to ensure that the output type is always the same.\nlist_c() supersedes flatten_lgl(), flatten_int(), flatten_dbl(), and flatten_chr() in purrr 1.0.0.\n\nlist_c(list(1, 1:2, 1:3))\n#&gt; [1] 1 1 2 1 2 3\n\n\n12.6.3 list_simplify()\n\nReduces a list to a homogeneous vector; the output is always the same length as the input. Thus, all elements of the list must be length 1. Use .ptype to specify what class the resulting vector should be.\nlist_simplify() supersedes simplify(), simplify_all(), and as_vector() in purrr 1.0.0.\n\nlist_simplify(list(1, 2, 3))\n#&gt; [1] 1 2 3\n\n# Error with more than one element\nlist_simplify(list(1, 2, 1:3))\n#&gt; Error in `list_simplify()`:\n#&gt; ! `x[[3]]` must have size 1, not size 3.\n\n\n12.6.4 list_rbind() and list_cbind()\n\nCombine data frames together to create a larger data frame either by row or column. x must be a list of data frames.\nlist_rbind() and list_cbind() supersedes flatten_dfr() and flatten_dfc()in purrr 1.0.0.\n\nx &lt;- list(\n  a = data.frame(x = 1:2),\n  b = data.frame(y = \"a\")\n)\n# rbind\nlist_rbind(x)\n#&gt;    x    y\n#&gt; 1  1 &lt;NA&gt;\n#&gt; 2  2 &lt;NA&gt;\n#&gt; 3 NA    a\nlist_rbind(x, names_to = \"id\")\n#&gt;   id  x    y\n#&gt; 1  a  1 &lt;NA&gt;\n#&gt; 2  a  2 &lt;NA&gt;\n#&gt; 3  b NA    a\n\n#cbind\nlist_cbind(x)\n#&gt;   x y\n#&gt; 1 1 a\n#&gt; 2 2 a\n\n\n12.6.5 accumulate() and reduce()\n\n\nAccumulate intermediate results of a vector reduction.\n\n\naccumulate() and accumulate2()\n\n\n\nReduce a list to a single value by iteratively applying a binary function\n\n\nreduce() and reduce2()\n\n\n\n\n\n# accumulate is equivalent to cumsum\n1:5 |&gt; accumulate(`+`)\n#&gt; [1]  1  3  6 10 15\n\n# reduce is equivalent to sum\n1:5 |&gt; reduce(`+`)\n#&gt; [1] 15\n\n# with paste\naccumulate(letters[1:5], paste, sep = \".\")\n#&gt; [1] \"a\"         \"a.b\"       \"a.b.c\"     \"a.b.c.d\"   \"a.b.c.d.e\"\nreduce(letters[1:5], paste, sep = \".\")\n#&gt; [1] \"a.b.c.d.e\"",
    "crumbs": [
      "tidyverse",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>purrr</span>"
    ]
  },
  {
    "objectID": "02-ggplot2-rstudioconf-2022.html",
    "href": "02-ggplot2-rstudioconf-2022.html",
    "title": "13  RStudio conf 2022 ggplot2 workshop",
    "section": "",
    "text": "13.1 The Grammar of Graphics",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>RStudio conf 2022 ggplot2 workshop</span>"
    ]
  },
  {
    "objectID": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-grammar",
    "href": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-grammar",
    "title": "13  RStudio conf 2022 ggplot2 workshop",
    "section": "",
    "text": "Component\nFunction\nExplanation\n\n\n\nData\nggplot(data)\nThe raw data that you want to visualize.\n\n\nAesthetics\naes()\nAesthetic mappings between variables and visual properties.\n\n\nGeometries\ngeom_*()\nThe geometric shapes representing the data.\n\n\nStatistics\nstat_*()\nThe statistical transformations applied to the data.\n\n\nScales\nscale_*()\nMaps between the data and the aesthetic dimensions.\n\n\nCoordinate system\ncoord_*()\nMaps data into the plane of the data rectangle.\n\n\nFacets\nfacet_*()\nThe arrangement of the data into a grid of plots.\n\n\nVisual themes\n\ntheme()/theme_*()\n\nThe overall visual defaults of a plot.",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>RStudio conf 2022 ggplot2 workshop</span>"
    ]
  },
  {
    "objectID": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-aesthetic-mappings",
    "href": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-aesthetic-mappings",
    "title": "13  RStudio conf 2022 ggplot2 workshop",
    "section": "\n13.2 Aesthetic mappings",
    "text": "13.2 Aesthetic mappings\n\npositions: x, y\n\ncolors: color, fill\n\nshapes: shape, linetype\n\nsize: size\n\ntransparency: alpha\n\ngroupings: group\n\n\n\n13.2.1 Setting vs Mapping of visual properties\nAesthetics are set within geom_*() and are mapped within aes(). See line 6 in the examples below.\nggplot(\n    bikes,\n    aes(x = temp_feel, y = count)\n  ) +\n  geom_point(\n    color = \"#28a87d\",\n    alpha = .5\n  )\nggplot(\n    bikes,\n    aes(x = temp_feel, y = count)\n  ) +\n  geom_point(\n    aes(color = season),\n    alpha = .5\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou can map expressions directly within ggplot2.\n\nggplot(\n    bikes,\n    aes(x = temp_feel, y = count)\n  ) +\n  geom_point(\n    aes(color = temp_feel &gt; 20),\n    alpha = .5\n  )\n\n\n\n\n\n\n\n\n13.2.2 Local vs Global encoding\n\n\nLocal encoding: aesthetic properties only correspond to the specified geom.\n\nGlobal encoding aesthetic properties correspond to all geoms. This results in adding a group aesthetic to geoms such as geom_smooth()\n\n\nggplot(\n    bikes,\n    aes(x = temp_feel, y = count)\n  ) +\n  geom_point(\n    aes(color = season),\n    alpha = .5\n  ) + \n  geom_smooth(method = \"lm\")\nggplot(\n    bikes,\n    aes(x = temp_feel, y = count,\n        color = season)\n  ) +\n  geom_point(\n    alpha = .5\n  ) + \n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGlobal encodings are overridden by local encodings. In this case, this leads to a warning message. You can get rid of the warning message by setting a local color, such as color = \"black\".\n\nggplot(\n    bikes,\n    aes(x = temp_feel, y = count,\n        color = season)\n  ) +\n  geom_point(\n    alpha = .5\n  ) + \n  geom_smooth(\n    aes(group = day_night),\n    method = \"lm\")\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n#&gt; Warning: The following aesthetics were dropped during statistical transformation: colour\n#&gt; ℹ This can happen when ggplot fails to infer the correct grouping structure in\n#&gt;   the data.\n#&gt; ℹ Did you forget to specify a `group` aesthetic or to convert a numerical\n#&gt;   variable into a factor?",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>RStudio conf 2022 ggplot2 workshop</span>"
    ]
  },
  {
    "objectID": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-label-basics",
    "href": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-label-basics",
    "title": "13  RStudio conf 2022 ggplot2 workshop",
    "section": "\n13.3 Label basics",
    "text": "13.3 Label basics\nFor more detailed info on labels, see Section 13.7.\nCreate base plot\n\nCodeg &lt;-\n  ggplot(\n    bikes,\n    aes(x = temp_feel, y = count,\n        color = season,\n        group = day_night)\n  ) +\n  geom_point(\n    alpha = .5\n  ) +\n  geom_smooth(\n    method = \"lm\",\n    color = \"black\"\n  )\n\n\n\n13.3.1 labs labs()\n\n\nAesthetic name-value pairs: x = \"Date\", color = \"Season\"\n\ntitle\nsubtitle\n\ncaption: Displayed at the bottom-right of the plot by default.\n\ntag: Displayed at the top-left of the plot by default.\n\nalt: Text used for the generation of alt-text for the plot.\n\n13.3.2 Specific functions\n\nxlab()\nylab()\nggtitle()\n\n\ng +\n  labs(\n    x = \"Feels-like temperature (°F)\",\n    y = \"Reported bike shares\",\n    title = \"TfL bike sharing trends\",\n    subtitle = \"Reported bike rents versus feels-like temperature in London\",\n    caption = \"Data: TfL\",\n    color = \"Season:\",\n    tag = \"Fig. 1\"\n  )\ng &lt;- last_plot()",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>RStudio conf 2022 ggplot2 workshop</span>"
    ]
  },
  {
    "objectID": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-theme",
    "href": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-theme",
    "title": "13  RStudio conf 2022 ggplot2 workshop",
    "section": "\n13.4 Themes",
    "text": "13.4 Themes\nSee notes on themes for more information.\n\n13.4.1 Theme functions\n\n\ntheme(): modify components of a theme.\n\ntheme_set(): completely overrides the current theme.\n\ntheme_update(): Update individual elements of a plot.\n\n\n# Set theme for remaining plots \ntheme_set(theme_light())\n\n# Update theme\ntheme_update(\n  panel.grid.minor = element_blank(),\n  plot.title = element_text(face = \"bold\"),\n  legend.position = \"top\",\n  plot.title.position = \"plot\"\n)\n\ng",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>RStudio conf 2022 ggplot2 workshop</span>"
    ]
  },
  {
    "objectID": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-scales",
    "href": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-scales",
    "title": "13  RStudio conf 2022 ggplot2 workshop",
    "section": "\n13.5 Scales",
    "text": "13.5 Scales\nThe scale_*() components control the properties of all the aesthetic dimensions mapped to the data.\n\nPositions: scale_x_*() and scale_y_*()\n\n\ncontinuous(), discrete(), reverse(), identity(), log10(), sqrt(), date()\n\n\n\nColors: scale_color_*() and scale_fill_*()\n\n\ncontinuous(), discrete(), manual(), identity(), gradient(), gradient2(), brewer()\n\n\n\nSizes: scale_size_*() and scale_radius_*()\n\n\ncontinuous(),discrete(), manual(), identity() ordinal(), area(), date()\n\n\n\nShapes: scale_shape_*() and scale_linetype_*()\n\n\ncontinuous(), discrete(), manual(), identity(), ordinal()\n\n\n\nTransparency: scale_alpha_*()\n\n\ncontinuous(),discrete(), manual(), identity(), ordinal(), date()\n\n\n\n\nContinuous vs discrete\n\nContinuous: quantitative or numerical data – can have infinite values within given range.\nDiscrete: qualitative or categorical data – observations can only exist at limited values, often counts.\n\n\n13.5.1 Position arguments\n\n\nname: name used for the axis or legend title. If NULL the name will be omitted.\n\nbreaks: numeric vector or function that takes the limits of the input and returns breaks.\n\nlabels: labels used for axis breaks.\n\nlimits: numeric vector of length two providing minimum and maximum with NA to refer to the existing minimum or maximum. Or a function that accepts the existing (automatic) limits and returns new limits.\n\nSetting limits with scales removes data outside of the limits. If you want to zoom, use the limit argument in the coordinate system, see Section 13.6.1.\n\n\n\nexpand: Used to add or reduce padding around data along an axis.\n\nUse the convenience function expansion() to generate the values for the expand argument.\n\n\n\nna.value: value used to replace missing values.\n\ntrans: A transformation object bundles together a transform, its inverse, and methods for generating breaks and labels.\n\nguide: Specify, add, or remove guides.\n\nposition: For position scales, The position of the axis. left or right for y axes, top or bottom for x axes.\n\n\ng &lt;- ggplot(\n    bikes,\n    aes(x = date, y = count,\n        color = season)\n  ) +\n  geom_point() +\n  scale_y_continuous(\n    name = \"Reported bike shares\",\n    breaks = -1:5*15000,\n    expand = expansion(add = 2000)\n  ) + \n  scale_x_date(\n    name = NULL,\n    expand = expansion(add = 1),\n    date_labels = \"%Y/%m/%d\"\n  )\ng\n\n\n\n\n\n\n\n\n13.5.2 Color scales\n\ng + \n    scale_color_discrete(\n    name = \"Season:\",\n    type = c(\"#69b0d4\", \"#00CB79\", \"#F7B01B\", \"#a78f5f\")\n  )\n\n\n\n\n\n\n\n# With RColorBrewer\nlibrary(RColorBrewer)\ng + \n  scale_color_discrete(\n    name = \"Season:\",\n    type = brewer.pal(\n      n = 4, name = \"Dark2\"))\n# Or with scale_color_brewer\n# Also scale_color_viridis_d()\ng + \n  scale_color_brewer(\n    name = \"Season:\",\n    palette = \"Dark2\"\n    )",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>RStudio conf 2022 ggplot2 workshop</span>"
    ]
  },
  {
    "objectID": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-coords",
    "href": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-coords",
    "title": "13  RStudio conf 2022 ggplot2 workshop",
    "section": "\n13.6 Coordinate systems",
    "text": "13.6 Coordinate systems\n\nlinear coordinate systems: preserve the geometrical shapes\n\ncoord_cartesian()\ncoord_fixed()\ncoord_flip()\n\n\nnon-linear coordinate systems: likely change the geometrical shapes\n\ncoord_polar()\n\ncoord_map() and coord_sf()\n\ncoord_trans()\n\n\n\n\n13.6.1 Plot limits\nYou can set plot limits with the coordinate functions. This zooms into the plot instead of removing data that falls outside of those limits as is done with the scale_*() functions, see Section 13.5.1.\nggplot(\n    bikes,\n    aes(x = season, y = count)\n  ) +\n  geom_boxplot() +\n  coord_cartesian(\n    ylim = c(NA, 15000)\n  ) + \n  ggtitle(\"Zoomed plot\")\nggplot(\n    bikes,\n    aes(x = season, y = count)\n  ) +\n  geom_boxplot() +\n  scale_y_continuous(\n    limits = c(NA, 15000)\n  ) + \n  ggtitle(\"Filtered plot\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn easy way to remove padding in the plot limits is with expand = FALSE. When doing this, you might want to set clip = \"off\" to allow drawing points outside the plot area, so that points are cut in half. Usually you do not want to use clip = \"off\" because this allows plotting anywhere in the plot window.\n\nggplot(\n    bikes,\n    aes(x = temp_feel, y = count)\n  ) +\n  geom_point() +\n  coord_cartesian(\n    expand = FALSE,\n    clip = \"off\"\n  )\n\n\n\n\n\n\n\n\n13.6.2 Flipped coordinate system\ncoord_flip() is often used with bar plots to make them sideways. This can also be done by placing the variable to be counted on the y axis.\n\nggplot(\n    filter(bikes, !is.na(weather_type)),\n    aes(x = fct_infreq(weather_type))\n  ) +\n  geom_bar() + \n  coord_flip() + \n  labs(x = \"Weather type\")\n\n\n\n\n\n\n\n\n13.6.3 Circular coordinate system\nUse coord_polar() for a circular coordinate system.\n\nggplot(\n    filter(bikes, !is.na(weather_type)),\n    aes(x = fct_infreq(weather_type),\n        fill = weather_type)\n  ) +\n  geom_bar(width = 1) +\n  coord_polar()\n\n\n\n\n\n\n\nCreate circular bar plots with theta = \"y\".\n\nggplot(\n    filter(bikes, !is.na(weather_type)),\n    aes(x = fct_infreq(weather_type),\n        fill = weather_type)\n  ) +\n  geom_bar() +\n  coord_polar(theta = \"y\")\n\n\n\n\n\n\n\nCreate pie chart with geom_bar(position = \"stack\").\n\nggplot(\n    filter(bikes, !is.na(weather_type)),\n    aes(x = 1, fill = fct_rev(\n      fct_infreq(weather_type)))\n  ) +\n  geom_bar(position = \"stack\") +\n  coord_polar(theta = \"y\") \n\n\n\n\n\n\n\n\n13.6.4 Example: lillipop plot\n\nbikes |&gt; \ngroup_by(season) |&gt;\n  summarize(count = sum(count)) |&gt; \n  ggplot(aes(x = season, y = count)) +\n  geom_point(size = 3) + # points at end\n  geom_linerange( # lines\n    aes(ymin = 0, ymax = count)\n  ) + \n  annotate( # create baseline \n  geom = \"linerange\",\n  xmin = .7, xmax = 4.3, y = 0\n  ) +\n  geom_text( # text labels of seasons\n    aes(label = season, y = 0),\n    size = 4.5,\n    fontface = \"bold\", hjust = 1.15\n  ) +\n  coord_polar(theta = \"y\") + \n  scale_x_discrete( # x-axis is discrete variable\n    expand = c(.5, .5) # expand start and end of x-axis\n    ) +\n  scale_y_continuous(\n    # Set higher max limit so summer does not go in circle\n    # Can see this value on axis ticks\n    limits = c(0, 7.5*10^6)\n    ) + \n  theme_void() + \n  # Make plot margin smaller\n  theme(plot.margin = margin(rep(-100, 4)))\n\n\n\n\n\n\n\n\n13.6.5 Transform a coordinate system\ncoord_trans() is different to scale transformations in that it occurs after statistical transformation and will affect the visual appearance of geoms; there is no guarantee that straight lines will continue to be straight.\nggplot(\n    bikes,\n    aes(x = temp, y = count,\n        group = day_night)\n  ) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  coord_trans(y = \"log10\") + \n  ggtitle(\n    \"Log transform\",\n    \"Linear model lines not straight\")\nggplot(\n    bikes,\n    aes(x = temp, y = count,\n        group = day_night)\n  ) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  scale_y_log10() + \n  ggtitle(\n    \"Log scale\",\n    \"Linear model lines are straight\")",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>RStudio conf 2022 ggplot2 workshop</span>"
    ]
  },
  {
    "objectID": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-labels",
    "href": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-labels",
    "title": "13  RStudio conf 2022 ggplot2 workshop",
    "section": "\n13.7 Labels in plot elements",
    "text": "13.7 Labels in plot elements\nSee Section 13.3 for basic discussion of labels.\nCreate labels with labs() as shown in Section 13.3.\n\ng &lt;- ggplot(\n    bikes,\n    aes(x = temp_feel, y = count,\n        color = season)\n  ) +\n  geom_point(\n    alpha = .5\n  ) +\n  labs(\n    x = \"Feels Like temperature (°F)\",\n    y = \"Reported bike shares\",\n    title = \"TfL bike sharing trends\",\n    subtitle = \"Reported bike rents versus Feels Like temperature in London\",\n    caption = \"Data: TfL\",\n    color = \"Season:\",\n    tag = \"1.\"\n  )\n\ng\n\n\n\n\n\n\n\n\n13.7.1 Labels and theme\nChange other labels and elements of the plot via theme().\n\ng + theme(\n  plot.title = element_text(face = \"bold\"),\n  plot.title.position = \"plot\",\n  axis.text = element_text(\n    color = \"#28a87d\",\n    face = \"italic\",\n    colour = NULL,\n    size = NULL,\n    hjust = 1,\n    vjust = 0,\n    angle = 45,\n    lineheight = 1.3, ## no effect here\n    margin = margin(10, 0, 20, 0) ## no effect here\n  ),\n  plot.tag = element_text(\n    margin = margin(0, 12, -8, 0) ## trbl\n  )\n)\n\n\n\n\n\n\n\n\n13.7.2 Labels and scales\nDifferent ways to change the labels of the scales using the scales package or just the labels argument.\n\ng + \n  scale_x_continuous(\n  labels = (\\(x) paste0(x, \"°F\")),\n  name = \"Feels Like Temperature\"\n  ) + \n  scale_y_continuous(\n    breaks = 0:4*15000,\n    labels = scales::label_number(\n      scale = .001,\n      suffix = \"k\"),\n    name = \"Reported bike shares in thousands\"\n    ) + \n  scale_color_discrete(\n    name = NULL,\n    labels = stringr::str_to_title\n  )\n\n\n\n\n\n\n\n\n13.7.3 Labels and markdown\nStyling labels with ggtext and element_markdown().\n\ng +\n  ggtitle(\"&lt;b style='font-size:25pt'&gt;TfL&lt;/b&gt; bike sharing trends by &lt;i style='color:#28a87d;'&gt;season&lt;/i&gt;\") +\n  theme(\n    plot.title = ggtext::element_markdown()\n  )\n\n\n\n\n\n\n\n\n13.7.4 Labels and facets\n\ncodes &lt;- c(\n  `TRUE` = \"Workday\",\n  `FALSE` = \"Weekend or Holiday\"\n)\n\ng +\n  facet_grid(\n    day_night ~ is_workday,\n    scales = \"free\",\n    space = \"free\",\n    labeller = labeller(\n      day_night = stringr::str_to_title,\n      is_workday = codes\n    )\n  )\n\n\n\n\n\n\n\n\n13.7.5 Handling long labels\nstringr\n\nggplot(\n    bikes,\n    aes(x = stringr::str_wrap(weather_type, 6),\n        y = count)\n  ) +\n  geom_boxplot()\n\n\n\n\n\n\n\nggtext\n\ng +\n  ggtitle(\"TfL bike sharing trends in 2015 and 2016 by season for day and night periods\") +\n  theme(\n    plot.title = ggtext::element_textbox_simple(\n      margin = margin(t = 12, b = 12),\n      padding = margin(rep(12, 4)),\n      fill = \"grey90\",\n      box.color = \"grey40\",\n      r = unit(9, \"pt\"),\n      halign = .5,\n      face = \"bold\",\n      lineheight = .9\n    ),\n    plot.title.position = \"plot\"\n  )",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>RStudio conf 2022 ggplot2 workshop</span>"
    ]
  },
  {
    "objectID": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-annotations",
    "href": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-annotations",
    "title": "13  RStudio conf 2022 ggplot2 workshop",
    "section": "\n13.8 Annotations",
    "text": "13.8 Annotations\n\n13.8.1 Annotation basics\nAdd annotations with annotate() and selecting the geom used for the annotation.\n\nggplot(bikes, aes(humidity, temp)) +\n  geom_point(size = 2, color = \"grey\") +\n  annotate(\n    geom = \"text\",\n    x = 90,\n    y = 27.5,\n    label = \"Some\\nadditional\\ntext\",\n    size = 6,\n    color = \"firebrick\",\n    fontface = \"bold\",\n    lineheight = .9\n  )\n\n\n\n\n\n\n\nTo add multiple text annotations use vectors for aspects you want to be different.\n\nggplot(bikes, aes(humidity, temp)) +\n  geom_point(size = 2, color = \"grey\") +\n  annotate(\n    geom = \"text\",\n    x = c(90, 50),\n    y = c(27.5, 3.5),\n    label = c(\"Text A\", \"Text B\"),\n    color = c(\"black\", \"firebrick\"),\n    size = c(5, 10),\n    fontface = c(\"plain\", \"bold\")\n  )\n\n\n\n\n\n\n\nAdd boxes\n\nggplot(bikes, aes(humidity, temp)) +\n  annotate(\n    geom = \"rect\",\n    xmin = -Inf,\n    xmax = 60,\n    ymin = 20,\n    ymax = Inf,\n    fill = \"#663399\"\n  ) +\n  geom_point(size = 2, color = \"grey\")\n\n\n\n\n\n\n\n\n13.8.2 Highlighting aspects with annotations\nAdding a straight line or a curved line between annotated text and aspects of the plot you want to highlight. See geom_segment() and geom_curve() for arguments to use in annotate(), particularly in working with curvature.\nggplot(bikes, aes(humidity, temp)) +\n  geom_point(size = 2, color = \"grey\") +\n  annotate(\n    geom = \"text\",\n    x = 90,\n    y = 27.5,\n    label = \"Some\\nadditional\\ntext\",\n    size = 6,\n    lineheight = .9\n  ) +\n  annotate(\n    geom = \"segment\",\n    x = 90, xend = 82,\n    y = 25, yend = 18.5\n  )\nggplot(bikes, aes(humidity, temp)) +\n  geom_point(size = 2, color = \"grey\") +\n  annotate(\n    geom = \"text\",\n    x = 90,\n    y = 27.5,\n    label = \"Some\\nadditional\\ntext\",\n    size = 6,\n    lineheight = .9\n  ) +\n  annotate(\n    geom = \"curve\",\n    x = 90, xend = 82,\n    y = 25, yend = 18.5\n  )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWorking with curved line annotations and adding arrows.\n\nggplot(bikes, aes(humidity, temp)) +\n  geom_point(size = 2, color = \"grey\") +\n  annotate(\n    geom = \"text\",\n    x = 90,\n    y = 27.5,\n    label = \"Some\\nadditional\\ntext\",\n    size = 6,\n    lineheight = .9\n  ) +\n  annotate(\n    geom = \"curve\",\n    x = 94, xend = 82,\n    y = 26, yend = 18.5,\n    curvature = -.8,\n    angle = 140,\n    arrow = arrow(\n      length = unit(10, \"pt\"),\n      type = \"closed\"\n    )\n  )\n\n\n\n\n\n\n\n\n13.8.3 Annotations with geoms\nYou can highlight specific points on a plot by giving them different aesthetics, for instance, highlighting hot periods by using filtered data for highlighted points in a second geom_point() function.\n\nggplot(\n    filter(bikes, temp &gt;= 27),\n    aes(x = humidity, y = temp)\n  ) +\n  geom_point(\n    data = bikes,\n    color = \"grey65\", alpha = .3\n  ) +\n  geom_point(size = 2.5)\n\n\n\n\n\n\n\n\n13.8.4 Text annotations\nYou can use geom_text() and geom_label() to label points, but ggrepel helps to make these annotations clearer.\n\nggplot(\n    filter(bikes, temp &gt;= 27),\n    aes(x = humidity, y = temp)\n  ) +\n  geom_point(\n    data = bikes,\n    color = \"grey65\", alpha = .3\n  ) +\n  geom_point(size = 2.5) +\n  ggrepel::geom_text_repel(\n    aes(label = season)\n  )\n\n\n\n\n\n\n\nHighlight an outlier by changing color of the point and the text annotation. Here, a color aspect is added by creating a TRUE/FALSE statement within aes(). Because this is done in the global ggplot() encoding, it is used by the outlier points and the text annotation. The rest of the points use the local encoding provided by the first geom_point().\n\nggplot(\n    filter(bikes, temp &gt;= 27),\n    aes(x = humidity, y = temp,\n        # Create TRUE/FALSE for color\n        color = season == \"summer\")\n  ) +\n  geom_point(\n    data = bikes,\n    color = \"grey65\", alpha = .3\n  ) +\n  geom_point(size = 2.5) +\n  ggrepel::geom_text_repel(\n    aes(label = str_to_title(season))\n  ) +\n  scale_color_manual(\n    values = c(\"firebrick\", \"black\"),\n    guide = \"none\" # no legend\n  )\n\n\n\n\n\n\n\nWith ggrepel you can force text annotations into a certain area of the plot with xlim and ylim. You can also style the line segments.\n\nggplot(\n    filter(bikes, temp &gt;= 27),\n    aes(x = humidity, y = temp,\n        color = season == \"summer\")\n  ) +\n  geom_point(\n    data = bikes,\n    color = \"grey65\", alpha = .3\n  ) +\n  geom_point(size = 2.5) +\n  ggrepel::geom_text_repel(\n    aes(label = str_to_title(season)),\n    ## force to the left of plot\n    xlim = c(NA, 35),\n    ## style segment\n    segment.curvature = .01,\n    arrow = arrow(length = unit(.02, \"npc\"), type = \"closed\")\n  ) +\n  scale_color_manual(\n    values = c(\"firebrick\", \"black\"),\n    guide = \"none\"\n  ) +\n  xlim(25, NA) # Expand x min to give space for annotations\n\n\n\n\n\n\n\n\n13.8.5 Annotations with ggforce\n\nUse of ggforce to highlight aspects of a plot.\ngeom_mark_rect() draws a rectangle around a set of points. The geom provides many arguments that can be used to alter the look of the rectangles and labels for the rectangles.\n\nggplot(\n    filter(bikes, temp &gt; 20 & season != \"summer\"),\n    aes(x = humidity, y = temp,\n        color = season)\n  ) +\n  geom_point(\n    data = bikes,\n    color = \"grey65\", alpha = .3\n  ) +\n  geom_point() +\n  ggforce::geom_mark_rect(\n    aes(label = str_to_title(season)),\n    label.fill = \"transparent\"\n  ) +\n  scale_color_brewer(\n    palette = \"Dark2\",\n    guide = \"none\"\n  ) + \n  ylim(NA, 35) # Give room above for annotations\n\n\n\n\n\n\n\ngeom_mark_hull() creates a hull around the points. Notice the use of description in aes() to provide addition information to the label.\n\nggplot(\n    bikes,\n    aes(x = humidity, y = temp,\n        color = season == \"summer\")\n  ) +\n  geom_point(alpha = .4) +\n  ggforce::geom_mark_hull(\n    aes(label = str_to_title(season),\n        filter = season == \"summer\",\n        description = \"June to August\"),\n    label.fill = \"transparent\",\n    expand = unit(10, \"pt\")\n  ) +\n  scale_color_manual(\n    values = c(\"grey65\", \"firebrick\"),\n    guide = \"none\"\n  )\n\n\n\n\n\n\n\n\n13.8.6 Annotations example: Palmer penguins\nSee also Cédric’s The Evolution of a ggplot for another example of building a similar plot.\n\n# Summary data for annotations\npenguins_labs &lt;- penguins |&gt; \n  group_by(species) |&gt; \n  summarize(across(starts_with(\"bill\"), ~ mean(.x, na.rm = TRUE))) |&gt; \n  mutate(\n    species_lab = case_when(\n      species == \"Adelie\" ~ \"&lt;b style='font-size:15pt;'&gt;*P. adéliae*&lt;/b&gt;&lt;br&gt;(Adélie penguin)\",\n      species == \"Chinstrap\" ~ \"&lt;b style='font-size:15pt;'&gt;*P. antarctica*&lt;/b&gt;&lt;br&gt;(Chinstrap penguin)\",\n      species == \"Gentoo\" ~ \"&lt;b style='font-size:15pt;'&gt;*P. papua*&lt;/b&gt;&lt;br&gt;(Gentoo penguin)\"\n    )\n  )\n\nggplot(\n  penguins,\n  aes(x = bill_length_mm, y = bill_depth_mm,\n      color = species, size = body_mass_g)\n  ) + \n  geom_point(alpha = 0.2, stroke = 0.3) + \n  # Add solid outline to points\n  geom_point(shape = 1, stroke = 0.3) + \n  # Color scale and legend title\n  scale_color_manual(\n    guide = \"none\",\n    values = c(\"#FF8C00\", \"#A034F0\", \"#159090\")\n  ) + \n  # Style size legend\n  scale_size(\n    name = \"Body mass:\",\n    breaks = 3:6 * 1000,\n    labels = (\\(x) paste0(x / 1000, \"kg\")),\n    range = c(0.5, 5)\n  ) + \n  geom_richtext(\n    data = penguins_labs,\n    aes(label = species_lab,\n        color = species,\n        color = after_scale(colorspace::darken(color, .4))),\n    size = 3, lineheight = 0.8,\n    fill = \"#ffffffab\", ## hex-alpha code\n    show.legend = FALSE\n  ) + \n  # Adjust axes\n  scale_x_continuous(\n   limits = c(30, 60),\n   breaks = 6:12*5,\n   expand = c(0, 0)\n  ) + \n  scale_y_continuous(\n    limits = c(12.5, 22.5),\n    breaks = seq(12.5, 22.5, by = 2.5),\n    expand = c(0, 0)\n  ) + \n  coord_cartesian(\n    expand = FALSE,\n    clip = \"off\",\n  ) + \n  labs(\n    x = \"Bill length *(mm)*\",\n    y = \"Bill depth *(mm)*\",\n    title = \"Bill dimensions of brush-tailed penguins *Pygoscelis spec.*\",\n    caption = \"Horst AM, Hill AP, Gorman KB (2020). palmerpenguins R package version 0.1.0\"\n    ) + \n  theme_minimal(base_size = 10) + \n  theme(\n    plot.title.position = \"plot\",\n    plot.caption.position = \"plot\",\n    panel.grid.minor = element_blank(),\n    plot.title = element_markdown(\n      face = \"bold\", size = 16, margin = margin(12, 0, 12, 0)\n    ),\n    plot.caption = element_markdown(\n      size = 7, color = \"grey50\", margin = margin(12, 0, 6, 0)\n    ),\n    axis.title.x = element_markdown(margin = margin(t = 8)),\n    axis.title.y = element_markdown(margin = margin(r = 8)),\n    legend.text = element_text(color = \"grey50\"),\n    plot.margin = margin(0, 14, 0, 12),\n    plot.background = element_rect(fill = NA, color = \"grey50\", linewidth = 1)\n)",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>RStudio conf 2022 ggplot2 workshop</span>"
    ]
  },
  {
    "objectID": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-images",
    "href": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-images",
    "title": "13  RStudio conf 2022 ggplot2 workshop",
    "section": "\n13.9 Adding Images",
    "text": "13.9 Adding Images\nLoad the image\n\nurl &lt;- \"https://d33wubrfki0l68.cloudfront.net/dbb07b06a7b3fe056db386fef0b158cc2fd33cb9/8b491/assets/img/2022conf/logo-rstudio-conf.png\"\nimg &lt;- magick::image_read(url)\nimg &lt;- magick::image_negate(img)\n\nAdd background image to a plot using grid::rasterGrob().\n\nggplot(bikes, aes(date, temp_feel)) +\n  annotation_custom(\n    grid::rasterGrob(\n      image = img\n    )\n  ) +\n  geom_point(color = \"#71a5d4\")\n\n\n\n\n\n\n\nAdjust the position of the image using ratios from the plot.\n\nggplot(bikes, aes(date, temp_feel)) +\n  annotation_custom(\n    grid::rasterGrob(\n      image = img,\n      x = .5,\n      y = .9,\n      width = .9\n    )\n  ) +\n  geom_point(color = \"#71a5d4\") +\n  ylim(NA, 37)\n\n\n\n\n\n\n\nPlace image outside of the plot areas using y &gt; 1 and adding to plot.margin.\n\nggplot(bikes, aes(date, temp_feel)) +\n  annotation_custom(\n    grid::rasterGrob(\n      image = img,\n      x = .47,\n      y = 1.15,\n      width = .9\n    )\n  ) +\n  geom_point(color = \"#71a5d4\") +\n  coord_cartesian(clip = \"off\") +\n  theme(\n    plot.margin = margin(90, 10, 10, 10)\n  )",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>RStudio conf 2022 ggplot2 workshop</span>"
    ]
  },
  {
    "objectID": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-color",
    "href": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-color",
    "title": "13  RStudio conf 2022 ggplot2 workshop",
    "section": "\n13.10 Color",
    "text": "13.10 Color\n\n13.10.1 Predefined color palettes\nggplot(\n    bikes, \n    aes(x = day_night, y = count, \n        fill = season)\n  ) +\n  geom_boxplot() +\n  scale_fill_viridis_d(\n    option = \"plasma\",\n    begin = 0.3\n  ) + \n  ggtitle(\"Viridis\")\nggplot(\n    bikes, \n    aes(x = day_night, y = count, \n        fill = season)\n  ) +\n  geom_boxplot() +\n  scale_fill_brewer(\n    palette = \"Set1\",\n    direction = -1\n  ) + \n  ggtitle(\"Brewer\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n13.10.2 Color palette packages\n\nrcartocolor\nscico\nggsci\nggthemes\nnord\nMetBrewer\n\n13.10.3 Customizing existing palettes\nChoose specific colors from a discrete color palette.\n\ncarto_custom &lt;- \n  rcartocolor::carto_pal(\n    name = \"Vivid\", n = 6\n  )[c(1, 3:5)]\n\nggplot(\n    bikes, \n    aes(x = day_night, y = count, \n        fill = season)\n  ) +\n  geom_boxplot() +\n  scale_fill_manual(\n    values = carto_custom\n  )\n\n\n\n\n\n\n\nLighten or darken the color palette with colorspace.\nThis can be done by lightening the palette and placing it in scale_fill_manual().\n\ncarto_light &lt;- colorspace::lighten(carto_custom, 0.8)\n\nggplot(\n    bikes, \n    aes(x = day_night, y = count, \n        fill = season)\n  ) +\n  geom_boxplot() +\n  scale_fill_manual(\n    values = carto_light\n  )\n\n\n\n\n\n\n\nOr you can do the lightening within aes() using stage().\n\nggplot(\n    bikes, \n    aes(x = day_night, y = count)\n  ) +\n  geom_boxplot(\n    aes(\n      fill = stage(\n        season,\n        after_scale = colorspace::lighten(fill, 0.8)\n      )\n    )\n  ) +\n  scale_fill_manual(\n    values = carto_custom\n  )\n\n\n\n\n\n\n\nThis latter approach is a good way to apply a color palette to two different aspects of a geom such as color and fill, though you do not need to use stage() in this case.\n\nggplot(\n    bikes, \n    aes(x = day_night, y = count)\n  ) +\n  geom_boxplot(\n    aes(color = season,\n        fill = after_scale(\n          colorspace::lighten(color, 0.8))\n        )\n  ) +\n  scale_color_manual(\n    values = carto_custom\n  )\n\n\n\n\n\n\n\nThe approach also makes it possible to both lighten and darken palettes for different geoms. For instance, adding points to a boxplot with a darker palette.\n\nggplot(\n    bikes, \n    aes(x = day_night, y = count)\n  ) +\n  geom_boxplot(\n    aes(color = season,\n        fill = after_scale(\n          colorspace::lighten(color, 0.8)\n        ))\n  ) +\n  geom_jitter(\n    aes(color = season,\n        color = after_scale(\n          colorspace::darken(color, 0.3))\n        ), \n    position = position_jitterdodge(\n      dodge.width = 0.75, \n      jitter.width = 0.2),\n    alpha = 0.4\n  ) +\n  scale_color_manual(\n    values = carto_custom\n  )\n\n\n\n\n\n\n\n\n13.10.4 Gradient palettes\nSequential palettes: scale_color_gradient()\n\n\nggplot(\n    bikes, \n    aes(x = temp_feel, y = count, \n        color = temp_feel)\n  ) +\n  geom_point() +\n  scale_color_gradient(\n    low = \"#28A87D\",\n    high = \"#FFD166\"\n  )\n\n\n\n\n\n\n\nDiverging palettes: scale_color_gradient2()\n\n\nggplot(\n    bikes, \n    aes(x = temp_feel, y = count, \n        color = temp_feel)\n  ) +\n  geom_point() +\n  scale_color_gradient2(\n    low = \"#663399\",\n    high = \"#993334\",\n    mid = \"grey92\",\n    midpoint = 10,\n    limits = c(-10, 30)   \n  )\n\n\n\n\n\n\n\nMulti-colored sequential palettes: scale_color_gradientn()\n\n\nggplot(\n    bikes, \n    aes(x = temp_feel, y = count, \n        color = temp_feel)\n  ) +\n  geom_point() +\n  scale_color_gradientn(\n    colors = carto_custom,\n    values = c(0, .2, .8, 1)\n  )\n\n\n\n\n\n\n\n\n13.10.5 Build your own palettes: discrete palette\n\nCreate a function that accesses a named vector of colors as hex values.\n\n\ndubois_colors &lt;- function(...) {\n  dubois_cols &lt;- c(\n    `black`    = \"#000000\",\n    `purple`   = \"#582f6c\",\n    `violet`   = \"#94679C\",\n    `pink`     = \"#ef849f\",\n    `softred`  = \"#f4b7a7\",\n    `iceblue`  = \"#bccbf3\",\n    `palegrey` = \"#e4e4e4\"\n  )\n\n  cols &lt;- c(...)\n\n  if (is.null(cols))\n    return (dubois_cols)\n\n  dubois_cols[cols]\n}\n\ndubois_colors(\"black\", \"pink\", \"softred\", \"iceblue\")\n#&gt;     black      pink   softred   iceblue \n#&gt; \"#000000\" \"#ef849f\" \"#f4b7a7\" \"#bccbf3\"\n\n\nCreate a function to return n color values from discrete palette.\n\n\ndubois_pal_d &lt;- function(palette = \"default\", reverse = FALSE) {\n  function(n) {\n    if(n &gt; 5) stop('Palettes only contains 5 colors')\n\n    if (palette == \"default\") { pal &lt;- dubois_colors(\n      \"black\", \"violet\", \"softred\", \"iceblue\", \"palegrey\")[1:n] }\n    if (palette == \"dark\") { pal &lt;- dubois_colors(1:5)[1:n] }\n    if (palette == \"light\") { pal &lt;- dubois_colors(3:7)[1:n] }\n    \n    pal &lt;- unname(pal)\n\n    if (reverse) rev(pal) else pal\n  }\n}\n\ndubois_pal_d()(3)\n#&gt; [1] \"#000000\" \"#94679C\" \"#f4b7a7\"\n\n\nCreate scale discrete color and fill functions to work with ggplot.\n\n\nscale_color_dubois_d &lt;- function(palette = \"default\", reverse = FALSE, ...) {\n  if (!palette %in% c(\"default\", \"dark\", \"light\"))\n    stop('Palette should be \"default\", \"dark\" or \"light\".')\n\n  pal &lt;- dubois_pal_d(palette = palette, reverse = reverse)\n\n  ggplot2::discrete_scale(\"colour\", paste0(\"dubois_\", palette), palette = pal, ...)\n}\n\nscale_fill_dubois_d &lt;- function(palette = \"default\", reverse = FALSE, ...) {\n  if (!palette %in% c(\"default\", \"dark\", \"light\"))\n    stop('Palette should be \"default\", \"dark\" or \"light\".')\n\n  pal &lt;- dubois_pal_d(palette = palette, reverse = reverse)\n\n  ggplot2::discrete_scale(\"fill\", paste0(\"dubois_\", palette), palette = pal, ...)\n}\n\n\nUse discrete palette scale function\n\n\nggplot(\n    bikes, \n    aes(x = day_night, y = count, \n        fill = season)\n  ) +\n  geom_boxplot() +\n  scale_fill_dubois_d(palette = \"light\")\n\n\n\n\n\n\n\n\n13.10.6 Build your own palettes: continuous palette\nUse named color palette from above\n\nCreate function that builds light and dark palettes and uses colorRampPalette() to create continuous palette.\n\n\ndubois_pal_c &lt;- function(palette = \"dark\", reverse = FALSE, ...) {\n  dubois_palettes &lt;- list(\n    `dark`    = dubois_colors(\"black\", \"purple\", \"violet\", \"pink\"),\n    `light`   = dubois_colors(\"purple\", \"violet\", \"pink\", \"palered\")\n  )\n\n  pal &lt;- dubois_palettes[[palette]]\n  pal &lt;- unname(pal)\n\n  if (reverse) pal &lt;- rev(pal)\n\n  grDevices::colorRampPalette(pal, ...)\n}\n\ndubois_pal_c(palette = \"light\", reverse = TRUE)(3)\n#&gt; [1] \"#FFFFFF\" \"#C1759D\" \"#582F6C\"\n\n\nCreate scale continuous color and fill functions to work with ggplot.\n\n\nscale_fill_dubois_c &lt;- function(palette = \"dark\", reverse = FALSE, ...) {\n  if (!palette %in% c(\"dark\", \"light\")) stop('Palette should be \"dark\" or \"light\".')\n\n  pal &lt;- dubois_pal_c(palette = palette, reverse = reverse)\n\n  ggplot2::scale_fill_gradientn(colours = pal(256), ...)\n}\n\nscale_color_dubois_c &lt;- function(palette = \"dark\", reverse = FALSE, ...) {\n  if (!palette %in% c(\"dark\", \"light\")) stop('Palette should be \"dark\" or \"light\".')\n\n  pal &lt;- dubois_pal_c(palette = palette, reverse = reverse)\n\n  ggplot2::scale_color_gradientn(colours = pal(256), ...)\n}\n\n\nUse continuous palette scale function\n\n\nggplot(\n    bikes, \n    aes(x = temp_feel, y = count, \n        color = temp_feel)\n  ) +\n  geom_point() +\n  scale_color_dubois_c(\n    palette = \"light\",\n    reverse = TRUE\n  )",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>RStudio conf 2022 ggplot2 workshop</span>"
    ]
  },
  {
    "objectID": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-legend",
    "href": "02-ggplot2-rstudioconf-2022.html#sec-rs22-gd-legend",
    "title": "13  RStudio conf 2022 ggplot2 workshop",
    "section": "\n13.11 Legend placement and styling",
    "text": "13.11 Legend placement and styling\nGuides are the collective name for axes and legends. Legend position is set within theme(), while many aspects of the styling of the legend can be set within guide argument of scale_*() functions. See guides() function for details.\nRemoving a legend from a plot:\n\ngeom_*(show.legend = FALSE)\nscale_*(guide = \"none\")\n\nguides(color = \"none\"): setting aesthetic to “none”\ntheme(legend.position = \"none\")\n\nThere are three types of quantitative guides:\n\nguide_bins()\nguide_colourbar()\nguide_coloursteps()\n\n\n13.11.1 Legend position\n\nggplot(\n    bikes,\n    aes(x = temp_feel, y = count,\n        color = humidity)\n  ) +\n  geom_point() +\n  scale_color_viridis_b(\n    # Styling of legend with guide\n    guide = guide_colorsteps(\n      title.position = \"top\",\n      title.hjust = 0.5, # center title\n      show.limits = TRUE, # labels for low and high values\n      frame.colour = \"black\",\n      frame.linewidth = 1,\n      barwidth = unit(8, \"lines\") # width of whole colorbar\n    )\n  ) +\n  theme(\n    # Legend position and direction\n    legend.position = c(.25, .85),\n    legend.direction = \"horizontal\"\n  )\n\n\n\n\n\n\n\nCreate a colorbar at the top of the plot that spans most of the plot.\n\nggplot(\n    bikes,\n    aes(x = temp_feel, y = count,\n        color = humidity)\n  ) +\n  geom_point() +\n  scale_color_viridis_c(\n    breaks = 3:10*10,\n    limits = c(30, 100),\n    name = \"Humidity\",\n    guide = guide_colorbar(\n      title.position = \"top\",\n      title.hjust = 0,\n      ticks = FALSE,\n      # set width of colorbar\n      barwidth = unit(20, \"lines\"),\n      barheight = unit(0.6, \"lines\")\n    )\n  ) +\n  theme(\n    legend.position = \"top\"\n  )\n\n\n\n\n\n\n\n\n13.11.2 Legend and color example: color shading\nCreate a legend that uses color shading, taking a palette and using lighter and darker shades to show similarity between groups.\n\n# Create palette\npal &lt;- c(\"#3c89d9\", \"#1ec99b\", \"#F7B01B\", \"#a26e7c\")\nshades &lt;- c(colorspace::lighten(pal, .3),\n            colorspace::darken(pal, .3))\n\nbikes |&gt; \n  arrange(day_night, date) |&gt; \n  # Create factor column with season and day/night data\n  mutate(\n    season_day = paste(\n      str_to_title(season), day_night\n    ),\n    season_day = forcats::fct_inorder(season_day)\n  ) |&gt; \n  ggplot(\n    aes(x = season, y = count,\n        fill = season_day)\n  ) +\n  stat_summary(\n    geom = \"col\", fun = sum,\n    position = position_dodge2(\n      width = .2, padding = .1\n    )\n  ) + \n  scale_fill_manual(\n    values = shades, name = NULL # No name for fill legend\n  ) +\n  scale_x_discrete(\n    labels = str_to_title # Capitalize labels\n  ) +\n  scale_y_continuous(\n    labels = scales::label_comma(),\n    expand = c(0, 0),\n    limits = c(NA, 4500000)\n  ) +\n  labs(x = NULL, y = \"Reported bike shares\") + \n  # Order of legend by row to align seasons\n  guides(fill = guide_legend(byrow = TRUE)) + \n  theme(\n    panel.grid.major.x = element_blank(),\n    axis.title = element_blank()\n  )",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>RStudio conf 2022 ggplot2 workshop</span>"
    ]
  },
  {
    "objectID": "02-geoms.html",
    "href": "02-geoms.html",
    "title": "14  Geoms",
    "section": "",
    "text": "14.1 Resources\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(palmerpenguins)\n\n# Data\npenguins &lt;- penguins |&gt; \n  filter(!is.na(flipper_length_mm),\n         !is.na(sex)) |&gt; \n  # Add factor data that has more levels\n  mutate(species_sex = as.factor(\n    paste(species, sex)))",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Geoms</span>"
    ]
  },
  {
    "objectID": "02-geoms.html#sec-geom-resources",
    "href": "02-geoms.html#sec-geom-resources",
    "title": "14  Geoms",
    "section": "",
    "text": "Layers documentation\n\ngeoms\nstats\nposition\n\n\nWickham, ggplot2 Book: Layers\nggplot2 Cheatsheet: Geoms\nR for Data Science: Communication, Data visualization\nR for Data Science: Communication, Layers",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Geoms</span>"
    ]
  },
  {
    "objectID": "02-geoms.html#sec-geom-intro",
    "href": "02-geoms.html#sec-geom-intro",
    "title": "14  Geoms",
    "section": "\n14.2 Introduction",
    "text": "14.2 Introduction\nThe geometric layers that make up the data aspects of a plot are typically added through a geom that may be altered by position and stat, or statistical transformation if necessary. Each geom necessitates certain aesthetics, particularly positional aesthetics. Other aesthetics can be added to map variables to the plot or to alter the visual representation of the geoms.\n\n\ngeom: Geometric object drawn on a plot to represent data.\n\nstat: The statistical transformations applied to the data.\n\nposition: Adjustments to position of geoms to resolve overlapping.\n\nThere is usually a one-to-one relationship between geoms and stats: geoms are created through specific statistical transformations. The relationship between geom_bar() and stat_count() as discussed in Section 14.3.1 is a particularly simple and clear example. Geoms, stats, and positions all have their functional forms (geom_*(), stat_*(), and position_*()) as well as their form as a string without the functional prefix (geom = \"point\", stat = \"identity\", position = \"stack\"). The relationship between these three aspects of a geometric layer is discussed in some length in Section 14.3. Otherwise the relationship between geoms and stats are noted throughout. An overview of the possible position adjustments is in Section 14.9\nThe documentation for each geom provides the aesthetics that can be used with it. See Chapter 16 for an overview of aesthetics.",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Geoms</span>"
    ]
  },
  {
    "objectID": "02-geoms.html#sec-geom-bar",
    "href": "02-geoms.html#sec-geom-bar",
    "title": "14  Geoms",
    "section": "\n14.3 Bar plots",
    "text": "14.3 Bar plots\n\n14.3.1 Geoms and stats\ngeom_bar() is a good place to start with geoms because it is easy to show the relationship between geoms, stats, and position.\ngeom_bar()\nBy default geom_bar() performs a statistical transformation by counting the number of observations in the variable provided in the single positional aesthetic: x for upright bar plot, y for horizontal bar plot. Therefore, you can create a bar plot with either geom_bar() or stat_count(geom = \"bar\"):\npenguins |&gt; \n  ggplot(aes(x = species)) + \n  geom_bar()\npenguins |&gt; \n  ggplot(aes(x = species)) + \n  stat_count(geom = \"bar\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstat_identity()\nInstead of using the default count stat, you can use stat_identity() which gets the height of the bars directly from the data. stat_identity() requires both x and y positional aesthetics because it needs to know which variable to use for the height of the bar.\npenguins |&gt; \n  count(species) |&gt; \n  ggplot(aes(x = species,\n             y = n)) + \n  geom_bar(stat = \"identity\")\npenguins |&gt; \n  count(species) |&gt; \n  ggplot(aes(x = species,\n             y = n)) + \n  stat_identity(geom = \"bar\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_col()\ngeom_col() provides a shortcut for creating a bar plot using stat_identity(). The height of the bar is scaled to the y aesthetic, which does not need to be a count.\n\npenguins |&gt; \n  count(species) |&gt; \n  ggplot(aes(x = species, y = n)) + \n  geom_col()\n\n\n\n\n\n\n\n\n14.3.2 Aesthetics\nAdd color to the geom with either color or fill aesthetics. As with other polygon geoms, fill provides the color for the area of the geom and color affects the outline of the polygon.\n# Fill\npenguins |&gt; \n  ggplot(aes(x = species)) + \n  geom_bar(aes(fill = species))\n# Color\npenguins |&gt; \n  ggplot(aes(x = species)) + \n  geom_bar(aes(color = species))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n14.3.3 Position\nEach geom has a position argument that takes either \"identity\", \"stack\", \"dodge\", \"dodge2\", or \"fill\", or, alternatively, the corresponding position_*() functions that allow more freedom in tweaking aspects of the position. See Section 14.9 for an overview.\nThe default position for geom_bar() is position_stack(). This can be seen by mapping color or fill to a non-positional variable. With position_stack() each group is stacked on top of each other.\n\npenguins |&gt; \n  ggplot(aes(x = species, fill = sex)) + \n  geom_bar(color = \"black\")\n\n\n\n\n\n\n\nposition_identity() is the default for most geoms, but it does not work well with bar plots. Compare the default position_stack() to position_identity() in which each group starts from 0. Note the difference in the limit of the y-axis.\n# Default stack position\npenguins |&gt; \n  ggplot(aes(x = island, \n             color = species)) + \n  geom_bar(fill = NA)\n# Position identity\npenguins |&gt; \n  ggplot(aes(x = island, \n             color = species)) + \n  geom_bar(fill = NA,\n           position = \"identity\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA more useful positional adjustment with bar plots is to \"dodge\" the groups, placing them alongside each other instead of stacking them on top of each other. position_dodge2() provides space between the two groups. Note that using the position_*() function makes it possible to better control the behavior such as maintaining the same width for all bars.\npenguins |&gt; \n  ggplot(aes(x = island,\n             fill = species)) + \n  geom_bar(position = \"dodge\")\npenguins |&gt; \n  ggplot(aes(x = island,\n             fill = species)) + \n  geom_bar(position = position_dodge2(\n    preserve = \"single\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFinally, position_fill() standardizes the height of the bars to create a ratio or relative frequency plot.\n\npenguins |&gt; \n  ggplot(aes(x = island, fill = species)) + \n  geom_bar(position = \"fill\")",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Geoms</span>"
    ]
  },
  {
    "objectID": "02-geoms.html#sec-geom-cont-distributions",
    "href": "02-geoms.html#sec-geom-cont-distributions",
    "title": "14  Geoms",
    "section": "\n14.4 Continuous distributions",
    "text": "14.4 Continuous distributions\nLike geom_bar(), geoms that visualize continuous distributions count the frequency of data and therefore only needs one positional aesthetic. However, because the data is continuous it needs to be placed into bins before being counted.\nGeoms\n\ngeom_histogram()\ngeom_freqpoly()\ngeom_density()\nggridges::geom_density_ridges()\ngeom_dotplot()\n\n14.4.1 Histograms and frequency polygons\ngeom_histogram() and geom_freqpoly() use stat_bin() to count frequency. The nature of the visualization is determined by the width of the bins with these geoms. This can be changed with either bins (number of bins) or binwidth (width of bins in scale).\n# binwidth\npenguins |&gt; \n  ggplot(aes(x = body_mass_g)) +\n  geom_histogram(binwidth = 200)\n# bins\npenguins |&gt; \n  ggplot(aes(x = body_mass_g)) +\n  geom_histogram(bins = 50)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_freqpoly() displays the same counts with lines instead of bars.\n# binwidth\npenguins |&gt; \n  ggplot(aes(x = body_mass_g)) +\n  geom_freqpoly(binwidth = 200)\n# bins\npenguins |&gt; \n  ggplot(aes(x = body_mass_g)) +\n  geom_freqpoly(bins = 50)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdd color or fill to group the frequency plots.\n# binwidth\npenguins |&gt; \n  ggplot(aes(x = body_mass_g,\n             fill = species)) +\n  geom_histogram(binwidth = 200)\n# bins\npenguins |&gt; \n  ggplot(aes(x = body_mass_g,\n             color = species)) +\n  geom_freqpoly(binwidth = 200)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n14.4.2 Density estimates\ngeom_density() provides another way to group continuous data, but it does so by smoothing out the frequency plots. The area of each density is standardized to one so that you lose information about the relative size of each group. Note that the y-axis is density not count.\n\npenguins |&gt; \nggplot(aes(x = body_mass_g, color = species, fill = species)) +\n  geom_density(alpha = 0.5) + \n  scale_y_continuous(labels = scales::label_number())\n\n\n\n\n\n\n\nThe ggridges package makes it easy to do what are essentially faceted density plots\n\nlibrary(ggridges)\npenguins |&gt; \n  ggplot(aes(x = body_mass_g, y = species, color = species, fill = species)) +\n  geom_density_ridges(alpha = 0.5, show.legend = FALSE)\n#&gt; Picking joint bandwidth of 153\n\n\n\n\n\n\n\n\n14.4.3 Dot plots\nAnother way to represent a binned continuous data is with a dot plot in which dots representing one observation are stacked. geom_dotplot() has two different methods for binning: \"dotdensity\" and \"histodot\". \"histodot\" uses fixed-width bins, whereas \"dotdensity\", the default, calculates binwidth based on the data.\n\npenguins |&gt; \n  ggplot(aes(x = body_mass_g)) +\n  geom_dotplot(binwidth = 100)\n\n\n\n\n\n\n\nThe labels used on the y-axis are not meaningful with geom_dotplot(). You can either hide the y-axis or manually scale it.\ngeom_dotplot() works differently in stacking groups. It has a stackgroups argument and this goes together with the method to use for binning and whether binpositions should be calculated \"bygroup\" or for \"all\" the data.\nWithout stacking you can see that each group has its own binning position by default.\n\npenguins |&gt; \n  ggplot(aes(x = body_mass_g, fill = species)) +\n  geom_dotplot(binwidth = 100,\n               alpha = 0.7)\n\n\n\n\n\n\n\nThere are two slightly different ways to stack the dots with either method = \"histodot\" or binpositions = \"all\":\n# method = \"histodot\"\npenguins |&gt; \n  ggplot(aes(x = body_mass_g,\n             fill = species)) +\n  geom_dotplot(binwidth = 100,\n               stackgroups = TRUE,\n               method = \"histodot\")\n# binpositions = \"all\"\npenguins |&gt; \n  ggplot(aes(x = body_mass_g,\n             fill = species)) +\n  geom_dotplot(binwidth = 100,\n               stackgroups = TRUE,\n               binpositions = \"all\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMapping an x and y aesthetic makes it possible to create a beeswarm plot with occurrences stacking from the center and bins on the y-axis.\n\npenguins |&gt; \n  ggplot(aes(x = species, y = body_mass_g, fill = species)) +\n  geom_dotplot(binwidth = 100,\n               binaxis = \"y\",\n               stackdir = \"center\",\n               binpositions = \"all\")",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Geoms</span>"
    ]
  },
  {
    "objectID": "02-geoms.html#sec-geom-stat-distributions",
    "href": "02-geoms.html#sec-geom-stat-distributions",
    "title": "14  Geoms",
    "section": "\n14.5 Statistical distributions",
    "text": "14.5 Statistical distributions\nThere are a variety of geoms intended to show the statistical distribution of a variable in the data.\nGeoms\n\ngeom_boxplot()\ngeom_jitter()\ngeom_violin()\ngeom_linerange()\ngeom_pointrange()\nstat_summary()\n\n14.5.1 geom_boxplot()\n\nA box plot displays the distribution of a continuous variable, showing the median, 25th, and 75th percentile, whiskers to farthest non-outlier point, and outliers.\n\npenguins |&gt; \n  ggplot(aes(x = species, y = body_mass_g)) +\n  geom_boxplot()\n\n\n\n\n\n\n\nThe orientation of the plot follows the discrete axis.\n\npenguins |&gt; \n  ggplot(aes(x = body_mass_g, y = species)) +\n  geom_boxplot()\n\n\n\n\n\n\n\nBox plots are automatically dodged when any aesthetic is a factor. By default, geom_boxplot() uses position_dodge2() to add space between the boxes.\n\npenguins |&gt; \n  ggplot(aes(x = species, y = body_mass_g, fill = sex)) +\n  geom_boxplot()\n\n\n\n\n\n\n\ngeom_jitter() is particularly useful with geom_boxplot() to show the actual points. geom_jitter() is a shortcut for geom_point(position = \"jitter\"). Control the width and height of the jitter with the corresponding arguments. geom_jitter() also has a position argument in case you want to make further changes. For instance, with a dodged box plot you need to use position = position_jitterdodge(). Finally, when adding the points with geom_jitter(), the outlier points from geom_boxplot() should be removed with outlier.shape = NA.\n\npenguins |&gt; \n  ggplot(aes(x = species, y = body_mass_g, color = sex)) +\n  geom_boxplot(outlier.shape = NA) + \n  geom_jitter(alpha = 0.8,\n              position = position_jitterdodge())\n\n\n\n\n\n\n\nIt is possible to use a boxplot with a continuous variable by binning the data with one of the helper functions: cut_width(), cut_interval(), or cut_number().\n\npenguins |&gt; \n  ggplot(aes(x = bill_depth_mm, body_mass_g)) + \n  geom_boxplot(aes(group = cut_width(bill_depth_mm, 1)))\n\n\n\n\n\n\n\n\n14.5.2 geom_violin()\n\ngeom_violin() is similar to geom_boxplot() but it adds a density measurement. geom_violin() behaves very similarly to geom_boxplot() but it does not show statistical quantiles.\n\npenguins |&gt; \n  ggplot(aes(x = species, y = body_mass_g)) +\n  geom_violin()\n\n\n\n\n\n\n\nTo show the quantiles use the draw_quantiles argument with a vector of quantiles to draw.\n\npenguins |&gt; \n  ggplot(aes(x = species, y = body_mass_g)) +\n  geom_violin(draw_quantiles = c(0.25, 0.5, 0.75))\n\n\n\n\n\n\n\nLike box plots, geom_violin() automatically dodges when any aesthetic is a factor.\n\npenguins |&gt; \n  ggplot(aes(x = species, y = body_mass_g, fill = sex)) +\n  geom_violin()\n\n\n\n\n\n\n\nAnd geom_violin() works well with geom_jitter().\n\npenguins |&gt; \n  ggplot(aes(x = species, y = body_mass_g)) +\n  geom_violin() + \n  geom_jitter(aes(color = sex),\n    width = 0.25, height = 0,\n    alpha = 0.6)\n\n\n\n\n\n\n\n\n14.5.3 geom_linerange() and geom_pointrange()\n\nAnother way to show statistical aspects of data is with either a line or point range that draws a vertical line from ymin to ymax. There needs to be variables in the data with ymin and ymax data for each group. This is done by grouping the data and then mutating:\n\npenguins_range &lt;- penguins |&gt; \n  group_by(species) |&gt; \n  mutate(lower = min(body_mass_g),\n         upper = max(body_mass_g))\n\ngeom_pointrange() is the same as geom_linerange() but it adds the points along the line.\npenguins_range |&gt; \n  ggplot(aes(x = species,\n             y = body_mass_g)) + \n  geom_linerange(aes(ymin = lower,\n                     ymax = upper))\npenguins_range |&gt; \n  ggplot(aes(x = species,\n             y = body_mass_g)) + \n  geom_pointrange(aes(ymin = lower,\n                      ymax = upper))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn this case, it is probably more useful to put points at specific statistical quantiles by calculating these and using geom_point().\n\npenguins |&gt; \n  group_by(species) |&gt; \n  mutate(lower = min(body_mass_g),\n         upper = max(body_mass_g),\n         med = median(body_mass_g)) |&gt; \n  ggplot(aes(x = species,\n             y = body_mass_g)) + \n  geom_linerange(aes(ymin = lower,\n                     ymax = upper)) + \n  geom_point(aes(x = species, y = med))\n\n\n\n\n\n\n\nOr, you can recreate this plot more easily with stat_summary():\n\npenguins |&gt; \n  ggplot(aes(x = species,\n             y = body_mass_g)) + \n  stat_summary(fun = median, fun.min = min, fun.max = max)\n\n\n\n\n\n\n\nOne useful point to note is that you can, of course, place a numeric value in either ymin or ymax such as beginning the line at 0.\n\npenguins_range |&gt; \n  ggplot(aes(x = species,\n             y = body_mass_g)) + \n  geom_linerange(aes(ymin = 0,\n                     ymax = upper)) + \n  geom_point(aes(y = upper), size = 4)",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Geoms</span>"
    ]
  },
  {
    "objectID": "02-geoms.html#sec-geom-scatter",
    "href": "02-geoms.html#sec-geom-scatter",
    "title": "14  Geoms",
    "section": "\n14.6 Scatter plots",
    "text": "14.6 Scatter plots\nScatter plots are best used to display the relationship between two continuous variables.\nGeoms\n\ngeom_point()\ngeom_rug()\ngeom_jitter()\ngeom_count()\ngeom_bin2d()\ngeom_hex()\ngeom_density_2d()\ngeom_density_2d_filled()\n\n14.6.1 geom_point()\n\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             color = species_sex)) + \n  geom_point()\n\n\n\n\n\n\n\nA complementary geom to go along with geom_point() is geom_rug(), which creates a compact visualizations of observations along the x- and y-axis of a plot. The documentation notes that it is best used with smaller data sets.\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             color = species_sex)) + \n  geom_point() + \n  geom_rug()\n\n\n\n\n\n\n\nThe above plot shows one of the potential issues with geom_rug() in that many observations occur at the same x or y value. You can see that this is particularly true for flipper length where the scale of the variable is much smaller. You can choose where to place geom_rug() and thus which axes to measure with the sides argument that takes a string containing any of \"trbl\", for top, right, bottom, and left.\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             color = species_sex)) + \n  geom_point() + \n  geom_rug(sides = \"l\")\n\n\n\n\n\n\n\n\n14.6.2 Overplotting\nThe easiest way to deal with overplotting, having multiple points drawn in the same or nearly the same place, is to use transparency. The more overplotting there is the lower the transparency can be.\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  geom_point(alpha = 0.5)\n\n\n\n\n\n\n\nThe use of geom_jitter() has already been shown in Section 14.5.1 for spreading out points along a discrete variable, but it can also be helpful if there are multiple points at specific coordinates.\npenguins |&gt; \n  ggplot(aes(x = species_sex,\n             y = body_mass_g)) + \n  geom_point()\npenguins |&gt; \n  ggplot(aes(x = species_sex,\n             y = body_mass_g)) + \n  geom_jitter(width = 0.2, height = 0)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nggplot2 also includes a number of geoms to deal with overplotting. The most specific is geom_count(), which counts the number of observations at each location, then maps the count to point area. geom_count() is a shortcut for geom_point(stat = \"sum\"). This can be used with two continuous variables, but the documentation specifically notes that it is most useful with discrete data.\n# Continuous x continuous\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  geom_count(alpha = 0.8)\n# Discrete x continuous\npenguins |&gt; \n  ggplot(aes(x = species_sex,\n             y = body_mass_g)) + \n  geom_count(alpha = 0.8)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAdding an aesthetic that maps to a factor creates groups for the “sum” statistical transformation. Compare the scales with and without color.\npenguins |&gt; \n  ggplot(aes(x = species,\n             y = body_mass_g)\n         ) + \n  geom_count(alpha = 0.8)\npenguins |&gt; \n  ggplot(aes(x = species,\n             y = body_mass_g,\n             color = sex)) + \n  geom_count(alpha = 0.8)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n14.6.3 Heat maps\nAnother way to deal with overplotting is to create heat maps with either geom_bin2d() or geom_hex(). geom_bin2d() creates rectangular bins; geom_hex() creates hexagonal bins. Like other binning geoms such as geom_histogram(), see Section 14.4.1, the heat map geoms have arguments for number of bins and binwidth. One difference is that binwidth takes a numeric vector of length 2 for vertical and horizontal size of the bins.\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  geom_bin2d()\n\n\n\n\n\n\n\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  geom_hex()\n\n\n\n\n\n\n\nBoth geoms map a continuous color scale to counts within the bin. Thus, using color or fill to map another aesthetic is not really useful here except for showing presence and absence.\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             fill = species)) + \n  geom_hex(alpha = 0.7)\n\n\n\n\n\n\n\n\n14.6.4 Contours\nAnother way to deal with overplotting and to visualize density along two continuous variables is with contour plots that are a 2D version of geom_density(), see Section 14.4.2.\n\n\ngeom_density_2d(): draw contour lines\n\ngeom_density_2d_filled(): draw filled contour bands\n\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  geom_density2d_filled() + \n  geom_density2d() + \n  geom_point(alpha = 0.4)\n\n\n\n\n\n\n\nIf you map an aesthetic to a categorical variable, you will get a set of contours for each group.\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  geom_density2d(aes(color = species))\n\n\n\n\n\n\n\nUsing geom_density2d_filled() with multiple groups does not work well, and so it seems best to use facets. You can change the way that the contour is created across the facets with contour_var choosing one of \"density\", \"ndensity\", or \"count\".\n\n\n\"density\" uses the same scale across the facets.\n\n\"ndensity\" keeps the peak intensity stable across the facets.\n\n\"count\" scales by the number of observations.\n\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  geom_density2d_filled() + \n  facet_wrap(vars(species)) + \n  scale_x_continuous(breaks = c(180, 200, 220))\n\n\n\n\n\n\n\nYou can also use stat_density2d() to use the density2d statistical transformation with a different geom such as raster to create density tiles instead of contours.\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  stat_density2d(\n    geom = \"raster\",\n    aes(fill = after_stat(density)),\n    contour = FALSE) + \n  scale_fill_viridis_c()",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Geoms</span>"
    ]
  },
  {
    "objectID": "02-geoms.html#sec-geom-line",
    "href": "02-geoms.html#sec-geom-line",
    "title": "14  Geoms",
    "section": "\n14.7 Lines",
    "text": "14.7 Lines\n\n14.7.1 Line plots\nggplot2 has three main geoms to draw lines to connect observations:\n\n\ngeom_line(): Connect observations in order of the variable on the x axis.\n\ngeom_path(): Connects the observations in the order in which they appear in the data.\n\ngeom_step(): Creates a stairstep plot, changes in y are at 90 degree angles, highlighting exactly when changes occur.\n\nLine data: mean body mass per year\n\nCodepenguins_line &lt;- penguins |&gt; \n  summarise(body_mass_g = mean(body_mass_g), n = n(),\n            .by = c(species_sex, year))\n\n\nThe group aesthetic determines which cases are connected together. Thus, when you want to draw multiple lines in a plot, you need to use group or another aesthetic such as color or linetype to create the groups, see Section 16.8. The difference between geom_line() and geom_path() can be shown by not including a group aesthetic. When you see a plot like the first one, you know that you are missing a group aesthetic.\npenguins_line |&gt; \n  ggplot(aes(x = year,\n             y = body_mass_g)) + \n  geom_line()\npenguins_line |&gt; \n  ggplot(aes(x = year,\n             y = body_mass_g)) + \n  geom_path()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMapping a color or linetype aesthetic creates the correct grouping.\npenguins_line |&gt; \n  ggplot(aes(\n    x = year,\n    y = body_mass_g,\n    color = species_sex)) +\n  geom_line(linewidth = 1.5)\npenguins_line |&gt; \n  ggplot(aes(\n    x = year,\n    y = body_mass_g,\n    linetype = species_sex)) +\n  geom_line(linewidth = 1.5)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_step() is good for highlighting exactly when changes occur, for instance with financial data where credits and debits are made on specific days, not over a continuous period or at a constant pace. It is thus good for more discrete forms of time data. Think of the difference between accounting data vs stock market prices taken at regular intervals of days or even hours. For the penguin data using geom_step() highlights that the data was collected at three specific point (at least according to the data we have) and does not represent continuous data over time. The changes can be further highlighted by adding points.\n\npenguins_line |&gt; \n  ggplot(aes(x = year,\n             y = body_mass_g,\n             color = species_sex)) +\n  geom_step() + \n  geom_point()\n\n\n\n\n\n\n\n\n14.7.2 Line segments and curves\ngeom_segment() and geom_curve() provide means to draw straight and curved lines with data. These geoms are often used as annotations to a plot and are similar to using “segment” and “curve” geom in annotate(), see Section 15.5.2. They differ in that they need data from a data frame. The geoms use the positional aesthetics of x, y, xend, and yend. geom_curve() has arguments for curvature and angle to specify the curve. See grid::curveGrob() for more control on the details of the curve.\n\n# Data frame for where to begin and end segment and curve\ndf &lt;- data.frame(x1 = 184, x2 = 209, y1 = 4650, y2 = 5500)\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  geom_point() + \n  geom_curve(data = df,\n             aes(x = x1, y = y1,\n                 xend = x2, yend = y2,\n                 color = \"curve\"),\n             curvature = -0.5) +\n  geom_segment(data = df,\n              aes(x = x1, y = y1,\n                  xend = x2, yend = y2,\n                  color = \"segment\")) + \n  labs(color = \"Geom type\")\n\n\n\n\n\n\n\n\n14.7.3 Reference lines\nReference line geoms draw horizontal (geom_hline()), vertical (geom_vline()), or angled (geom_abline()) lines across the plot panel. These geoms are drawn using geom_line() so they support the same aesthetics: alpha, color, linetype, and linewidth. The arguments for the geoms are very simple, and the placement aesthetics are usually provided manually instead of in the data. If you want the lines to vary across facets, you need to construct a data frame and then use them within aesthetics.\n\n\ngeom_vline(): xintercept\n\n\ngeom_hline(): yintercept\n\n\ngeom_abline(): slope and intercept\n\n\nintercept: Where line intercepts x-axis.\n\nslope: Slope of the line\n\n\n\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  geom_vline(xintercept = median(penguins$flipper_length_mm),\n             color = \"orchid\",\n             linewidth = 1.5) + \n  geom_hline(yintercept = median(penguins$body_mass_g),\n             color = \"tomato\",\n             linewidth = 1.5) + \n  geom_abline(intercept = 0, slope = 20,\n              color = \"slateblue\",\n             linewidth = 1.5) + \n  geom_point(alpha = 0.5)",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Geoms</span>"
    ]
  },
  {
    "objectID": "02-geoms.html#sec-geom-ribbon",
    "href": "02-geoms.html#sec-geom-ribbon",
    "title": "14  Geoms",
    "section": "\n14.8 Ribbons and areas",
    "text": "14.8 Ribbons and areas\ngeom_ribbon() is similar to geom_line but it creates a polygon between a ymin and a ymax. geom_area() is a special case of geom_ribbon(), where the ymin is fixed to 0 and y is used instead of ymax.\nA simple example is to subtract from and add to the y variable to create a buffer around geom_line(). You could calculate quantiles to do this, though using geom_smooth() would be better.\n\npenguins_line |&gt; \n  ggplot(aes(x = year,\n             y = body_mass_g,\n             group = species_sex)) +\n  geom_ribbon(aes(ymin = body_mass_g - 50,\n                  ymax = body_mass_g + 50),\n              fill = \"gray80\") + \n  geom_line(aes(color = species_sex))\n\n\n\n\n\n\n\nBy default, geom_area() uses position = \"stack\" with a special stat (stat_align()) to align the values so that they can be stacked when groups overlap on the x-axis. Thus, with the penguin_line data the areas just stack on top of each other, creating a measure of the total weight of penguins with heights of the areas representing the ratio of weight per species_sex. Note the very different scale on the y-axis.\n\npenguins_line |&gt; \n  ggplot(aes(x = year,\n             y = body_mass_g,\n             fill = species_sex)) + \n  geom_area()\n\n\n\n\n\n\n\nUsing position = \"identity\" places one polygon over another.\n\npenguins_line |&gt; \n  ggplot(aes(x = year,\n             y = body_mass_g,\n             fill = species_sex)) + \n  geom_area(position = \"identity\", alpha = 0.2) + \n  geom_line(aes(color = species_sex))",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Geoms</span>"
    ]
  },
  {
    "objectID": "02-geoms.html#sec-geom-position",
    "href": "02-geoms.html#sec-geom-position",
    "title": "14  Geoms",
    "section": "\n14.9 Positions",
    "text": "14.9 Positions\nAll geoms have a position adjustment argument that resolves overlapping geoms. Override the default by using the position argument in the geom_*() or stat_*() function. The argument can either be one of the below functions or a string without the position_ prefix. See in particular Section 14.3.3 for examples.\n\n\nposition_identity(): Do not adjust position\n\nposition_dodge(): Dodge overlapping objects side-to-side; useful with geom_bar().\n\nposition_dodge2(): Dodge overlapping objects side-to-side with a gap; used with geom_boxplot().\n\nposition_jitter(): Add random width and height adjustments to data; default for geom_jitter().\n\nposition_jitterdodge(): Dodge and jitter; primarily useful for jittering points within dodged box plots.\n\nposition_nudge(): Add manual adjustments to x or y; built into geom_text() to move labels away from points.\n\nposition_stack(): Stacks bars on top of each other; default in geom_bar() to stack groups within a discrete variable.\n\nposition_fill(): Stacks bars and standardizes each stack to have constant height to show ratios.",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>Geoms</span>"
    ]
  },
  {
    "objectID": "02-annotations.html",
    "href": "02-annotations.html",
    "title": "15  Annotations",
    "section": "",
    "text": "15.1 Resources",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Annotations</span>"
    ]
  },
  {
    "objectID": "02-annotations.html#sec-ann-resources",
    "href": "02-annotations.html#sec-ann-resources",
    "title": "15  Annotations",
    "section": "",
    "text": "Annotation documentation\nWickham, ggplot2 Book: Annotations\nR for Data Science: Communication, Annotations\n\n\n15.1.1 Packages\n\nggrepel\ngghighlight\nggtext\nggforce\ndirectlabels\ngeomtextpath\n\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(palmerpenguins)\nlibrary(ggrepel)\nlibrary(gghighlight)\nlibrary(ggtext)\nlibrary(ggforce)\nlibrary(geomtextpath)\n\n# Data\npenguins &lt;- penguins |&gt; \n  filter(!is.na(flipper_length_mm),\n         !is.na(sex))\n\n# Subset of data for labeling\nset.seed(42)\npenguins_sub &lt;- penguins |&gt; \n  slice_sample(n = 15)\n\n# Base plot\np &lt;- penguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  geom_point(aes(color = species),\n             show.legend = FALSE)",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Annotations</span>"
    ]
  },
  {
    "objectID": "02-annotations.html#sec-ann-text",
    "href": "02-annotations.html#sec-ann-text",
    "title": "15  Annotations",
    "section": "\n15.2 Text labels",
    "text": "15.2 Text labels\nThe simplest form of annotation is text labels with geom_text() and geom_label(). This uses a label aesthetic to place text wherever they are positioned by the x and y aesthetic. If you use these geoms in the place of geom_point() you get quite a mess.\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             color = species)) + \n  geom_text(aes(label = species),\n            show.legend = FALSE)\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             color = species)) + \n  geom_label(aes(label = species),\n            show.legend = FALSE)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngeom_text() and geom_label() are best used to highlight a small number of points using a subset of the data, such as the smallest and largest penguins.\n\n# Smallesy and largest penguins\nbody_mass_sub &lt;- bind_rows(\n  slice_max(penguins, body_mass_g),\n  slice_min(penguins, body_mass_g)\n)\n\np + \n  geom_text(data = body_mass_sub,\n             aes(label = species))\n\n\n\n\n\n\n\n\n15.2.1 Nudge\nOne way to move the text/label away from the point so that both the point and the label can be seen is to manually nudge the them using nudge_x and nudge_y, which are scaled to the x and y axes.\n\np + \n  geom_text(data = body_mass_sub,\n            aes(label = species),\n            nudge_x = 5, nudge_y = 60)\n\n\n\n\n\n\n\n\n15.2.2 Alignment\nAnother way to alter the position of the text/label is to alter the alignment with vjust and hjust. See Aesthetic specifications vignette: Justification for more information. The arguments take:\n\n\nhjust: Horizontal justification\n\n\n\"left\" or 0: text begins on the point and moves to the right.\n\n\"center\" or 0.5: Default\n\n\"right\" or 1: text ends on the point with the text to the left.\n\n\n\nvjust: Vertical justification\n\n\n\"bottom\" or 0: the bottom of the text is on the point, moving the text up.\n\n\"middle\" or 0.5: Default\n\n\"top\" or 1: the top of the text is on the point, moving the text down.\n\n\nSpecial position:\n\n\n\"inward\": towards the center\n\n\"outward\": away from the center\n\n\n\n\np + \n  geom_text(data = body_mass_sub,\n            aes(label = species),\n            vjust = \"top\", hjust = \"left\")\n\n\n\n\n\n\n\nAlignment and nudge can be used together.\n\np + \n  geom_text(data = body_mass_sub,\n            aes(label = species),\n            vjust = \"top\", hjust = \"left\",\n            nudge_x = 1)\n\n\n\n\n\n\n\nThe special alignment parameters of \"inward\" and \"outward\" are particularly useful because they can move the text different ways depending on where they are in the plot.\n\np + \n  geom_text(data = body_mass_sub,\n            aes(label = species),\n            vjust = \"inward\", hjust = \"inward\")\n\n\n\n\n\n\n\n\n15.2.3 Labeling bar plots\nLabeling bar plots is best done with geom_col() since you need the number used for the height of the bar to also act as the label. The main issue is whether to place the label inside or outside of the bar. This can be done with a combinations of vjust and nudge_y for vertical bar plots and hjust and nudge_x for horizontal bar plots. For a good example of more complex labeling of bar plots see Cedric Scherer’s post on labeling bar plots.\nVertical\n# Above\npenguins |&gt; \n  count(species) |&gt; \n  ggplot(aes(x = species, y = n)) + \n  geom_col() + \n  geom_text(aes(label = n),\n            vjust = 0, nudge_y = 2,\n            fontface = \"bold\")\n\n# Inside\npenguins |&gt; \n  count(species) |&gt; \n  ggplot(aes(x = species, y = n)) + \n  geom_col() + \n  geom_text(aes(label = n),\n            vjust = 1, nudge_y = -2,\n            color = \"white\", fontface = \"bold\")\n\n\n\n\n\n\n\n\n\n\n\n\nHorizontal\n\npenguins |&gt; \n  count(species) |&gt; \n  ggplot(aes(y = species, x = n)) + \n  geom_col() + \n  geom_text(aes(label = n),\n            hjust = 1, nudge_x = -2,\n            color = \"white\", fontface = \"bold\")\n\n\n\n\n\n\n\nDodge\nUsing position_dodge() creates some complexity because ggplot2 does not know the width of the dodge should be the same as the bars. Using width = 0.9 places the labels in the center of the bars. The other complexity is that you cannot use nudge if you use a position adjustment. Therefore, you need to directly change the y variable. Here, y = n + 2 is the same as nudge_y = 2.\n\npenguins |&gt; \n  count(island, species) |&gt; \n  ggplot(aes(x = island, y = n, fill = species)) + \n  geom_col(position = \"dodge\") + \n  geom_text(aes(label = n,\n                y = n + 2),\n            position = position_dodge(width = 0.9),\n            vjust = 0)\n\n\n\n\n\n\n\nStacked\nUse vjust and adjustments to the y variable within position_stack() to place labels within stacked bar plots. To place the labels in the middle of the bars use vjust = 0.5.\n\npenguins |&gt; \n  count(island, species) |&gt; \n  ggplot(aes(x = island, y = n, fill = species)) + \n  geom_col() + \n  geom_text(aes(label = n),\n            position = position_stack(vjust = 0.5))",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Annotations</span>"
    ]
  },
  {
    "objectID": "02-annotations.html#sec-ann-ggrepel",
    "href": "02-annotations.html#sec-ann-ggrepel",
    "title": "15  Annotations",
    "section": "\n15.3 ggrepel",
    "text": "15.3 ggrepel\nggrepel uses an algorithmic approach to minimize overlap of points. This quickly and easily fixes the issues of labels overlapping the points so that you do not need to use nudge and alignment adjustments. The Examples vignette does a good job of showing the wide range of features available in ggrepel.\n\np + \n  geom_text_repel(data = body_mass_sub,\n                  aes(label = species))\n\n\n\n\n\n\n\nBy default, ggrepel will not show labels if there are too many overlaps. This results in a warning. This can be changed with max.overlaps, which defaults to 10. Setting max.overlaps = Inf ensures that all labels are plotted even with overlaps.\n\np + \n  geom_text_repel(data = slice_sample(penguins, n = 25),\n                  aes(label = species),\n                  max.overlaps = Inf)\n\n\n\n\n\n\n\nUse box.padding to space out labels. Default is 0.25 lines. Compare smaller box.padding with larger box.padding.\n\n# No padding: labels closer together\np + \n  geom_text_repel(data = penguins_sub,\n                  aes(label = species),\n                  box.padding = 0)\n\n\n\n\n\n\n\n\n# Padding: labels more spread out\np + \n  geom_text_repel(data = penguins_sub,\n                  aes(label = species),\n                  box.padding = 0.5)\n\n\n\n\n\n\n\n\n15.3.1 Limit labels to a specific area\nxlim and ylim arguments constrain the labels to a specific area. Limits are specified in data coordinates. Use NA when there is no lower or upper bound in a particular direction. For instance, we can move the labels to the upper-left of the plot. Use direction = \"y\" to have the labels stack on top of each other, while expanding the y limits of the plot gives more room for the labels.\n\np + \n  geom_text_repel(data = penguins_sub,\n                  aes(label = species),\n                  xlim = c(NA, 190),\n                  ylim = c(5000, NA),\n                  direction = \"y\") + \n  ylim(c(NA, 7500))\n\n\n\n\n\n\n\nOr align the labels along the top using direction = \"x\" and angling the text at 90 degrees.\n\np + \n  geom_text_repel(data = penguins_sub,\n                  aes(label = species),\n                  ylim = c(6500, NA),\n                  direction = \"x\",\n                  angle = 90) + \n  ylim(c(NA, 7500))\n\n\n\n\n\n\n\n\n15.3.2 Line segments\nAlways, or never, draw line segments with min.segment.length\n\n\nmin.segment.length = 0: draw line segments for all labels, no matter how short they are.\n\nmin.segment.length = Inf: never draw any line segments, no matter how long they are.\n\n\np + \n  geom_text_repel(data = penguins_sub,\n                  aes(label = species),\n                  min.segment.length = 0)\n\n\n\n\n\n\n\nLine segments have many of the same adjustments as geom_segment(). Arguments for lines are:\n\nsegment.linetype\nsegment.color\nsegment.size\nsegment.alpha\n\nFor instance, we can have the line segments and the labels use the same color scale as the points. To do this, you need to use scale_color_discrete() to let the color scale know it should apply to both the color and segment.color aesthetics.\n\np + \n  geom_text_repel(data = penguins_sub,\n                  aes(label = species,\n                      segment.color = species,\n                      color = species),\n                  xlim = c(NA, 190),\n                  ylim = c(5000, NA),\n                  direction = \"y\",\n                  segment.linetype = 2) + \n  ylim(c(NA, 7000)) + \n    scale_color_discrete(\n    # The same color scale will apply to both of these aesthetics.\n    aesthetics = c(\"color\", \"segment.color\")\n  ) + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nYou can make curved line segments and add arrows just like in geom_curve(). See below Section 15.5.2.2 for more on controlling aspects of curves. Arguments for curvature are:\n\n\nsegment.curvature: Number from -1 to 1; negative for left-hand and positive for right-hand curves; 0 for straight lines.\n\nsegment.angle: 0-180, less than 90 skews control points toward the start point.\n\nsegment.ncp: number of control points to make a smoother curve.\n\nsegment.shape: curve shape by control points.\n\nsegment.inflect: whether there should be a curve inflection at the midpoint.\n\n\np + \n  geom_text_repel(data = penguins_sub,\n                  aes(label = species),\n                  xlim = c(NA, 190),\n                  ylim = c(4500, NA),\n                  direction = \"y\",\n                  segment.curvature = -0.5,\n                  arrow = arrow(length = unit(0.015, \"npc\"))) + \n  ylim(c(NA, 7500))\n\n\n\n\n\n\n\nAdd an inflection point:\n\np + \n  geom_text_repel(data = penguins_sub,\n                  aes(label = species),\n                  xlim = c(NA, 190),\n                  ylim = c(4500, NA),\n                  direction = \"y\",\n                  segment.curvature = -0.5,\n                  segment.inflect = TRUE,\n                  arrow = arrow(length = unit(0.015, \"npc\"))) + \n  ylim(c(NA, 7500))",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Annotations</span>"
    ]
  },
  {
    "objectID": "02-annotations.html#sec-ann-highlight",
    "href": "02-annotations.html#sec-ann-highlight",
    "title": "15  Annotations",
    "section": "\n15.4 Highlighting",
    "text": "15.4 Highlighting\nOne of the simplest and most effective forms of annotating a plot is to highlight a subset of the data that is particularly relevant. There are a number of ways to do this.\n\n15.4.1 Color a subset of points\nGray out non-essential data\nA simple example is to only add color to a subset of the points that you want to highlight, while graying out other data. For instance, we can highlight the Adelie and Chinstrap penguins that have flippers longer or equal to 205mm. To do this, plot all of the data in gray and then plot the subset in color over it. Note the use of scale_color_manual() to maintain the same color palette as used for three species. See Section 18.3.3 and Section 18.3.4 for working with discrete and manual color scales.\n\nggplot(penguins,\n       aes(x = flipper_length_mm,\n           y = body_mass_g)) + \n  geom_point(color = \"gray65\") + \n  geom_point(\n    data = filter(penguins,\n                  flipper_length_mm &gt;= 205 & species != \"Gentoo\"),\n    aes(color = species)\n    ) + \n  scale_color_manual(values = scales::hue_pal()(3)[c(1, 2)]) + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nAdd a second layer to points\nAnother similar strategy is to add a second layer of points. This can either be to add a larger point in a different color underneath the full point layer or by adding a larger, open circle shape. For instance, in highlighting tubby Adelie penguins that weigh more than 4.5kg.\nIn creating a “color halo” make sure that the larger, colored point is drawn first.\n\nggplot(penguins,\n       aes(x = flipper_length_mm,\n           y = body_mass_g)) + \n  geom_point(\n    data = filter(penguins, body_mass_g &gt; 4500 & species == \"Adelie\"),\n    color = \"orange\",\n    size = 3\n  ) + \n  geom_point()\n\n\n\n\n\n\n\nA similar affect is created by surrounding the points with an open circle shape. This necessitates three geom_point() layers, one for the full data and two separate layers for the highlighted points.\n\nggplot(penguins,\n       aes(x = flipper_length_mm,\n           y = body_mass_g)) + \n  geom_point() + \n  geom_point(\n    data = filter(penguins, body_mass_g &gt; 4500 & species == \"Adelie\"),\n    color = \"purple\"\n  ) + \n  geom_point(\n    data = filter(penguins, body_mass_g &gt; 4500 & species == \"Adelie\"),\n    color = \"purple\",\n    shape = \"circle open\", size = 3\n  )\n\n\n\n\n\n\n\n\n15.4.2 gghighlight\n\nCode# Line data\nh &lt;- penguins |&gt; \n  group_by(species, island, sex, year) |&gt; \n  summarise(flipper_length_mm = median(flipper_length_mm),\n            .groups = \"drop\") |&gt; \n  mutate(group = paste(species, island, sex))\n\n\ngghighlight helps to automate the strategy of coloring only certain cases, while graying out all others. It works by adding a filtering layer to a ggplot with the gghighlight() function. The first argument is a filtering predicate that is passed to dplyr::filter(). You can have as many of these as you want.\n\nggplot(h, aes(x = year, y = flipper_length_mm, color = group)) + \n  geom_line() + \n  gghighlight(min(flipper_length_mm) &lt;= 185)\n#&gt; label_key: group\n\n\n\n\n\n\n\nLabels\ngghighlight uses direct labeling by default, see Section 15.8 for more on this process. The label is chosen with the label_key argument. The label type is chosen with the line_label_type argument with choices of \"ggrepel_label\", \"ggrepel_text\", \"text_path\", \"label_path\", or \"sec_axis\".\n\nggplot(h, aes(x = year, y = flipper_length_mm, color = group)) + \n  geom_line() + \n  gghighlight(min(flipper_length_mm) &lt;= 185,\n              label_key = species,\n              line_label_type = \"text_path\")\n\n\n\n\n\n\n\nRemove direct labels with use_direct_label = FALSE.\n\nggplot(h, aes(x = year, y = flipper_length_mm, color = group)) + \n  geom_line() + \n  gghighlight(min(flipper_length_mm) &lt;= 185,\n              use_direct_label = FALSE) + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nYou can add your own text labels to the filtered data because gghighlight replaces the plot’s data with the filtered data. Note that the color for the highlighted points is placed in the geom_point() layer.\n\nggplot(penguins,\n       aes(x = flipper_length_mm,\n           y = body_mass_g)) + \n  geom_point(color = \"purple\") + \n  gghighlight(body_mass_g &gt; 4500 & species == \"Adelie\") + \n  geom_text_repel(aes(label = body_mass_g),\n                  max.overlaps = Inf,\n                  box.padding = 0.3)\n\n\n\n\n\n\n\nHighlighted vs unhighlighted aesthetics\nChange aspects of the highlighted cases within the geom and use unhighlighted_params with a list to change aesthetics of all other cases. For instance, make the line width of the highlighted cases larger, while using alpha to deemphasize other cases. Use colour = NULL to maintain color instead of graying out.\n\nggplot(h, aes(x = year, y = flipper_length_mm, color = group)) + \n  geom_line(linewidth = 2) + \n  gghighlight(min(flipper_length_mm) &lt;= 185,\n              unhighlighted_params = list(\n                colour = NULL,\n                alpha = 0.3,\n                linewidth = 0.75),\n              label_key = species)\n\n\n\n\n\n\n\nGeoms\ngghighlight can be used with most geoms.\n\npenguins |&gt; \n  ggplot(aes(x = body_mass_g, fill = species)) +\n  geom_histogram(binwidth = 200) + \n  gghighlight(species == \"Adelie\")\n#&gt; Warning: Tried to calculate with group_by(), but the calculation failed.\n#&gt; Falling back to ungrouped filter operation...\n#&gt; label_key: species\n\n\n\n\n\n\n\nFacets\ngghighlight works automatically with faceting, plotting the entirety of the data in its demphasized form along with each group.\n\npenguins |&gt; \n  ggplot(aes(x = body_mass_g, fill = species)) +\n  geom_histogram(binwidth = 200) + \n  gghighlight() + \n  facet_wrap(~ species)\n#&gt; label_key: species",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Annotations</span>"
    ]
  },
  {
    "objectID": "02-annotations.html#sec-ann-custom",
    "href": "02-annotations.html#sec-ann-custom",
    "title": "15  Annotations",
    "section": "\n15.5 Custom annotations",
    "text": "15.5 Custom annotations\n\n15.5.1 geoms vs annotate()\n\nYou can use a number of geoms to create custom annotations:\n\nText and labels: geom_text() and geom_label()\n\nHighlight rectangular regions: geom_rect()\n\nDraw lines and curves: geom_line(), geom_sement(), and geom_curve()\n\nDraw reference lines: geom_vline(), geom_hline(), and geom_abline()\n\n\nSee Section 14.7.2 for using line and curve geoms and Section 14.7.3 for reference line geoms.\nFor instance, we can create a rectangle with a plot description in it using geom_rect() and geom_text().\n\nrect &lt;- data.frame(xmin = 170, xmax = 200, ymin = 5000, ymax = 6000)\nt &lt;- data.frame(\n  x = 185, y = 5500,\n  lab = \"Body weight compared to flipper\\nlength of three penguin species\")\n\npenguins |&gt; \n  ggplot() + \n  # Place x and y aesthetics in geom_point() to be able to mix in different data\n  geom_point(aes(x = flipper_length_mm,\n                 y = body_mass_g,\n                 color = species),\n             show.legend = FALSE) + \n  geom_rect(data = rect,\n            aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax),\n            fill = \"darkseagreen1\") + \n  geom_text(data = t,\n            aes(x = x, y = y, label = lab))\n\n\n\n\n\n\n\nThe special annotate() function helps to create annotation geoms by making the data frames for you, so that you do not have to create one row data frames like rect and t but can just pass the data directly to annotate().\nannotate() works by selecting the geom you want to create and then providing positional aesthetics necessary for that geom:\n\nPoints and text: x and y\n\nLines and curves: x, xend, y, and yend\n\nRectangles: xmin, xmax, ymin, and ymax\n\n\nThus, the above plot can be recreated with annotate(). Notice that p can now be used because the data is automatically integrated into the penguins data used to make the plot.\n\np + \n  annotate(\n    geom = \"rect\",\n    xmin = 170, xmax = 200, ymin = 5000, ymax = 6000,\n    fill = \"darkseagreen1\"\n  ) + \n  annotate(\n    geom = \"text\",\n    x = 185, y = 5500,\n    label = \"Body weight compared to flipper\\nlength of three penguin species\"\n  )\n\n\n\n\n\n\n\nTo add multiple annotations of the same type use vectors:\n\np + \n  annotate(\n    geom = \"text\",\n    x = c(180, 220),\n    y = c(5500, 3500),\n    label = c(\"Label 1\", \"Label 2\"),\n    color = c(\"purple\", \"firebrick\"),\n    fontface = \"bold\"\n  )\n\n\n\n\n\n\n\n\n15.5.2 Lines, curves, and arrows\nLine segments\nAdding lines to highlight specific areas or points of a plot can be an effective way to improve legibility of a plot.\n\n# data\nchinstrap &lt;- penguins |&gt; \n  filter(species == \"Chinstrap\")\nend &lt;- c(median(chinstrap$flipper_length_mm), median(chinstrap$body_mass_g))\n\np + \n  annotate(\n    geom = \"segment\",\n    x = 190, xend = end[[1]],\n    y = 5500, yend = end[[2]]\n  ) + \n  annotate(\n    geom = \"label\",\n    x = 190, y = 5500,\n    vjust = 0,\n    label = \"Chinstrap\",\n    color = scales::hue_pal()(3)[[2]]\n  )\n\n\n\n\n\n\n\nCurves\nCreate a curved line with geom = \"curve\". Arguments to control the nature of the curve are based on grid::curveGrob():\n\n\ncurvature: Direction of curvature and where to angle drawing of line segment.\n\nMostly between -1 and 1, but larger numbers creates more skewed lines.\nNegative values produce left-hand curves\nPositive values produce right-hand curves\nZero produces a straight line.\nDefault is 0.5.\n\n\n\nangle: A numeric value between 0 and 180, for where the curve takes place along the line.\n\n\n&lt; 90: make the curve take place further along the line segment.\n\n&gt; 90: make the curve occur earlier along the line segment.\n\n\n\nncp: The number of control points used to draw the curve. More control points creates a smoother curve. Default is 5.\n\nDefault curve\n\np + \n  annotate(\n    geom = \"curve\",\n    x = 180, xend = end[[1]],\n    y = 5500, yend = end[[2]]\n  ) + \n  annotate(\n    geom = \"label\",\n    x = 180, y = 5500,\n    hjust = 1,\n    vjust = 0,\n    label = \"Chinstrap\",\n    color = scales::hue_pal()(3)[[2]]\n  )\n\n\n\n\n\n\n\nLeft-hand curve with curve skewed towards the beginning of the line segment:\n\np + \n  annotate(\n    geom = \"curve\",\n    x = 180, xend = end[[1]],\n    y = 5500, yend = end[[2]],\n    curvature = -0.5,\n    angle = 135\n  ) + \n  annotate(\n    geom = \"label\",\n    x = 180, y = 5500,\n    hjust = 1,\n    vjust = 0,\n    label = \"Chinstrap\",\n    color = scales::hue_pal()(3)[[2]]\n  )\n\n\n\n\n\n\n\nArrows\nBoth geom_segment() and geom_curve() have arguments for arrow to add arrows on one or both sides of the line segments using the arrow() function, which is exported from grid::arrow(). Arguments for controlling the aesthetics of arrows:\n\n\nangle: Angle of the arrow point. Default is 30 degrees.\n\nlength: Length of the arrow head, using unit().\n\nends: Where to draw arrow head: One of \"last\", \"first\", or \"both\".\n\ntype: Either \"open\" or \"closed\" arrow head.\n\n\np + \n  annotate(\n    geom = \"curve\",\n    x = 180, xend = end[[1]],\n    y = 5500, yend = end[[2]],\n    curvature = -0.5,\n    angle = 135,\n    arrow = arrow(length = unit(0.05, \"npc\"),\n                  type = \"closed\")\n  ) + \n  annotate(\n    geom = \"label\",\n    x = 180, y = 5500,\n    hjust = 1,\n    vjust = 0,\n    label = \"Chinstrap\",\n    color = scales::hue_pal()(3)[[2]]\n  )",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Annotations</span>"
    ]
  },
  {
    "objectID": "02-annotations.html#sec-ann-ggtext",
    "href": "02-annotations.html#sec-ann-ggtext",
    "title": "15  Annotations",
    "section": "\n15.6 ggtext",
    "text": "15.6 ggtext\nThe ggtext package provides two geoms for creating text annotations with markdown and html rendering for ggplot2 that can replace geom_text() or geom_label(). In addition to the geoms, ggtext also provides a way to render markdown and html in plot theme elements, see Section 23.9. In both the geoms and the theme elements ggtext provides two alternatives: markdown text labels and markdown text boxes with word wrapping. The actual rendering of the markdown and html is done by the gridtext package. ggtext only supports a small subset of markdown/html capabilities. For a list of supported Markdown and HTML capabilities, see Section 23.9.1 for a list of supported capabilities and the valid Markdown, HTML, and CSS that can be used.\n\n15.6.1 ggtext geoms\ngeom_richtext() creates markdown labels and is mostly a replacement for geom_label() or geom_text() with added capabilities. For instance, we can recreate the text annotations in Section 15.5.1 with some rich text.\n\nt &lt;- data.frame(\n  x = 185, y = 5500,\n  lab = \"**Body weight** compared to **flipper&lt;br&gt;length** of three penguin species\")\n\np + \n  geom_richtext(data = t,\n            aes(x = x, y = y, label = lab),\n            fill = \"darkseagreen1\")\n\n\n\n\n\n\n\nThe text can be angled with geom_richtext():\n\np + \n  geom_richtext(data = t,\n            aes(x = x, y = y, label = lab),\n            fill = \"darkseagreen1\",\n            angle = 30)\n\n\n\n\n\n\n\nUse fill = NA and label.color = NA to remove the background and box around the text.\n\np + \n  geom_richtext(data = t,\n            aes(x = x, y = y, label = lab),\n            fill = NA,\n            label.color = NA)\n\n\n\n\n\n\n\ngeom_textbox() is very similar to geom_richtext(), but it automatically wraps text and does not support arbitrary rotation angles, though it can be rotated at right angles.\n\nt &lt;- data.frame(\n  x = 185, y = 5500,\n  lab = paste(\"**Body weight** compared to **flipper length**\",\n              \"of three penguin species: Adelie, Chinstrap, and Gentoo\",\n              \"on the islands of Biscoe, Dream, and Torgersen.\"))\n\np + \n  geom_textbox(data = t,\n               aes(x = x, y = y, label = lab),\n               fill = \"darkseagreen1\")\n\n\n\n\n\n\n\nControl the width and height of the text box with width and height. The defaults are width = unit(2, \"inch\") and height = NULL to be determined by the width. Use halign and valign to control the horizontal and vertical justification of the text within the box, as opposed to hjust and vjust that determine the alignment of the box. The orientation of the text can be one of \"upright\", \"left-rotated\", \"right-rotated\", or \"inverted\".\n\np + \n  geom_textbox(data = t,\n               aes(x = x, y = y, label = lab),\n               fill = \"darkseagreen1\",\n               # Take up 45% of plot panel width\n               width = unit(0.45, \"npc\"),\n               halign = 1)",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Annotations</span>"
    ]
  },
  {
    "objectID": "02-annotations.html#sec-ann-ggforce",
    "href": "02-annotations.html#sec-ann-ggforce",
    "title": "15  Annotations",
    "section": "\n15.7 ggforce",
    "text": "15.7 ggforce\n\n15.7.1 Geoms\nThe ggforce package provides four geoms to annotate areas of a plot, differing by the shape that they draw.\n\ngeom_mark_rect()\ngeom_mark_circle()\ngeom_mark_ellipse()\ngeom_mark_hull()\n\np + \n  geom_mark_rect(\n    aes(group = species))\np + \n  geom_mark_hull(\n    aes(fill = species))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n15.7.2 Filter\ngeom_mark_*() functions contain a filter aesthetic since you often only want to highlight specific groups in a plot. Using the aesthetic is easier than creating a filtered data set, and the labels will know to not overlap with the rest of the data.\n\np + \n  geom_mark_hull(\n    aes(fill = species,\n        filter = species == \"Gentoo\"),\n    show.legend = FALSE) + \n  scale_fill_manual(values = scales::hue_pal()(3)[[3]])\n\n\n\n\n\n\n\n\n15.7.3 Labels\nUsing the label aesthetic adds labels to mark geoms with a bent line to connect to the label.\n\np + \n  geom_mark_hull(\n    aes(color = species,\n        label = species),\n    show.legend = FALSE)\n\n\n\n\n\n\n\nUse label.* arguments to change aspects to the labels and con.* arguments to alter aspects of the connecting line. Particularly relevant is label.fill = \"transparent\" and the con.type argument that can be one of \"elbow\", \"straight\", or \"none\".\n\np + \n  geom_mark_hull(\n    aes(color = species,\n        label = species),\n    label.fill = \"transparent\",\n    con.type = \"straight\",\n    show.legend = FALSE)\n\n\n\n\n\n\n\nIt is also possible to add longer descriptions to the labels that are automatically wrapped. The description aesthetic can either be tied to a variable in the data or provided directly if there is only one highlighted area.\n\np + \n  geom_mark_hull(\n    aes(group = species,\n        filter = species == \"Gentoo\",\n        label = species,\n        description = \"The largest of the three penguin species.\"),\n    show.legend = FALSE)",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Annotations</span>"
    ]
  },
  {
    "objectID": "02-annotations.html#sec-ann-direct",
    "href": "02-annotations.html#sec-ann-direct",
    "title": "15  Annotations",
    "section": "\n15.8 Direct labeling",
    "text": "15.8 Direct labeling\n\nCode# Line plot\np_line &lt;- penguins |&gt; \n  count(species, year) |&gt; \n  ggplot(aes(x = year,\n             y = n,\n             color = species))\n\n\nThere are a number of tools to automate the process of directly labeling a plot instead of doing it by hand. Two examples are directlabels and geomtextpath.\n\n15.8.1 directlabels\nThe directlabels package introduces a number of placement methods for algorithmically placing labels on a plot using geom_dl(). See here for a list of the possible placement methods. The most useful one for a scatter plot is \"smart.grid\", which positions the labels near the center of each point cloud.\n\np + \n  directlabels::geom_dl(\n    aes(label = species,\n        color = species),\n    method = \"smart.grid\")\n\n\n\n\n\n\n\nThere are also placement methods optimized for line plots such as \"last.points\".\n\np_line + \n  geom_line(show.legend = FALSE) + \n  directlabels::geom_dl(\n    aes(label = species),\n    method = \"last.points\") + \n  scale_x_continuous(breaks = c(2007, 2008, 2009),\n                     limits = c(NA, 2009.5))\n\n\n\n\n\n\n\n\n15.8.2 geomtextpath\nThe geomtextpath package focuses on creating labels along lines and particularly along curved lines. geomtextpath works by creating new geoms that are named either geom_text*() or geom_label*(). They create both the geom and the label/text.\n\np_line + \n  geom_textline(aes(label = species)) + \n  scale_x_continuous(breaks = c(2007, 2008, 2009)) + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\ngeomtextpath is particularly designed to allow labels to follow curves.\n\npenguins |&gt; \n  ggplot(aes(x = body_mass_g, color = species)) +\n  geom_textdensity(aes(label = species)) + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nSet different text and line colors with textcolor and linecolor.\n\np_line + \n  geom_textline(aes(label = species),\n                textcolor = \"firebrick\",\n                linecolor = \"dodgerblue\") + \n  scale_x_continuous(breaks = c(2007, 2008, 2009)) + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nText justification\nHorizontal justification\nhjust is used to justify text along the curve/line.\n\np_line + \n  geom_textline(aes(label = species),\n                hjust = 1) + \n  scale_x_continuous(breaks = c(2007, 2008, 2009)) + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nAn alternative is to use a text string to highlight a particular position relative to x and y coordinates for each line. The options are: “xmin”, “xmid”, “xmax”, “ymin”, “ymid”, “ymax”, and “auto”.\n\np_line + \n  geom_textline(aes(label = species),\n                hjust = \"ymax\") + \n  scale_x_continuous(breaks = c(2007, 2008, 2009)) + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nhjust = \"auto\" finds the straightest segment for the labels.\n\npenguins |&gt; \n  ggplot(aes(x = body_mass_g, color = species)) +\n  geom_textdensity(aes(label = species),\n                   hjust = \"auto\") + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nTo align multi-line text use halign instead of hjust. This can be one of \"left\", \"center\", or \"right\".\nVertical justification\nvjust is used to justify text orthogonal to the curve/line, as an offset to the path of the line/curve. vjust = 0 aligns the bottom of the text with the curve, whereas vjust = 1 aligns the top of the text with the curve.\n\np_line + \n  geom_textline(aes(label = species),\n                vjust = 0) + \n  scale_x_continuous(breaks = c(2007, 2008, 2009)) + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nvjust outside [0, 1] does not intersect with the line. Thus, both the text and the line will be drawn. If you do not want the line to be drawn, use gap = TRUE.\n\np_line + \n  geom_textline(aes(label = species),\n                vjust = -0.5,\n                hjust = 1) + \n  scale_x_continuous(breaks = c(2007, 2008, 2009)) + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nAn alternative to vjust is to use offset with grid::unit(). If this option is used, vjust is ignored and gap should be set to FALSE.\n\np_line + \n  geom_textline(aes(label = species),\n                offset = unit(1, \"mm\"),\n                gap = FALSE,\n                hjust = 1) + \n  scale_x_continuous(breaks = c(2007, 2008, 2009)) + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nIt is possible to use multiple justification parameters for the different lines with scale_hjust_discrete(), scale_vjust_discrete(), scale_hjust_manual() and/or scale_vjust_manual(). Use discrete options to automatically differ the horizontal or vertical justification of each group. Use manual options to pick the different levels of justification.\n\np_line + \n  geom_textline(aes(label = species,\n                    hjust = species,\n                    vjust = species)) + \n  scale_hjust_discrete(range = c(0.25, 0.75)) + \n  scale_vjust_manual(values = c(1.5, 0.25, -0.5)) + \n  scale_x_continuous(breaks = c(2007, 2008, 2009)) + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nRich text\nRich text support is provided by ggtext and can be turned on with rich = TRUE.",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>Annotations</span>"
    ]
  },
  {
    "objectID": "02-aesthetics.html",
    "href": "02-aesthetics.html",
    "title": "16  Aesthetics",
    "section": "",
    "text": "16.1 Resources\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(palmerpenguins)\n\n# Data\npenguins &lt;- penguins |&gt; \n  filter(!is.na(flipper_length_mm),\n         !is.na(sex))",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Aesthetics</span>"
    ]
  },
  {
    "objectID": "02-aesthetics.html#sec-aes-resources",
    "href": "02-aesthetics.html#sec-aes-resources",
    "title": "16  Aesthetics",
    "section": "",
    "text": "Aesthetics documentation\nAesthetic specifications vignette\nWickham, ggplot2 Book: Aesthetic mappings\nggplot2 Cheatsheet: Aes\nR for Data Science: Communication, Aesthetic mappings\nDefault ggplot2 aesthetics",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Aesthetics</span>"
    ]
  },
  {
    "objectID": "02-aesthetics.html#sec-aes-map",
    "href": "02-aesthetics.html#sec-aes-map",
    "title": "16  Aesthetics",
    "section": "\n16.2 Mapping vs setting aesthetics",
    "text": "16.2 Mapping vs setting aesthetics\nAesthetics define the visual properties of geoms. They can either be mapped to change according to variables in the data or set as a constant value.\n\n\nMap an aesthetic to a variable with aes(): aes(color = species)\n\n\nSet an aesthetic outside of aes() with a constant: color = \"blue\"\n\n\nAesthetics can be mapped for the entire plot (ggplot(aes())) or within each layer (geom_point(aes())). Within each layer you can add, override, or remove mappings.\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) + \n  geom_point(\n    aes(color = species), # Map aesthetic\n    shape = \"square\" # Set aesthetic\n    )\n\n\n\n\n\n\n\n\n16.2.1 Naming layers\nAn alternative between mapping and setting aesthetics is to name the layers within aes() to distinguish them and create a legend. This is useful when you want to compare multiple layers such as two geom_smooth() layers with different methods.\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm, y = body_mass_g)) + \n  geom_point() + \n  geom_smooth(aes(color = \"Method: loess\"), method = \"loess\", se = FALSE) + \n  geom_smooth(aes(color = \"Method: lm\"), method = \"lm\", se = FALSE) +\n  labs(color = \"Method\")\n#&gt; `geom_smooth()` using formula = 'y ~ x'\n#&gt; `geom_smooth()` using formula = 'y ~ x'",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Aesthetics</span>"
    ]
  },
  {
    "objectID": "02-aesthetics.html#sec-aes-common",
    "href": "02-aesthetics.html#sec-aes-common",
    "title": "16  Aesthetics",
    "section": "\n16.3 Common aesthetics",
    "text": "16.3 Common aesthetics\nThe documentation for each geom provides the aesthetics that can be used with it. Common aesthetics include:\n\npositions: x, y\n\ncolors: color, fill\n\nshapes: shape, linetype\n\nsize: size, linewidth\n\ntransparency: alpha\n\ngroupings: group",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Aesthetics</span>"
    ]
  },
  {
    "objectID": "02-aesthetics.html#default-aesthetics-for-geoms",
    "href": "02-aesthetics.html#default-aesthetics-for-geoms",
    "title": "16  Aesthetics",
    "section": "\n16.4 Default aesthetics for geoms",
    "text": "16.4 Default aesthetics for geoms\nEach geom has default aesthetics when drawing the geoms. For a complete list see the table created by Dana Seidel. The gist includes code to create a list and table of the default aesthetics:\n\ngeom_names &lt;- apropos(\"^Geom\", ignore.case = FALSE)\ngeoms &lt;- mget(geom_names, env = asNamespace(\"ggplot2\"))\naes_list &lt;- lapply(geoms, function(x) x$default_aes)\n\nThe list provides a nice way to look at the default aesthetics, but it is quite long. We can simplify the list to concentrate on aesthetics used for the main types of geoms.\nPoints\n\naes_list[c(\"GeomPoint\")]\n#&gt; $GeomPoint\n#&gt; Aesthetic mapping: \n#&gt; * `shape`  -&gt; 19\n#&gt; * `colour` -&gt; \"black\"\n#&gt; * `size`   -&gt; 1.5\n#&gt; * `fill`   -&gt; NA\n#&gt; * `alpha`  -&gt; NA\n#&gt; * `stroke` -&gt; 0.5\n\nLines\n\naes_list[c(\"GeomLine\", \"GeomSmooth\")]\n#&gt; $GeomLine\n#&gt; Aesthetic mapping: \n#&gt; * `colour`    -&gt; \"black\"\n#&gt; * `linewidth` -&gt; 0.5\n#&gt; * `linetype`  -&gt; 1\n#&gt; * `alpha`     -&gt; NA\n#&gt; \n#&gt; $GeomSmooth\n#&gt; Aesthetic mapping: \n#&gt; * `colour`    -&gt; \"#3366FF\"\n#&gt; * `fill`      -&gt; \"grey60\"\n#&gt; * `linewidth` -&gt; 1\n#&gt; * `linetype`  -&gt; 1\n#&gt; * `weight`    -&gt; 1\n#&gt; * `alpha`     -&gt; 0.4\n\nRectangles\n\naes_list[c(\"GeomPolygon\", \"GeomBar\", \"GeomBoxplot\")]\n#&gt; $GeomPolygon\n#&gt; Aesthetic mapping: \n#&gt; * `colour`    -&gt; NA\n#&gt; * `fill`      -&gt; \"grey20\"\n#&gt; * `linewidth` -&gt; 0.5\n#&gt; * `linetype`  -&gt; 1\n#&gt; * `alpha`     -&gt; NA\n#&gt; * `subgroup`  -&gt; NULL\n#&gt; \n#&gt; $GeomBar\n#&gt; Aesthetic mapping: \n#&gt; * `colour`    -&gt; NA\n#&gt; * `fill`      -&gt; \"grey35\"\n#&gt; * `linewidth` -&gt; 0.5\n#&gt; * `linetype`  -&gt; 1\n#&gt; * `alpha`     -&gt; NA\n#&gt; \n#&gt; $GeomBoxplot\n#&gt; Aesthetic mapping: \n#&gt; * `weight`    -&gt; 1\n#&gt; * `colour`    -&gt; \"grey20\"\n#&gt; * `fill`      -&gt; \"white\"\n#&gt; * `size`      -&gt; NULL\n#&gt; * `alpha`     -&gt; NA\n#&gt; * `shape`     -&gt; 19\n#&gt; * `linetype`  -&gt; \"solid\"\n#&gt; * `linewidth` -&gt; 0.5\n\nText\n\naes_list[c(\"GeomText\", \"GeomLabel\")]\n#&gt; $GeomText\n#&gt; Aesthetic mapping: \n#&gt; * `colour`     -&gt; \"black\"\n#&gt; * `size`       -&gt; 3.88\n#&gt; * `angle`      -&gt; 0\n#&gt; * `hjust`      -&gt; 0.5\n#&gt; * `vjust`      -&gt; 0.5\n#&gt; * `alpha`      -&gt; NA\n#&gt; * `family`     -&gt; \"\"\n#&gt; * `fontface`   -&gt; 1\n#&gt; * `lineheight` -&gt; 1.2\n#&gt; \n#&gt; $GeomLabel\n#&gt; Aesthetic mapping: \n#&gt; * `colour`     -&gt; \"black\"\n#&gt; * `fill`       -&gt; \"white\"\n#&gt; * `size`       -&gt; 3.88\n#&gt; * `angle`      -&gt; 0\n#&gt; * `hjust`      -&gt; 0.5\n#&gt; * `vjust`      -&gt; 0.5\n#&gt; * `alpha`      -&gt; NA\n#&gt; * `family`     -&gt; \"\"\n#&gt; * `fontface`   -&gt; 1\n#&gt; * `lineheight` -&gt; 1.2",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Aesthetics</span>"
    ]
  },
  {
    "objectID": "02-aesthetics.html#sec-aes-color",
    "href": "02-aesthetics.html#sec-aes-color",
    "title": "16  Aesthetics",
    "section": "\n16.5 Color, fill, and alpha",
    "text": "16.5 Color, fill, and alpha\nAdd color to the geom with either color or fill aesthetics. See Color related aesthetics for more.\n\n\ncolor is used with geom_point(), lines, and the outline of polygon geoms.\n\nfill “fills” in the color of all polygon geoms.\n\nColors can be specified with either rbg hex string, color name listed under colors(), or NA for transparent.\nalpha: Values of alpha range from 0 to 1, with lower values corresponding to more transparent colors.",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Aesthetics</span>"
    ]
  },
  {
    "objectID": "02-aesthetics.html#sec-aes-lines",
    "href": "02-aesthetics.html#sec-aes-lines",
    "title": "16  Aesthetics",
    "section": "\n16.6 Lines",
    "text": "16.6 Lines\nThe appearance of a line is affected by linewidth, linetype, lineend, linejoin. See ggplot2 Aesthetic specifications: Lines\nlinewidth: used to control the width or size of the line.\nLine type\nlinetype: can be specified with an integer of 0 to 6 or by name:\n\n0 = blank\n1 = solid\n2 = dashed\n3 = dotted\n4 = dotdash\n5 = longdash\n6 = twodash\n\nAlternatively, linetype can be created with a string containing 2, 4, 6, or 8 hexadecimal digits that provide lengths of on and off. Thus, \"3313\" specifies three units on followed by three off followed by one on and finally three off.\nLine ends\n\n\nlineend can be one of \"butt\" (the default), \"round\", or \"square\".\n\nlinejoin can be one of \"round\" (the default), \"mitre\", or \"bevel\".",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Aesthetics</span>"
    ]
  },
  {
    "objectID": "02-aesthetics.html#sec-aes-points",
    "href": "02-aesthetics.html#sec-aes-points",
    "title": "16  Aesthetics",
    "section": "\n16.7 Points",
    "text": "16.7 Points\nPoints can be chosen in 5 ways, see the visualization in the Aesthetics vignette:\n\nAn integer: 0 to 25\nName of the shape\nSingle character to use that character as a plotting symbol.\n\n. to draw the smallest rectangle that is visible, usually 1 pixel.\n\nNA to draw nothing",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Aesthetics</span>"
    ]
  },
  {
    "objectID": "02-aesthetics.html#sec-aes-groups",
    "href": "02-aesthetics.html#sec-aes-groups",
    "title": "16  Aesthetics",
    "section": "\n16.8 Grouping",
    "text": "16.8 Grouping\nThe group aesthetic is by default set to the interaction of all discrete variables in the plot. This default is often good enough, but when it does not work or when there is no discrete variable, you need to explicitly map group to a variable that has a different value for each group. See Aesthetics: grouping.\nFor most applications the grouping is set implicitly by mapping one or more discrete variables to x, y, color, fill, alpha, shape, size, and/or linetype. The typical case where grouping does not work by default is with geom_line() when only positional aesthetics are set. See Section 14.7 for examples.",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>Aesthetics</span>"
    ]
  },
  {
    "objectID": "02-scales-position.html",
    "href": "02-scales-position.html",
    "title": "17  Position scales",
    "section": "",
    "text": "17.1 Resources\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(readr)\nlibrary(palmerpenguins)\n\n# Data\npenguins &lt;- penguins |&gt; \n  filter(!is.na(flipper_length_mm),\n         !is.na(sex))\n\nbikes &lt;- read_csv(\n  here::here(\"data\", \"london-bikes-custom.csv\"),\n  col_types = \"Dcfffilllddddc\"\n)\n\nbikes$season &lt;- forcats::fct_inorder(bikes$season)\n\n# Base plot\np &lt;- penguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  geom_point(aes(color = species)) + \n  theme(legend.position = \"none\")",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Position scales</span>"
    ]
  },
  {
    "objectID": "02-scales-position.html#sec-scale-pos-resources",
    "href": "02-scales-position.html#sec-scale-pos-resources",
    "title": "17  Position scales",
    "section": "",
    "text": "Scales documentation\nggplot2 Cheatsheet: Scales\nscales package\nWickham, ggplot2 Book: Position scales and axes\nR for Data Science: Communication, Scales",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Position scales</span>"
    ]
  },
  {
    "objectID": "02-scales-position.html#sec-position-types",
    "href": "02-scales-position.html#sec-position-types",
    "title": "17  Position scales",
    "section": "\n17.2 Types of positional scales",
    "text": "17.2 Types of positional scales\n\nContinuous: Map continuous values to visual ones - scale_*_continuous()\n\nBinned: Map continuous values into discrete bins or categories - scale_*_binned()\n\nDiscrete: Map a finite number of discrete categories to visual ones - scale_*_discrete()\n\nDates: Treat data values as dates or datetimes - scale_*_date(date_labels = \"%m/%d\", date_breaks = \"2 weeks\")\n\n\n\n17.2.1 Scale position continuous\nscale_x/y_continuous() is often the default for plots and usually does not need to be specified. Transformation of scales can be done in two ways within scales_ functions: trans argument or with transformation functions. See ggplot2 Book: Transformations for available transformations through the trans argument provided by the scales package.\n\nscale_x_continuous()\nscale_x_log10()\nscale_x_reverse()\nscale_x_sqrt()\n\np + \n  scale_y_continuous(trans = \"log10\")\np + \n  scale_y_log10()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n17.2.2 Scale position binned\nscale_x/y_binned() transforms continuous position data into discrete data. Use these to transform continuous data into bins for use with discrete geoms.\n\npenguins |&gt; \nggplot(aes(x = flipper_length_mm,\n           fill = species)) + \n  geom_bar() + \n  scale_x_binned()\n\n\n\n\n\n\n\n\n17.2.3 Scale position discrete\nscale_x/y_discrete() is the default for discrete geoms like geom_bar(). It is useful when using geoms usually mapped to continuous values, such as geom_jitter() to show individual values for discrete variables.\n\npenguins |&gt; \nggplot(aes(x = sex,\n           y = body_mass_g,\n           color = species)) + \n  geom_jitter()\n\n\n\n\n\n\n\n\n17.2.4 Scale position date\nDate positional scales provide special ability to label axes in ways that make sense for dates. See Section 17.5.2.6 for labeling date axes.\n\nscale_x_date()\nscale_x_datetime()",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Position scales</span>"
    ]
  },
  {
    "objectID": "02-scales-position.html#sec-pos-args",
    "href": "02-scales-position.html#sec-pos-args",
    "title": "17  Position scales",
    "section": "\n17.3 Scale position arguments",
    "text": "17.3 Scale position arguments\n\n\nname: name used for the axis or legend title. If NULL the name will be omitted.\n\nbreaks: axis breaks for grid lines\n\n\nNULL: no breaks, labels, or grids\nA vector of positions: breaks = c(2, 4, 6) or breaks = 1:3*2\n\nA breaks function such as scales::extended_breaks(n)\n\n\n\n\nlabels: labels used for axis breaks.\n\n\nNULL: no labels\nA character vector of labels: labels = c(\"two\", \"four\", \"six\")\n\nAn anonymous function to transform labels labels = paste0(1:3*2, \"k\")\n\nA function from the scales package: labels = scales::label_comma()\n\n\n\n\nlimits: range of x and/or y\n\n\nNULL: use the default scale range\nNumeric vector providing minimum and maximum with NA to refer to the existing minimum or maximum.\nA function that accepts the existing (automatic) limits and returns new limits.\n\n\n\nexpand: Used to add or reduce padding around data along an axis.\n\nUse the convenience function expansion() to generate the values for the expand argument: expand = expansion(add = 2)\n\n\n\n\nna.value: value used to replace missing values.\n\ntrans: A transformation object bundles together a transform, its inverse, and methods for generating breaks and labels.\n\nguide: Specify, add, or remove guides.\n\nposition: The position of the axis.\n\n\n\"left\" or \"right\" for y axes, \"top\" or \"bottom\" for x axes.",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Position scales</span>"
    ]
  },
  {
    "objectID": "02-scales-position.html#sec-scale-breaks",
    "href": "02-scales-position.html#sec-scale-breaks",
    "title": "17  Position scales",
    "section": "\n17.4 Axes breaks",
    "text": "17.4 Axes breaks\nThere are three arguments controlling breaks: breaks, minor_breaks, and n.breaks. Breaks control the axis tick marks and the major and minor grid lines on plots.\n\n17.4.1 Remove breaks\nRemove axis breaks, labels, and grids with NULL.\n\np + \n  scale_y_continuous(breaks = NULL)\n\n\n\n\n\n\n\n\n17.4.2 Breaks: Vector of positions\nUse of c(), seq(), or integer sequence (:) to create vector of positions.\n\np +  \n  scale_x_continuous(breaks = seq(170, 230, by = 20),\n                     minor_breaks = seq(170, 230, by = 5)) + \n  scale_y_continuous(breaks = 5:13*500,\n                     minor_breaks = NULL)\n\n\n\n\n\n\n\nCan combine the different ways to create a vector to make unequal breaks.\n\np +  \n  scale_y_continuous(\n    breaks = c(seq(2600, 4000, by = 200), 5000, 6000))\n\n\n\n\n\n\n\nUse external data such as the summary of body_mass_g to make breaks. This is the strategy used in the plot from R for Data Science showing presidential terms.\n\np + \n  scale_y_continuous(\n    minor_breaks = NULL,\n    breaks = penguins$body_mass_g |&gt; \n      summary() |&gt; \n      as.vector() |&gt; \n      round()\n    )\n\n\n\n\n\n\n\n\n17.4.3 Breaks: extended_breaks()\n\nChoose the number of breaks with extended_breaks() or with n.breaks argument.\np + \n  scale_x_continuous(breaks = \n    scales::breaks_extended(n = 4))\np + \n  scale_x_continuous(\n    n.breaks = 4)",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Position scales</span>"
    ]
  },
  {
    "objectID": "02-scales-position.html#sec-scale-guides",
    "href": "02-scales-position.html#sec-scale-guides",
    "title": "17  Position scales",
    "section": "\n17.5 Axes guides",
    "text": "17.5 Axes guides\nAxes labels and legends are collectively known as guides. The labels argument works very similar to breaks, but the data is character vectors rather than numeric. In addition to the labels, the axis labels can be altered through the guide argument. See Section 17.5 for more on the use of the guide argument.\n\n17.5.1 Axis title\nThe first argument of scale_ functions is name, which provides the axis or legend title. This can also be achieved with labs() or xlab(), ylab() functions. Remove axis title with NULL.\n\np + \n  scale_x_continuous(\"Flipper Length (mm)\") + \n  scale_y_continuous(name = NULL)\n\n\n\n\n\n\n\n\n17.5.2 Axis labels\nRemove axis labels\nRemove axis labels with NULL or set guide = \"none\". The former maintains tick marks; the latter removes ticks, which are part of the guide. Unlike with breaks, this maintains grid lines.\n\np + \n  scale_x_continuous(labels = NULL) +\n  scale_y_continuous(guide = \"none\")\n\n\n\n\n\n\n\nAxis labels position\nYou can also move the labels and ticks with the position argument from the default of bottom and left.\n\np + \n  scale_x_continuous(position = \"top\") +\n  scale_y_continuous(position = \"right\")\n\n\n\n\n\n\n\nAxis labels: Character vector\nProvide a character vector that is the same lengths as breaks.\n\np + \n  scale_x_continuous(breaks = NULL) + \n  scale_y_continuous(\n    name = \"Body Mass\",\n    labels = c(\"3kg\", \"4kg\", \"5kg\", \"6kg\")\n  )\n\n\n\n\n\n\n\nAxis labels: Anonymous function\n\np + \n  scale_x_continuous(breaks = NULL) + \n  scale_y_continuous(\n    name = \"Body Mass\",\n    labels = (\\(x) paste0(x / 1000, \"kg\"))\n  )\n\n\n\n\n\n\n\nAxis labels: scales package\nlabel_number() and label_comma() from the scales package provide a nice way to force decimal display of numbers (no scientific notion). label_comma() is the same as label_number() but inserts a comma every three digits.\nArguments:\n\n\nscale: Ability to transform labels through multiplication to change units.\n\nprefix and sufix: Additional text to display before and after the number label that removes the need to use paste().\n\n\np + \n  scale_x_continuous(breaks = NULL) + \n  scale_y_continuous(\n    name = \"Body Mass\",\n    labels = scales::label_number(\n      scale = 0.001,\n      suffix = \"kg\")\n  )\n\n\n\n\n\n\n\nOther scales formats\n\n\nlabel_bytes(): formats numbers as kilobytes, megabytes etc.\n\nlabel_comma(): formats numbers as decimals with commas added.\n\nlabel_dollar(): formats numbers as currency.\n\nlabel_ordinal(): formats numbers in rank order: 1st, 2nd, 3rd etc.\n\nlabel_percent(): formats numbers as percentages.\n\nlabel_pvalue(): formats numbers as p-values: &lt;.05, &lt;.01, .34, etc.\nAxis labels: Dates\n\nCode# Dates base plot\nb &lt;- bikes |&gt; \n  ggplot(aes(x = date, y = count,\n             color = season)) + \n  geom_point()  + \n  scale_y_continuous(breaks = NULL) + \n  labs(x = NULL, y = NULL) + \n  theme(legend.position = \"none\")\n\n\nDates provides its own difficulties for a continuous scale and this is why scale_x_date() and scale_x_datetime() are provided. The date scales have special arguments for date_breaks and date_labels.\n\n\ndate_breaks: A string giving the distance between breaks like \"2 weeks\", or \"10 years\".\n\ndate_labels: A string giving the formatting specification for the labels using POSIX codes used by strftime().\n\n\nb + \n  scale_x_date(\n    date_breaks = \"3 months\",\n    date_minor_breaks = \"1 month\",\n    date_labels = \"%b %y\")\n\n\n\n\n\n\n\nYou can create more complex date breaks and labels with the helper function scales::breaks_width(). For instance, if you want to have the breaks on the 15th of the month, use breaks_width(offset = 14) or \"14 days\". breaks_width() and offset can also be used with non-date axis breaks and labels to create breaks that do not end in 0 or 5 such as breaks_width(width = 20, offset = 4).\n\nb + \n  scale_x_date(\n    breaks = scales::breaks_width(\n      \"3 months\", offset = 14),\n    date_labels = \"%d %b\")\n\n\n\n\n\n\n\nAnother convenience function from the scales package for dates is label_date_short(), which automatically constructs a short format string sufficient to uniquely identify labels.\n\nb + \n  scale_x_date(\n    labels = scales::label_date_short())\n\n\n\n\n\n\n\nAxis labels: guides\nThe guide argument can be used to affect axis labels in many of the same ways as the labels argument. Axis guides are set with guide_axis() either in the general guides() convenience function or in the guide argument.\n\np + \n  scale_x_continuous(guide = guide_axis(\"Flipper length\")) + \n  guides(y = guide_axis(\"Body mass\"))\n\n\n\n\n\n\n\nWhat guide and guide_axis() add is the ability to change the angle of the labels or stack labels. Changes to label angle can also be done with themes, see Section 23.5.2.\n\np +  \n  scale_x_continuous(n.breaks = 20,\n                     guide = guide_axis(n.dodge = 3)) + \n  scale_y_continuous(guide = guide_axis(angle = 45))\n\n\n\n\n\n\n\nYou can also change the position of the labels with guide_axis(), replicating the functionality of the position argument in scale_x/y_*().",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Position scales</span>"
    ]
  },
  {
    "objectID": "02-scales-position.html#sec-scale-limits",
    "href": "02-scales-position.html#sec-scale-limits",
    "title": "17  Position scales",
    "section": "\n17.6 Scale limits",
    "text": "17.6 Scale limits\n\n17.6.1 Limit convenience functions\nThere are three convenience functions for setting plot limits:\n\n\nlims(): Like labs(), lims() is a more general convenience function that can set limits to any scale such as size or color.\n\nxlim() and ylim(): provide quick means to set limits to position scales.\n\n17.6.2 Scale limits vs coordinates\nThere are three basic reasons to scale the limits of plots:\n\nSet consistent x/y limits for multiple plots.\nZoom in on plots.\nAlter the default padding added to the x/y limits.\n\nEach of these can be achieved either through scale_x/y_*() functions or coord_*() functions. However, the scale and coord functions work very differently and have slightly different capabilities. See Chapter 20 for working with the coord_*() functions.\n\n\nscale_x_continuous(limits = c(180, 220)): Subsets data, all values outside the range become NA. This will lead to changes in the data for lines or polygons.\n\ncoord_cartesian(xlim = c(180, 220)): Visual zoom on the data, maintaining the same structure of the data.\n\n1. Setting consistent limits\nSetting x/y limits is a good way to ensure consistent scales across different plots as is done in faceted plots. scale_x/y_*(limits) provides a good way to expand the limits of certain plots to ensure consistent scales.\nNotice the very different x and y scales in the plots without setting limits…\ncol_scale &lt;- scale_color_discrete(limits = levels(penguins$species))\n\nadelie &lt;- penguins |&gt; \n  filter(species == \"Adelie\") |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             color = species)) + \n  geom_point() + \n  col_scale + \n  theme(legend.position = \"none\")\n\ngentoo &lt;- penguins |&gt; \n  filter(species == \"Gentoo\") |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             color = species)) + \n  geom_point() + \n  col_scale + \n  theme(legend.position = \"none\")\nadelie\ngentoo\n\n\n\n\n\n\n\n\n\n\n\n\n…compared to plots where consistent limits are set.\n\n# Find default scale with all data\nx_scale &lt;- range(penguins$flipper_length_mm)\ny_scale &lt;- range(penguins$body_mass_g)\n\nadelie + \n  lims(x = x_scale,\n       y = y_scale)\ngentoo + \n  xlim(x_scale) + \n  ylim(y_scale)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n2. Zooming\nThe preferred method for zooming in on a plot is to use coord_cartesian(xlim, ylim) because it does not subset the data. This can be seen by adding a model line. scale_x/y_*(limits) changes the data and, therefore, the model line.\n# Left: Zoomed\np + \n  geom_smooth() + \n  coord_cartesian(xlim = c(190, 210))\n\n# Right: Filtered\np + \n  geom_smooth() + \n  scale_x_continuous(limits = c(190, 210))\n#&gt; Warning: Removed 170 rows containing non-finite values (`stat_smooth()`).\n#&gt; Warning: Removed 170 rows containing missing values (`geom_point()`).\n\n\n\n\n\n\n\n\n\n\n\n\n3. Padding\nscale_x/y_*() and coord_*() are both useful for altering the padding added to the scale of plots, but they do different things.\n\n\nscale_x/y_*(expand): Alter padding on x and y axes.\n\ncoord_*(expand): Logical to turn on (default) or off padding.\n\nscale_x/y_*() with the expand argument and the expansion() convenience function changes the padding around the data through a percentage or addition. The defaults are to expand the scale by 5% on each side for continuous variables, and by 0.6 units on each side for discrete variables.\nRemove padding:\nPadding can be removed by setting scale_x/y_*(expand = expansion(0) or coord_cartesian(expand = FALSE). When removing padding completely, it may be beneficial to turn clip = \"off\" to allow points plotted outside the panel region so they are not cut in half.\np + \n  scale_x_continuous(\n    expand = expansion(0)) + \n  scale_y_continuous(\n    expand = expansion(0))\np + \n  coord_cartesian(\n    expand = FALSE,\n    clip = \"off\"\n    )\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAltering padding:\nexpansion() takes vectors of length 1 or 2 to either multiply (mult) or add (add) to the lower and upper limits of the scale. The below code adds ten units to the lower and upper bounds of the x scale and removes all padding from the lower bound of the y scale (multiplies by 0) and expands the upper bound of the y scale by 10%.\n\np + \n  scale_x_continuous(expand = expansion(add = 10)) + \n  scale_y_continuous(expand = expansion(mult = (c(0, 0.1))))",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>Position scales</span>"
    ]
  },
  {
    "objectID": "02-scales-color.html",
    "href": "02-scales-color.html",
    "title": "18  Color scales",
    "section": "",
    "text": "18.1 Resources\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(dplyr)\nlibrary(palmerpenguins)\n\n# Data\npenguins &lt;- penguins |&gt; \n  filter(!is.na(flipper_length_mm),\n         !is.na(sex)) |&gt; \n  # Add factor data that has more levels\n  mutate(species_sex = as.factor(\n    paste(species, sex)))\nBase plots\nCodepcont &lt;- penguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             color = bill_depth_mm)) + \n  geom_point(size = 2) + \n  labs(color = \"Bill depth\")\n\npdisc &lt;- penguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             color = species_sex)) + \n  geom_point(size = 2)",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Color scales</span>"
    ]
  },
  {
    "objectID": "02-scales-color.html#sec-color-resources",
    "href": "02-scales-color.html#sec-color-resources",
    "title": "18  Color scales",
    "section": "",
    "text": "Scales documentation\nggplot2 Cheatsheet: Scales\nscales package: color\nWickham, ggplot2 Book: Color scales\nR for Data Science: Communication, Scales\n\nCédric Scherer, Graphic Design with ggplot2 at RStudio conf 2022: Working with colors\n\nSee the notes on the workshop\n\n\n\n\nZeileis and Murrell, “Coloring in R’s Blind Spot”1",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Color scales</span>"
    ]
  },
  {
    "objectID": "02-scales-color.html#sec-color-fns",
    "href": "02-scales-color.html#sec-color-fns",
    "title": "18  Color scales",
    "section": "\n18.2 Color functions",
    "text": "18.2 Color functions\nThe default color scales are provided to quickly choose a palette type. To manually set colors it is better to use the lower-level functions designed for creating color scales. ggplot2 also provides functions to use the popular Color brewer and Viridis sets of color palettes that are designed for discrete and continuous scales respectively.\n\n18.2.1 Default color scales\n\nContinuous scales: type is “gradient” or “viridis”\n\nscale_color_continuous()\nscale_fill_continuous()\n\n\nBinned scales: type is “gradient” or “viridis”\n\nscale_color_binned()\nscale_fill_binned()\n\n\nDiscrete scales: type is scale_fill_hue() or scale_color_brewer()\n\nscale_color_discrete()\nscale_fill_discrete()\n\n\n\n18.2.2 Creating color scales\n\nContinuous scales: Gradient\n\n\nscale_color_gradient(): produces a two-color sequential gradient.\n\nscale_color_gradient2(): produces a three-color diverging gradient with specified midpoint.\n\nscale_color_gradientn(): produces an n-color gradient. Used to transform a discrete color palette—often from a color palette package—to a continuous color palette.\n\n\nBinned scales: Binned variants of gradient scales that work in the same way\n\nscale_color_steps()\nscale_color_steps2()\nscale_color_stepsn()\n\n\nDiscrete scales\n\nscale_color_hue()\nscale_color_grey(start = 0.2, end = 0.8)\n\n\nManual scales\n\nscale_color_manual()\n\n\nIdentity scales\n\nscale_color_identity()\n\n\n\n18.2.3 Color brewer scales\nColor brewer: sequential, diverging and qualitative color schemes designed for use on discrete values on a map. They are designed for discrete scales.\n\nStandard discrete color brewer scales\n\nscale_color_brewer()\nscale_fill_brewer()\n\n\nContinuous scale\n\nscale_color_distiller()\nscale_fill_distiller()\n\n\nBinned scale\n\nscale_color_fermenter()\nscale_fill_fermenter()\n\n\nTypes of scales: type\n\n“seq” (sequential), “div” (diverging), or “qual” (qualitative)\n\n\nPalettes: palette\n\n\nDiverging: BrBG, PiYG, PRGn, PuOr, RdBu, RdGy, RdYlBu, RdYlGn, Spectral\n\nQualitative: Accent, Dark2, Paired, Pastel1, Pastel2, Set1, Set2, Set3\n\nSequential: Blues, BuGn, BuPu, GnBu, Greens, Greys, Oranges, OrRd, PuBu, PuBuGn, PuRd, Purples, RdPu, Reds, YlGn, YlGnBu, YlOrBr, YlOrRd\n\n\n\n18.2.4 Viridis scales\nThe viridis scales provide color palettes that are perceptually uniform in both color and black-and-white. They are also designed to be perceived by viewers with common forms of color blindness. They are particularly good for continuous scales.\n\nContinuous scales\n\nscale_color_viridis_c()\nscale_fill_viridis_c()\n\n\nBinned scales\n\nscale_color_viridis_b()\nscale_fill_viridis_b()\n\n\nDiscrete scales\n\nscale_color_viridis_d()\nscale_fill_viridis_d()\n\n\nPalette options: option\n\n“magma” (or “A”), “inferno” (or “B”), “plasma” (or “C”), “viridis” (or “D”), “cividis” (or “E”), “rocket” (or “F”), “mako” (or “G”), “turbo” (or “H”)",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Color scales</span>"
    ]
  },
  {
    "objectID": "02-scales-color.html#sec-color-scale-types",
    "href": "02-scales-color.html#sec-color-scale-types",
    "title": "18  Color scales",
    "section": "\n18.3 ggplot2 color scales",
    "text": "18.3 ggplot2 color scales\nColors have the same types of scales as the other scales: continuous, binned, discrete, manual, identity and date.\n\n18.3.1 Continuous color scales\nDefault continuous scale\nThe default scale for continuous color scales is scale_color_continuous(), which defaults to using scale_color_gradient().\npcont + \n  scale_color_continuous()\n\npcont + \n  scale_color_gradient()\n\n\n\n\n\n\n\n\n\n\n\n\nGradient continuous scales\nTo create your own continuous color scale use the gradient functions. There are three gradient functions that create two-color sequential, diverging, and n-color gradients.\nscale_color_gradient() takes colors for the low and high values to create a gradient sequentially moving from one color to the other.\n\npcont + \n  scale_color_gradient(\n    low = \"#E5940E\",\n    high = \"#454B87\"\n  )\n\n\n\n\n\n\n\nscale_color_gradient2() adds an argument for mid to create a midpoint to be used in a diverging scale and midpoint for the value used as the middle of the scale. midpoint defaults to 0, so you will likely need to specify it. The default uses a muted red and blue for low and high values and white for the midpoint.\n\npcont + \n  scale_color_gradient2(\n    midpoint = mean(penguins$bill_depth_mm))\n\n\n\n\n\n\n\nCreate your own diverging gradient by providing low, mid, and high.\n\npcont + \n  scale_color_gradient2(\n    low = \"#E5940E\",\n    mid = \"white\",\n    high = \"#454B87\",\n    midpoint = mean(penguins$bill_depth_mm)\n  )\n\n\n\n\n\n\n\nscale_color_gradientn() creates an n-colored gradient. The function needs a vector of colors to work, and the colors argument must be named. You can provide your own color palette, a palette using the scales::*_pal() functions, a base R color palette, or one from a color palette package. When using predefined color palettes, the colors used for the gradient may change depending on the number of colors used to create the palette if the palette is dynamic. For instance, notice the difference in the gradient created with 6 vs 25 terrain colors: the changes across the gradient are more subtle with 25 colors.\n# 6 terrain color gradient\npcont + \n  scale_color_gradientn(\n    colors = terrain.colors(6))\n# 25 terrain color gradient\npcont + \n  scale_color_gradientn(\n    colors = terrain.colors(25))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nscale_color_gradientn() is important for transforming a discrete palette into a continuous palette. This makes it the primary way to use color packages with a continuous color scale.\nColor brewer continuous scales\nscale_color_distiller() provides continuous color scales using the Color Brewer palettes that are designed for discrete data. Use the type argument to choose between sequential \"seq\", diverging \"div\", and qualitative \"qual\" palettes. This is a quick way to choose the default palette for each type and can be used with the numerical manner for choosing a palette. Or just write the name of the palette in the palette argument.\nSequential\n\npcont + \n  scale_color_distiller()\n\n\n\n\n\n\n\nDiverging\n\npcont + \n  scale_color_distiller(palette = \"PuOr\")\n\n\n\n\n\n\n\nQualitative: n-gradient\n\npcont + \n  scale_color_distiller(palette = \"Set1\")\n\n\n\n\n\n\n\nViridis continuous scales\nThe viridis colors are the most well suited to a continuous scale among the built in ggplot2 color scales. They are designed to be perceptually uniform in both color and when reduced to black and white, and to be perceptible to people with various forms of color blindness.\nYou can access the viridis palette from scale_color_continuous()\n\npcont + \n  scale_color_continuous(type = \"viridis\")\n\n\n\n\n\n\n\nOr use scale_color_viridis_c(), which provides more options, including the ability to choose among the 8 viridis palettes.\npcont + \n  scale_color_viridis_c()\npcont + \n  scale_color_viridis_c(option = \"A\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDate color scales\nscale_color_date() is a special form of continuous color scales. It is only different in that it provides access to the date_breaks and date_labels arguments used in date scales as discussed in Section 17.5.2.6.\n\n18.3.2 Binned color scales\nBinned color scales take continuous data and map them into bins. The default binned color scale is scale_color_binned(), which in turn defaults to scale_color_steps(). The scale_color_steps() family of functions are analogous to the scale_color_gradient() family of functions other than providing a n.breaks argument from binned scales. Another difference from gradients is the use of the colorsteps style legend instead of colorbar.\nDefault binned scale\n\npcont + \n  scale_color_binned()\n\n\n\n\n\n\n\nColor steps\nUse the scale_color_steps() functions to get sequential, diverging, and qualitative bins.\nSequential\n\npcont + \n  scale_color_steps(\n    low = \"#E5940E\",\n    high = \"#454B87\"\n  )\n\n\n\n\n\n\n\nDiverging\n\npcont + \n  scale_color_steps2(\n    n.breaks = 8,\n    low = \"#E5940E\",\n    mid = \"white\",\n    high = \"#454B87\",\n    midpoint = mean(penguins$bill_depth_mm)\n  )\n\n\n\n\n\n\n\nQualitative\nAs with scale_color_gradientn() the number of colors used to create the palette may change the colors used for the bins.\n\npcont + \n  scale_color_stepsn(\n    colors = terrain.colors(6)\n  )\n\n\n\n\n\n\n\nViridis and color brewer\nThe binned versions of the viridis and color brewer palettes work in the same way as scale_color_steps() with the n.breaks argument and their continuous variants.\nColor brewer\nscale_color_fermenter() has the same ability to pick a type and palette:\n\npcont + \n  scale_color_fermenter(palette = \"Oranges\")\n\n\n\n\n\n\n\nViridis\nscale_color_viridis_b() has the same ability to pick a palette option:\n\npcont + \n  scale_color_viridis_b(option = \"A\")\n\n\n\n\n\n\n\n\n18.3.3 Discrete color scales\nDefault discrete scale\nThe default scale for discrete color scales is scale_color_discrete(), which defaults to using scale_color_hue().\npdisc + \n  scale_color_discrete()\npdisc + \n  scale_color_hue()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUse scales::hue_pal() to recreate or access the discrete color palette used for a plot. Making sure to use the length of the discrete colors, as the colors used changes with the length of the palette.\n\n# Palette used for pdisc\nscales::hue_pal()(6)\n#&gt; [1] \"#F8766D\" \"#B79F00\" \"#00BA38\" \"#00BFC4\" \"#619CFF\" \"#F564E3\"\nshow_col(scales::hue_pal()(6))\n\n\n\n\n\n\n\nThis can be used with scale_color_manual() to color a subset of the groups. See the discussion in Annotations: Highlighting and below Section 18.3.4.\nHCL color scale\nscale_color_hue() provides access to HCL colors directly within ggplot2. The default color scheme picks evenly spaced hues around the HCL color wheel. The functions do not produce color blind compatible palettes.\n\n\nHue: Color on a range from 0 to 360 (an angle).\n\nChroma: Purity of a color, ranging from 0 (grey) to a maximum that varies with luminance.\n\nLuminance: Lightness of the color, ranging from 0 (black) to 1 (white).\n\nscale_color_hue() provides arguments to customize each of these aspects:\n\n\nh: Range of hues to use between 0 and 360; default is c(0, 360) + 15\n\n\nh.start: What hue to start at. This can affect the colors, or just the order of the colors if the angle chosen is a product of the number of discrete variables divided by 360. For instance, pdisc has six levels, so h.start = 60 uses the same colors as the default but moves the order of the colors up one. On the other hand, h.start = 45 changes the colors used because 45 x 6 is not 360.\n\nc: Chroma value; default is 100. Higher values leader to brighter colors, lower values lead to more muted colors.\n\nl: Lightness of the color from 0 to 100; default is 65. Higher values lead to more white, light colors, lower values lead to darker colors.\n\nHue: compare using only the third-fourth of the color wheel (left) to the default that uses all of it (right).\n# Use smaller part of wheel\npdisc + \n  scale_color_hue(h = c(180, 270))\n# Default: whole wheel\npdisc + \n  scale_color_hue()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nh.start: compare changing the order of the colors (left) to changing the colors used (right).\n# Move order of colors up 1\npdisc + \n  scale_color_hue(h.start =  60)\n# Change colors used\npdisc + \n  scale_color_hue(h.start = 30)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nChroma: compare the muted colors with a lower chroma (left) to the almost neon colors with a higher chroma (right).\n# Low chroma: Muted\npdisc + \n  scale_color_hue(c = 50)\n# High chroma: Bright\npdisc + \n  scale_color_hue(c = 150)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLightness: compare the darker colors with lower lightness (left) to the brighter pastel-like colors with higher lightness (right).\n# Lower l: Dark\npdisc + \n  scale_color_hue(l = 40)\n# Higher l: Light\npdisc + \n  scale_color_hue(l = 85)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGray color scale\nscale_color_hue() uses colors that have the same chroma (c) and luminance (l) and so they appear as the same shade of gray when printed in black and white. If you are making plots that will be in black and white it is best to use scale_color_grey() (note the British spelling), which is base on gray.colors(). The main arguments are start and end: limits on a scale of 0 (black) to 1 (white); the defaults are start = 0.2 and end = 0.8. It is probably best not to use a gray background.\n\npdisc + \n  scale_color_grey(start = 0, end = 0.7) + \n  theme_minimal()\n\n\n\n\n\n\n\nColor brewer and viridis\nWhereas the viridis palettes are best suited for continuous scales, color brewer is designed specifically for discrete scales. For ordered discrete values the sequential (“seq”) palettes are useful, while unordered categorical data is best visualized with the qualitative (“qual”) palettes. “Set1” and “Dark2” are particularly good for points, and “Set2”, “Pastel1”, “Pastel2” and “Accent” work well for areas.\n\npdisc + \n  scale_color_brewer(palette = \"Dark2\")\n\n\n\n\n\n\n\nscale_color_viridis_d() provides the same set of viridis palettes in a discrete scale:\n\npdisc + \n  scale_color_viridis_d()\n\n\n\n\n\n\n\n\n18.3.4 Manual and identity scales\nManually setting colors for discrete data can be useful if you want to quickly create your own palette, or if you want to choose colors that have a specific relationship to the data, such as blue for democrat and red for republican in a voting map. For instance, you can group together the penguin species with similar colors and use darker colors for male and lighter for female.\nThe colors are chosen using the values argument which can either be a vector of colors or a named vector of colors that corresponds to the levels of the data. scale_color_manual() is the primary way within the ggplot2 package to get access to discrete palettes provided by other color packages: scale_color_manual(values = palette), see Section 18.5.\n\npdisc + \n  scale_color_manual(\n    values = c(\"chocolate\", \"chocolate1\",\n               \"dodgerblue4\", \"dodgerblue\",\n               \"seagreen\", \"seagreen3\")\n  )\n\n\n\n\n\n\n\nA named vector makes the color mapping more clear. This can be done outside or inside the scale_color_manual() function.\n\npdisc + \n  scale_color_manual(\n    values = c(\n      \"Adelie female\"    = \"chocolate\",\n      \"Adelie male\"      = \"chocolate1\",\n      \"Chinstrap female\" = \"dodgerblue4\",\n      \"Chinstrap male\"   = \"dodgerblue\",\n      \"Gentoo female\"    = \"seagreen\",\n      \"Gentoo male\"      = \"seagreen3\")\n  )\n\n\n\n\n\n\n\nA common workflow for using scale_color_manual() is to color a subset of discrete groups using the same color scale that would be used for all groups. This is the basis for highlighting groups or certain instances shown in Annotations: Highlighting. This is done by taking a subset of the discrete palette constructor scales::hue_pal() discussed in Section 18.3.3. For instance, we can color only the male penguins but maintain the same color palette as used in pdisc. Compare the use of the default palette to maintaining the palette used when there are six groups.\n\n# Default discrete scale\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  geom_point(color = \"gray60\") + \n  geom_point(data = filter(penguins, sex == \"male\"),\n             aes(color = species)) + \n  labs(color = \"Males\")\n\n\n\n\n\n\n\n\n# Use same color scale as pdisc\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  geom_point(color = \"gray60\") + \n  geom_point(data = filter(penguins, sex == \"male\"),\n             aes(color = species)) + \n  scale_color_manual(\"Males\",\n                     values = scales::hue_pal()(6)[c(2, 4, 6)])\n\n\n\n\n\n\n\nscale_color_identity() works similarly, but the colors to be used are in the data frame.",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Color scales</span>"
    ]
  },
  {
    "objectID": "02-scales-color.html#sec-color-guides",
    "href": "02-scales-color.html#sec-color-guides",
    "title": "18  Color scales",
    "section": "\n18.4 Labels, breaks, and legends",
    "text": "18.4 Labels, breaks, and legends\nJust as with the scales described in Chapter 19 you can change the breaks and labels of scales and how they are expressed in legends using the scale_color_*() functions. For more on the look of legends, see Section 21.4.2 on choosing the type of legend and Section 21.8.2 for styling color legends.\nChange the breaks and reverse the colorbar.\n\npcont + \n  scale_color_continuous(breaks = c(15, 17, 21),\n                         guide = guide_colorbar(reverse = TRUE))\n\n\n\n\n\n\n\nCreate a legend that only shows the colors of females of the three species.\n\npdisc + \n  scale_color_discrete(\n    \"Females\",\n    breaks = c(\"Adelie female\", \"Chinstrap female\", \"Gentoo female\"),\n    labels = c(\"Adelie\", \"Chinstrap\", \"Gentoo\")\n  )",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Color scales</span>"
    ]
  },
  {
    "objectID": "02-scales-color.html#sec-color-pkgs",
    "href": "02-scales-color.html#sec-color-pkgs",
    "title": "18  Color scales",
    "section": "\n18.5 Color palette packages",
    "text": "18.5 Color palette packages\n\npalettes\ncolorspace\nscico\nggsci\nggthemes\nrcartocolor\nMetBrewer\npaletteer\n\nLoad packages\n\nCodelibrary(colorspace)\nlibrary(scico)\nlibrary(ggsci)\nlibrary(ggthemes)\nlibrary(rcartocolor)\nlibrary(MetBrewer)\nlibrary(paletteer)\nlibrary(palettes)\n\n\n\n18.5.1 Overview\nMost color palette packages have two main types of functions: scale functions that are usually named scale_color_*() and are meant to replace the ggplot2 scale functions and pal functions that provide access to the hex values of palettes that can then be used with scale_color_manual() or scale_color_gradientn() to create a continuous palette. The API for accessing these functions differs. This has led to the creation of paletteer (Section 18.5.11) to try to create a common interface for palettes.\nMost of the color packages have functions to list the name of the available palettes and to view the palettes as a plot. A particularly useful way to view a palette before using it is with scales::show_col().\n\n18.5.2 palettes pkg\nA fun, quick alternative to scales::show_col() is to use the palettes package, which uses vctrs to print vectors of colors as hex rbg values with a color preview. palettes has its own way to access color palettes in ggplot2, but it is particularly useful for printing out a vector of colors with pal_color().\n\npal_color(\n  c(\"#a00e00\", \"#d04e00\", \"#f6c200\", \"#0086a8\", \"#132b69\")\n)\n#&gt; &lt;palettes_colour[5]&gt;\n#&gt; • #A00E00\n#&gt; • #D04E00\n#&gt; • #F6C200\n#&gt; • #0086A8\n#&gt; • #132B69\n\n\n18.5.3 Scales pkg\nscales provides a number of functions to specify palettes and perform color mapping that provide the basis for the color scale functions in ggplot2. The *_pal() functions have consistent APIs with their associated scale_color_*() variants in ggplot2. The *_pal() functions all return a function. Thus, to access the hex color values you need to add another set of parentheses: discrete palettes take an n, while continuous palettes take a vector of values from 0 to 1 that produce length(x) colors.\nOnce you have a palette, you can view the colors with scales::show_col(). This provides a good workflow to view the color palette and make any changes you want.\nDiscrete palettes\n\nbrewer_pal()\nviridis_pal()\nhue_pal()\ngrey_pal()\n\ndichromat_pal(): color-blind discrete palettes\n\nDiscrete palette constructors use the form *_pal()(n):\n\nbrewer_pal(palette = \"Oranges\")(9)\n#&gt; [1] \"#FFF5EB\" \"#FEE6CE\" \"#FDD0A2\" \"#FDAE6B\" \"#FD8D3C\" \"#F16913\" \"#D94801\"\n#&gt; [8] \"#A63603\" \"#7F2704\"\nshow_col(brewer_pal(palette = \"Oranges\")(9))\n\n\n\n\n\n\n\nhue_pal() and show_col() provide a good way to play around with HCL colors and see what changes to hue, chroma, and luminance does.\nshow_col(hue_pal()(9))\nshow_col(hue_pal(h = c(0, 120))(9))\nshow_col(hue_pal(c = 60)(9))\nshow_col(hue_pal(l = 90)(9))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ngrey_pal() is the same as grey.colors() though it uses different starting and ending points.\nshow_col(grey_pal()(16))\nshow_col(grey.colors(16, 0.2, 0.8))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nContinuous palettes\n\nseq_gradient_pal()\ndiv_gradient_pal()\ngradient_n_pal()\n\nContinuous palette constructors use the form *_pal()(seq(0, 1, length.out = n)). Like their scale_color_*() variants, these functions take 2, 3, or n colors and create a continuous scale.\nCreate a vector of n values:\n\nx &lt;- seq(0, 1, length.out = 16)\n\nCreating sequential and divergent gradients:\nshow_col(\n  seq_gradient_pal(\n    \"#E5940E\", \"#454B87\"\n    )(x))\nshow_col(\n  div_gradient_pal(\n    \"#E5940E\", \"white\", \"#454B87\"\n    )(x))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLike its scale variant, gradient_n_pal() is useful for taking a discrete palette and turning it into a continuous palette. For instance, you can take colors from a Color Brewer palette and turn it into a continuous scale with many more colors.\n# Discrete diverging scale\ncols &lt;- brewer_pal(\"div\")(9)\nshow_col(cols)\n# Continuous diverging scale\nshow_col(\n  gradient_n_pal(cols)(x))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis process shows an approximation of the colors that would be used in a continuous scale with the scale_color_gradient*() functions. Thus, you can replicate scale_color_distiller() with slightly different colors, as scale_color_distiller() has more colorful values towards the middle. The only other change is that scale_color_distiller() uses direction = -1.\npcont + \n  scale_color_gradientn(\n    colors = cols)\npcont + \n  scale_color_distiller(\n    palette = \"BrBG\", direction = 1)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n18.5.4 Base color palettes\nR comes with a number of base color palettes. On the changes in base color palettes from R 3.6 and 4.0 see:\n\nZeileis and Murrell, “Coloring in R’s Blind Spot”\nHCL-Based Color Palettes in grDevices\nA New palette() for R\n\nPost R 4.0 palettes\n\n\npalette(): Default discrete R palette of 8 colors “R4”\n\npalette.colors(n, palette): Access to a set of discrete palettes; default is “Okabe-Ito”\n\n\npalette.pals(): Vector of palette names to use in palette.colors().\n\n\n\nhcl.colors(n, palette): Continuous hcl color palettes; default is “viridis”\n\n\nhcl.pals(): Vector of 115 continuous color palettes\n\n\n\nOlder palettes\n\nrainbow()\nheat.colors()\nterrain.colors()\ntopo.colors()\ncm.colors()\ngray.colors()\n\nDiscrete palettes\nThe default palette in R after R 4.0 is “R4”.\n\nshow_col(palette())\n\n\n\n\n\n\n\npalette.colors(n, palette) provides access to a range of discrete palettes that are listed with palette.pals(). The default palette is “Okabe-Ito”. Several palettes comes from Color Brewer, see Section 18.2.3.\n\npalette.pals()\n#&gt;  [1] \"R3\"              \"R4\"              \"ggplot2\"         \"Okabe-Ito\"      \n#&gt;  [5] \"Accent\"          \"Dark 2\"          \"Paired\"          \"Pastel 1\"       \n#&gt;  [9] \"Pastel 2\"        \"Set 1\"           \"Set 2\"           \"Set 3\"          \n#&gt; [13] \"Tableau 10\"      \"Classic Tableau\" \"Polychrome 36\"   \"Alphabet\"\n\nshow_col(\n  palette.colors())\nshow_col(\n  palette.colors(palette = \"Pastel 1\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou can change the defualt palette used by R by passing one of the palettes to the palette() function: palette(\"Okabe-Ito\").\nhcl.colors() has 9 discrete color palettes that vary only in hue and have the same chroma and luminance. The first 5 palettes are derived from Color Brewer and are similar to the palettes present in palette.colors(). These are all very neutral palettes.\n\n# Qualitative palettes\nhcl.pals(\"qualitative\")\n#&gt; [1] \"Pastel 1\" \"Dark 2\"   \"Dark 3\"   \"Set 2\"    \"Set 3\"    \"Warm\"     \"Cold\"    \n#&gt; [8] \"Harmonic\" \"Dynamic\"\nshow_col(hcl.colors(9, palette = \"Pastel 1\"))\n\n\n\n\n\n\n\nContinuous palettes\nhcl.colors() is a simplified implementation of the color palettes from the colorspace package, see Section 18.5.5. This means that you can use the colorspace package to use these palettes directly in ggplot2.\nhcl.colors() does not select from a fixed set of colors but provides a specific path in the HCL color space. For hue, chroma, and luminance a color palette can have either a constant, linear, or triangular trajectory within the HCL values. The default is viridis:\n\nshow_col(hcl.colors(9))\n\n\n\n\n\n\n\nhcl.colors() has single hue, multi-hue, diverging, and divergingx palettes which can be listed with “qualitative”, “sequential”, “diverging”, or “divergingx” in hcl.pals().\nThe single hue are all inspired by Color Brewer except Oslo, which is from the scico package.\n\n# Single hue palettes\nhcl.pals()[10:20]\n#&gt;  [1] \"Grays\"       \"Light Grays\" \"Blues 2\"     \"Blues 3\"     \"Purples 2\"  \n#&gt;  [6] \"Purples 3\"   \"Reds 2\"      \"Reds 3\"      \"Greens 2\"    \"Greens 3\"   \n#&gt; [11] \"Oslo\"\nshow_col(hcl.colors(9, \"reds 3\"))\n\n\n\n\n\n\n\nThe multi-hue palettes are similar to those from colorspace, viridis, rcartocolor, and scico.\n\n# Multi-hue palettes\nhcl.pals()[21:79]\n#&gt;  [1] \"Purple-Blue\"   \"Red-Purple\"    \"Red-Blue\"      \"Purple-Orange\"\n#&gt;  [5] \"Purple-Yellow\" \"Blue-Yellow\"   \"Green-Yellow\"  \"Red-Yellow\"   \n#&gt;  [9] \"Heat\"          \"Heat 2\"        \"Terrain\"       \"Terrain 2\"    \n#&gt; [13] \"Viridis\"       \"Plasma\"        \"Inferno\"       \"Rocket\"       \n#&gt; [17] \"Mako\"          \"Dark Mint\"     \"Mint\"          \"BluGrn\"       \n#&gt; [21] \"Teal\"          \"TealGrn\"       \"Emrld\"         \"BluYl\"        \n#&gt; [25] \"ag_GrnYl\"      \"Peach\"         \"PinkYl\"        \"Burg\"         \n#&gt; [29] \"BurgYl\"        \"RedOr\"         \"OrYel\"         \"Purp\"         \n#&gt; [33] \"PurpOr\"        \"Sunset\"        \"Magenta\"       \"SunsetDark\"   \n#&gt; [37] \"ag_Sunset\"     \"BrwnYl\"        \"YlOrRd\"        \"YlOrBr\"       \n#&gt; [41] \"OrRd\"          \"Oranges\"       \"YlGn\"          \"YlGnBu\"       \n#&gt; [45] \"Reds\"          \"RdPu\"          \"PuRd\"          \"Purples\"      \n#&gt; [49] \"PuBuGn\"        \"PuBu\"          \"Greens\"        \"BuGn\"         \n#&gt; [53] \"GnBu\"          \"BuPu\"          \"Blues\"         \"Lajolla\"      \n#&gt; [57] \"Turku\"         \"Hawaii\"        \"Batlow\"\nshow_col(hcl.colors(9, \"Lajolla\"))\n\n\n\n\n\n\n\nThe diverging palettes use contrasting colors on the extremes with either light gray or yellow at the center. The palettes are similar to those from colorspace, rcartocolor, and scico. There are also flexible diverging palettes that do not have restrictions on balancing the ends and can go through other colors in the middle.\n\n# Diverging palettes\nhcl.pals()[80:115]\n#&gt;  [1] \"Blue-Red\"      \"Blue-Red 2\"    \"Blue-Red 3\"    \"Red-Green\"    \n#&gt;  [5] \"Purple-Green\"  \"Purple-Brown\"  \"Green-Brown\"   \"Blue-Yellow 2\"\n#&gt;  [9] \"Blue-Yellow 3\" \"Green-Orange\"  \"Cyan-Magenta\"  \"Tropic\"       \n#&gt; [13] \"Broc\"          \"Cork\"          \"Vik\"           \"Berlin\"       \n#&gt; [17] \"Lisbon\"        \"Tofino\"        \"ArmyRose\"      \"Earth\"        \n#&gt; [21] \"Fall\"          \"Geyser\"        \"TealRose\"      \"Temps\"        \n#&gt; [25] \"PuOr\"          \"RdBu\"          \"RdGy\"          \"PiYG\"         \n#&gt; [29] \"PRGn\"          \"BrBG\"          \"RdYlBu\"        \"RdYlGn\"       \n#&gt; [33] \"Spectral\"      \"Zissou 1\"      \"Cividis\"       \"Roma\"\nshow_col(hcl.colors(9, \"TealRose\"))\n\n\n\n\n\n\n\n\n18.5.5 colorspace\nThe colorspace package provides a broad toolbox for selecting individual colors or color palettes, manipulating these colors, and employing them in various kinds of visualizations. As noted above, a simplified version of the color palettes from the package have been implemented in base R with hcl.colors(). The package provides three types of palettes: qualitative, sequential, and diverging. The package also provides tools for mapping HCL color space to hex values and other color representations, as well as tools to visualize and manipulate color palettes.\nHCL color palettes\nHCL color palettes\nUse hcl_palettes() to access the palettes provided by colorspace. These are the same palettes as provided by base R with hcl.colors(), see Section 18.5.4. The main difference is that hcl.colors() does not have the ability to modify the existing palettes through the h, c, and l arguments in the palette functions.\n\n\nhcl_palettes(plot = TRUE): View a plot of the palettes.\n\nhclwizard(): shiny app to view and play around with the palettes.\n\nMany of the palettes are similar to those provided by other packages such as Color Brewer, Viridis, rcartocolors, and scico. See the vignette for a discussion and visualizations of the comparisons.\n\nhcl_palettes()\n#&gt; HCL palettes\n#&gt; \n#&gt; Type:  Qualitative \n#&gt; Names: Pastel 1, Dark 2, Dark 3, Set 2, Set 3, Warm, Cold, Harmonic, Dynamic\n#&gt; \n#&gt; Type:  Sequential (single-hue) \n#&gt; Names: Grays, Light Grays, Blues 2, Blues 3, Purples 2, Purples 3, Reds 2,\n#&gt;        Reds 3, Greens 2, Greens 3, Oslo\n#&gt; \n#&gt; Type:  Sequential (multi-hue) \n#&gt; Names: Purple-Blue, Red-Purple, Red-Blue, Purple-Orange, Purple-Yellow,\n#&gt;        Blue-Yellow, Green-Yellow, Red-Yellow, Heat, Heat 2, Terrain,\n#&gt;        Terrain 2, Viridis, Plasma, Inferno, Rocket, Mako, Dark Mint,\n#&gt;        Mint, BluGrn, Teal, TealGrn, Emrld, BluYl, ag_GrnYl, Peach,\n#&gt;        PinkYl, Burg, BurgYl, RedOr, OrYel, Purp, PurpOr, Sunset,\n#&gt;        Magenta, SunsetDark, ag_Sunset, BrwnYl, YlOrRd, YlOrBr, OrRd,\n#&gt;        Oranges, YlGn, YlGnBu, Reds, RdPu, PuRd, Purples, PuBuGn, PuBu,\n#&gt;        Greens, BuGn, GnBu, BuPu, Blues, Lajolla, Turku, Hawaii, Batlow\n#&gt; \n#&gt; Type:  Diverging \n#&gt; Names: Blue-Red, Blue-Red 2, Blue-Red 3, Red-Green, Purple-Green,\n#&gt;        Purple-Brown, Green-Brown, Blue-Yellow 2, Blue-Yellow 3,\n#&gt;        Green-Orange, Cyan-Magenta, Tropic, Broc, Cork, Vik, Berlin,\n#&gt;        Lisbon, Tofino\ndivergingx_palettes() \n#&gt; HCL palettes\n#&gt; \n#&gt; Type:  Diverging (flexible) \n#&gt; Names: ArmyRose, Earth, Fall, Geyser, TealRose, Temps, Tropic, PuOr, RdBu,\n#&gt;        RdGy, PiYG, PRGn, BrBG, RdYlBu, RdYlGn, Spectral, Zissou 1,\n#&gt;        Cividis, Roma\n\nAccess the palettes by using the palette function that corresponds to the type of palette you desire:\n\nqualitative_hcl()\nsequential_hcl()\ndiverging_hcl()\ndivergingx_hcl()\n\nshow_col(\n  qualitative_hcl(9,\n    palette = \"Pastel 1\"))\nshow_col(\n  diverging_hcl(9,\n    palette = \"Berlin\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe palette functions also have arguments to alter h, c, and l to modify the palettes. This functionality is not available through the base R hcl.colors() function.\nggplot2 scales\n\nContinuous\n\nscale_color_continuous_qualitative()\nscale_color_continuous_sequential()\nscale_color_continuous_diverging()\nscale_color_continuous_divergingx()\n\n\nBinned\n\nscale_color_binned_qualitative()\nscale_color_binned_sequential()\nscale_color_binned_diverging()\nscale_color_binned_divergingx()\n\n\nDiscrete\n\nscale_color_discrete_qualitative()\nscale_color_discrete_sequential()\nscale_color_discrete_diverging()\nscale_color_discrete_divergingx()\n\n\n\npcont + \n  scale_color_continuous_sequential(\n    \"Lajolla\")\npdisc + \n  scale_color_discrete_qualitative(\n    \"Dark 3\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe nmax and order arguments in the discrete scales allow you to choose which colors to use.\n\npdisc + \n  scale_color_discrete_qualitative(\n    \"Dark 3\",\n    nmax = 8,\n    order = c(8, 6, 3:5, 1))\n\n\n\n\n\n\n\nYou can use this to remove the lightest colors in sequential palettes:\n\npdisc + \n  scale_color_discrete_sequential(\n    \"Blues\", nmax = 8, order = 3:8)\n\n\n\n\n\n\n\nLike the palette functions, you can also change the h1, c1, and l1 and h2, c2, and l2 arguments for the starting and ending values. In addition, the continuous scale functions have arguments for begin and end that indicate where to begin and end on the color scale from 0 to 1.\nPalette visualization and assessment\nUse swatchplot() to view color palettes similar to scales::show_col().\n\nswatchplot(\n  sequential_hcl(8, h = c(0, 300), c = c(60, 60), l = 65)\n  )\n\n\n\n\n\n\n\nCompare multiple palettes:\n\nswatchplot(\n  \"Qualitative\" = qualitative_hcl(6, palette = \"Dark 3\"),\n  \"Sequential\"  = sequential_hcl(6, palette = \"Purples 2\"),\n  \"Diverging\"   = diverging_hcl(6, palette = \"Tropic\"),\n  off = 0\n)\n\n\n\n\n\n\n\nShow palette with common types of color blindness with cvd = TRUE:\n\nswatchplot(\n  sequential_hcl(8, palette = \"Sunset\"),\n  cvd = TRUE\n)\n\n\n\n\n\n\n\nAlternatively, use spec_plot() to see the hue, chroma, and luminance coordinates of a palette. Hue is shown in red with an axis of -360 to 360 on the right, chroma is in green, and luminance in blue both of which have an axis of 0 to 100 on the left. These plots do a good job of showing the structure of the different palettes. For instance, a sequential plot maintains the same hue (color) but changes chroma and luminance in an inverse relationship. A multi-hue sequential palette will often have a triangular path in chroma. On the other hand, a qualitative palette like “Set 2” goes through the spectrum of colors while maintaining mostly stable chroma and luminance. A diverging palette such as “Blue-Red” replicates the sequential plot from two different sides,\n# Sequential\nspecplot(sequential_hcl(\n  25, \"Blues 2\"))\n# Multi-hue sequential\nspecplot(sequential_hcl(\n  25, \"La Jolla\"))\n# Qualitative\nspecplot(qualitative_hcl(\n  25, \"Set 2\"))\n# Diverging\nspecplot(diverging_hcl(\n  25, \"Blue-Red\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nColor manipulation and utilities\ncolorspace has tools to manipulate color palettes, particularly to desaturate, lighten, or darken them. Desaturation removes the chroma or color of a palette, turning it into a gray scale. Lightening and darkening use an algorithm to try to lighten or darken colors while maintaining correspondence in how they look.\n\n\ndesaturate(): Desaturate colors by chroma removal in HCL space to turn into gray scale.\n\nlighten(): Use algorithm to lighten colors in HCL space.\n\ndarken(): Use algorithm to darken colors in HCL space.\n\nDesaturate\n\ncols &lt;- sequential_hcl(25, \"La Jolla\")\nswatchplot(\n  \"La Jolla\" = cols,\n  \"Desaturate\" = desaturate(cols))\n\n\n\n\n\n\n\nLightening and darkening a palette can be really useful for having complementary color palettes for different types of geoms or text annotations in a plot. See Section 13.10.3 for an example of lightening and darkening a palette to add layers to a plot.\nLighten and Darken\n\ncols &lt;- sequential_hcl(5, \"Purple-Orange\")\nswatchplot(\n  \"-40%\" = lighten(cols, 0.4),\n  \"-20%\" = lighten(cols, 0.2),\n  \"  0%\" = cols,\n  \" 20%\" =  darken(cols, 0.2),\n  \" 40%\" =  darken(cols, 0.4),\n  off = c(0, 0)\n)\n\n\n\n\n\n\n\nlighten() and darken() have arguments for the amount to apply the manipulation, but also for the method to use and the color space within which to make the manipulation. You can play around with these arguments if the defaults are not what you want.\nAnother tool provided by colorspace is to calculate color contrast ratios between a palette and a color with contrast_ratio().\n\ncontrast_ratio(sequential_hcl(6, \"Emrld\"),\n               plot = TRUE)\n\n\n\n\n\n\n\nYou can also use colorspace to calculate the maximum chroma for a given hue and luminance with max_chroma().\n\nmax_chroma(h = seq(0, 360, by = 60), l = 50)\n#&gt; [1] 137.96  59.99  69.06  39.81  65.45 119.54 137.96\n\n\n18.5.6 scico\nThe scico package provides access to the perceptually uniform and color-blind friendly palettes developed by Fabio Crameri. The package has 35 different palettes. The color scales are sequential, and so it is a good augmentation to the viridis palettes.\n\n\nscico_palette_names(): Vector of palette names.\n\nscico_palette_show(): View the palettes.\n\nscico(30, palette = \"lapaz\"): Generate a palette with n values.\n\nscale_color_scico(): continuous color scale.\n\nscale_color_scico_d(): discrete color scale.\n\npcont + \n  scale_color_scico(\n    palette = \"hawaii\")\npdisc + \n  scale_color_manual(values = \n    scico(6, palette = \"tokyo\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n18.5.7 ggsci\nggsci offers a collection of ggplot2 color palettes inspired by scientific journals, data visualization libraries, science fiction movies, and TV shows. The palettes are mostly discrete. Each palette type has its own functions to access palettes (pal_palname()) and scale functions to use the palettes (scale_color_palname()). Each palette has different palette options.\npdisc + \n  scale_color_uchicago()\npdisc + \n  scale_color_manual(values = \n    pal_simpsons()(6))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n18.5.8 ggthemes\nggthemes provides a number of extra color palettes derived from the style of news organizations and other visualization platforms. Like ggsci, it has functions to access palettes (palname_pal()) and scale functions (scale_color_palname()).\npdisc + \n  scale_color_solarized() + \n  theme_solarized()\npdisc + \n  scale_color_manual( \n    values = economist_pal()(6)) + \n  theme_economist()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n18.5.9 rcartocolors\nrcartocolor provides color palettes made for mapping designed by CARTO. Similar to Color brewer, rcartocolor has sequential, diverging, and qualitative color palettes.\n\n\ncartocolors$Name: vector of palette names\n\n\ncartocolors[c(1, 2)]: Data frame of palette names and types\n\n\n\ndisplay_carto_all(): display all palettes\n\ndisplay_carto_pal(6, name = \"Sunset\"): Display a single palette with n discrete colors.\n\ncarto_pal(n, name): Create or access carto color palette\nScale functions\n\nscale_color_carto_c()\nscale_color_carto_d()\n\n\n\npcont + \n  scale_color_carto_c(\n  palette = \"Sunset\")\npdisc + \n  scale_color_manual(\n    values = carto_pal(6, \"Vivid\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n18.5.10 MetBrewer\nMetBrewer contains 56 color palettes inspired by works of art at the Metropolitan Museum of Art.\n\n\nMetPalettes: see a complete list of all the palettes and the colors used in them.\n\ndisplay_all(): view all palettes.\n\nmet.brewer(name, n): view or use an individual palette. Use n to expand beyond the discrete values provided by the palettes.\nScale functions\n\nscale_color_met_c()\nscale_color_met_d()\n\n\n\npcont + \n  scale_color_met_c(\n    \"VanGogh2\")\npdisc + \n  scale_color_manual(\n    values = met.brewer(\"VanGogh2\", 6))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n18.5.11 paletteer\npaletteer provides a common API for accessing dozens of palette packages and thousands of color palettes. The basic structure is function(\"package::palette\").\npaletteer palettes are divided among discrete and continuous. There are two types of discrete palettes: fixed width and dynamic. Fixed width palettes have a set number of colors and return colors from 1 to n. Dynamic palettes return different discrete colors depending on the number of colors desired using similar starting and ending values.\n\nLists of palettes\n\n\npaletteer_packages: tibble of all color packages included\n\npalettes_c_names: tibble of continuous palettes\n\npalettes_d_names: tibble of discrete palettes\n\npalettes_dynamic_names: tibble of dynamic discrete palettes\n\n\nPal functions\n\npaletteer_c(palette, n)\npaletteer_d(palette, n)\npaletteer_dynamic(palette, n)\n\n\nScale functions\n\nscale_color_paletteer_c()\nscale_color_paletteer_d()\nscale_color_paletteer_binned()\n\n\n\nContinuous\npcont + \n  scale_color_paletteer_c(\n    \"harrypotter::hufflepuff\")\nshow_col(\n  paletteer_c(\n    \"harrypotter::hufflepuff\", 16))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBinned\nscale_color_paletteer_binned() creates binned versions of the continuous palettes from palettes_c_names.\n\npcont + \n  scale_color_paletteer_binned(\n    \"scico::tokyo\")\n\n\n\n\n\n\n\nDiscrete\nThere are many, many more discrete palettes available. A good way to see the palettes available is to filter palettes_d_names by the name of the package.\n\npalettes_d_names |&gt; \n  filter(package == \"nationalparkcolors\")\n#&gt; # A tibble: 25 × 5\n#&gt;    package            palette        length type        novelty\n#&gt;    &lt;chr&gt;              &lt;chr&gt;           &lt;int&gt; &lt;chr&gt;       &lt;lgl&gt;  \n#&gt;  1 nationalparkcolors SmokyMountains      6 qualitative TRUE   \n#&gt;  2 nationalparkcolors RockyMountains      5 qualitative TRUE   \n#&gt;  3 nationalparkcolors Yellowstone         6 qualitative TRUE   \n#&gt;  4 nationalparkcolors Arches              6 qualitative TRUE   \n#&gt;  5 nationalparkcolors ArcticGates         6 qualitative TRUE   \n#&gt;  6 nationalparkcolors MtMckinley          6 qualitative TRUE   \n#&gt;  7 nationalparkcolors GeneralGrant        8 qualitative TRUE   \n#&gt;  8 nationalparkcolors Hawaii              5 qualitative TRUE   \n#&gt;  9 nationalparkcolors CraterLake          7 qualitative TRUE   \n#&gt; 10 nationalparkcolors Saguaro             6 qualitative TRUE   \n#&gt; # ℹ 15 more rows\n\npdisc + \n  scale_color_paletteer_d(\n  \"nationalparkcolors::BlueRidgePkwy\")\nshow_col(\n  paletteer_d(\n  \"nationalparkcolors::BlueRidgePkwy\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npaletteer_d() also has an argument for type to allow “continuous” palette to interpolate between colors and allow more colors than are available in the discrete palette. This provides a way to either get more colors for a discrete scale or visualize what the palette looks like in a continuous scale using scale_gradientn().\n\n\n\n\nZeileis, Achim, and Paul Murrell. 2023. “Coloring in R’s Blind Spot.” arXiv. https://arxiv.org/abs/2303.04918.",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Color scales</span>"
    ]
  },
  {
    "objectID": "02-scales-color.html#footnotes",
    "href": "02-scales-color.html#footnotes",
    "title": "18  Color scales",
    "section": "",
    "text": "(Zeileis and Murrell 2023)↩︎",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>Color scales</span>"
    ]
  },
  {
    "objectID": "02-scales-aes.html",
    "href": "02-scales-aes.html",
    "title": "19  Aesthetic scales",
    "section": "",
    "text": "19.1 Resources\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(readr)\nlibrary(palmerpenguins)\n\n# Data\npenguins &lt;- penguins |&gt; \n  filter(!is.na(flipper_length_mm),\n         !is.na(sex))\n\nbikes &lt;- read_csv(\n  here::here(\"data\", \"london-bikes-custom.csv\"),\n  col_types = \"Dcfffilllddddc\"\n)\n\nbikes$season &lt;- forcats::fct_inorder(bikes$season)\n\np &lt;- penguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  geom_point(aes(color = species)) + \n  theme(legend.position = \"none\")",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Aesthetic scales</span>"
    ]
  },
  {
    "objectID": "02-scales-aes.html#sec-scale-aes-resources",
    "href": "02-scales-aes.html#sec-scale-aes-resources",
    "title": "19  Aesthetic scales",
    "section": "",
    "text": "Scales documentation\nggplot2 Cheatsheet: Scales\nscales package\nWickham, ggplot2 Book: Other aesthetics\nR for Data Science: Communication, Scales",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Aesthetic scales</span>"
    ]
  },
  {
    "objectID": "02-scales-aes.html#sec-scale-types",
    "href": "02-scales-aes.html#sec-scale-types",
    "title": "19  Aesthetic scales",
    "section": "\n19.2 Types of scales",
    "text": "19.2 Types of scales\nThere are five main types of aesthetic scales:\n\nContinuous: Map continuous values to visual ones - scale_*_continuous()\n\nDiscrete: Map a finite number of discrete categories to visual ones - scale_*_discrete()\n\nBinned: Map continuous values into discrete bins or categories - scale_*_binned()\n\nManual: Map discrete values to manually chosen visual ones - scale_*_manual(values = c()) (Section 19.7)\nIdentity: Use data values directly as visual ones - scale_*_identity() (Section 19.8)",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Aesthetic scales</span>"
    ]
  },
  {
    "objectID": "02-scales-aes.html#sec-scale-size",
    "href": "02-scales-aes.html#sec-scale-size",
    "title": "19  Aesthetic scales",
    "section": "\n19.3 Scale size",
    "text": "19.3 Scale size\nThe main reason to change the default scale for size is to affect the upper and lower bounds of the size of the geoms. This is done with the range argument. The defaults for size are range = c(1, 6).\nSize base plot\n\nCodepsize &lt;- penguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             size = bill_depth_mm)) + \n  geom_point(alpha = 0.4)\n\n\n\npsize + \n  scale_size(range = c(0.5, 4))\n\n\n\n\n\n\n\nYou can also change the guides with scale_size(), providing a title for the legend, the breaks for the legend, and the labels for the legend. These types of changes to breaks and labels are also available with other scales.\n\npsize + \n  scale_size(\"Bill depth\",\n             range = c(0.5, 4),\n             breaks = c(15, 17, 19, 21),\n             labels = c(\"Fifteen\", \"Seventeen\",\n                        \"Nineteen\", \"Twenty-one\")\n             )\n\n\n\n\n\n\n\nThe number of breaks in the size legend can be changed with scales::extended_breaks(n), which provides access to an n.breaks argument in a continuous scale.\n\npsize + \n  scale_size(\"Bill depth\",\n             range = c(0.5, 4),\n             breaks = scales::extended_breaks(8)\n             )\n\n\n\n\n\n\n\nA similar effect can be achieved with scale_size_binned(), which has an argument for n.breaks. Like binned position and color scales, scale_size_binned() makes a continuous variable into a discrete variable. Using a binned scale changes the legend style to guide_bins(), and it directly affects the scale used in the plot. This can be seen by choosing a smaller number of bins. To keep a continuous scale for the plot but use a binned legend use guide_bins(), see Section 21.8.1.\n\npsize + \n  scale_size_binned(\"Bill depth\",\n             range = c(0.5, 4),\n             n.breaks = 4)",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Aesthetic scales</span>"
    ]
  },
  {
    "objectID": "02-scales-aes.html#sec-scale-alpha",
    "href": "02-scales-aes.html#sec-scale-alpha",
    "title": "19  Aesthetic scales",
    "section": "\n19.4 Scale transparency",
    "text": "19.4 Scale transparency\nScaling transparency is very similar to scaling size. The default alpha range is range = c(0.1, 1).\nAlpha base plot\n\nCodepalpha &lt;- penguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             alpha = bill_depth_mm)) + \n  geom_point()\n\n\nCompare scale_alpha() and scale_alpha_binned()\npalpha + \n  scale_alpha(\"Bill depth\",\n              range = c(0.2, 0.5)\n              )\npalpha + \n  scale_alpha_binned(\"Bill depth\",\n              range = c(0.2, 0.5),\n              n.breaks = 6)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIt is also possible to map alpha to discrete values.\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             alpha = species)) + \n  geom_point() + \n  scale_alpha_discrete(\"Species\")\n#&gt; Warning: Using alpha for a discrete variable is not advised.",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Aesthetic scales</span>"
    ]
  },
  {
    "objectID": "02-scales-aes.html#sec-scale-shape",
    "href": "02-scales-aes.html#sec-scale-shape",
    "title": "19  Aesthetic scales",
    "section": "\n19.5 Scale shape",
    "text": "19.5 Scale shape\nMapping values to shapes can be useful when you have a small number of discrete values. The only different argument for scale_shape() is whether shapes should be solid or not, default is solid = TRUE.\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             shape = species)) + \n  geom_point() + \n  scale_shape(\"Species\",\n              solid = FALSE)\n\n\n\n\n\n\n\nThough it is probably not useful too often, it is also possible to map a continuous variable to shapes using scale_shape_binned().\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             shape = bill_depth_mm)) + \n  geom_point() + \n  scale_shape_binned(\"Bill depth\",\n                     solid = FALSE)\n\n\n\n\n\n\n\nThere are 25 different shapes that are associated with each integer. Use scale_shape_manual() to choose the shapes.",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Aesthetic scales</span>"
    ]
  },
  {
    "objectID": "02-scales-aes.html#sec-scale-lines",
    "href": "02-scales-aes.html#sec-scale-lines",
    "title": "19  Aesthetic scales",
    "section": "\n19.6 Scale lines",
    "text": "19.6 Scale lines\nThere are two scales that can be applied to lines: linewidth and linetype. These are analogous to scaling size and shape.\n\n19.6.1 Line width\nLine width used to be controlled with size, but now linewidth is preferred. Like size, you can scale line width with scale_linewidth() or scale_linewidth_binned().\n# Base plot\nplw &lt;- bikes |&gt; \n  summarise(count = sum(count), .by = c(month, day_night)) |&gt; \n  ggplot(aes(x = month, y = count, group = day_night,\n             linewidth = count)) + \n  geom_line(lineend = \"round\") + \n  scale_y_continuous(guide = \"none\")\n\n# linewidth\n  plw + \n    scale_linewidth(\"Count\",\n                    range = c(0.1, 4))\n\n# linewidth_binned\n    plw + \n    scale_linewidth_binned(\"Count\",\n                           range = c(0.1, 4),\n                           n.breaks = 10,\n                           labels = scales::label_comma())\n\n\n\n\n\n\n\n\n\n\n\n\n\n19.6.2 Line type\nlinetype is like shape in that there is little to do with the scale other than choose among the thirteen line types with scale_linetype_manual(). You can access the default linetype palette with scales::linetype_pal().\n\nbikes |&gt; \n  summarise(count = sum(count), .by = c(month, day_night)) |&gt; \n  ggplot(aes(x = month, y = count, group = day_night,\n             linetype = day_night)) + \n  geom_line() + \n  scale_y_continuous(guide = \"none\")",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Aesthetic scales</span>"
    ]
  },
  {
    "objectID": "02-scales-aes.html#sec-scale-manual",
    "href": "02-scales-aes.html#sec-scale-manual",
    "title": "19  Aesthetic scales",
    "section": "\n19.7 Manual scales",
    "text": "19.7 Manual scales\nManual scales are created within the scale_*_manual() function through the values argument. values accepts a vector or a named vector to match to the values. See the Aesthetic specifications vignette for valid aesthetic values for the different geom scales.\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             shape = species)) + \n  geom_point() + \n  scale_shape_manual(\"Species\",\n                     values = c(8, 9, 13))\n\n\n\n\n\n\n\nA named vector makes the mapping clearer:\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             size = species)) + \n  geom_point(alpha = 0.4) + \n  scale_size_manual(\"Species\",\n    values = c(\"Adelie\" = 0.5, \"Chinstrap\" = 3, \"Gentoo\" = 5)\n    )",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Aesthetic scales</span>"
    ]
  },
  {
    "objectID": "02-scales-aes.html#sec-scale-identity",
    "href": "02-scales-aes.html#sec-scale-identity",
    "title": "19  Aesthetic scales",
    "section": "\n19.8 Identity scales",
    "text": "19.8 Identity scales\nIdentity scales are similar to manual scales, but are used when the data is already scaled. For instance, you might add a scale within the data wrangling process. By default no guide/legend is produced.\n\npenguins |&gt; \n  mutate(bill_depth_cm = bill_depth_mm / 10) |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             size = bill_depth_cm)) + \n  geom_point(alpha = 0.4) + \n  scale_size_identity(\"Bill depth\\n(cm)\",\n                      guide = \"legend\")",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>Aesthetic scales</span>"
    ]
  },
  {
    "objectID": "02-coords.html",
    "href": "02-coords.html",
    "title": "20  Coordinates",
    "section": "",
    "text": "20.1 Resources\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(palmerpenguins)\n\n# Data\npenguins &lt;- penguins |&gt; \n  filter(!is.na(flipper_length_mm),\n         !is.na(sex))",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Coordinates</span>"
    ]
  },
  {
    "objectID": "02-coords.html#sec-coords-resources",
    "href": "02-coords.html#sec-coords-resources",
    "title": "20  Coordinates",
    "section": "",
    "text": "Coordinates documentation\nWickham, ggplot2 Book: Coordinates",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Coordinates</span>"
    ]
  },
  {
    "objectID": "02-coords.html#sec-coords-limits",
    "href": "02-coords.html#sec-coords-limits",
    "title": "20  Coordinates",
    "section": "\n20.2 Plot limits",
    "text": "20.2 Plot limits\nSee Section 17.6 for more on the differences of using scale_x/y_*() or coord_cartesian() to set plot limits.\n\n20.2.1 Zooming\nUse coord_cartesian(xlim, ylim) to zoom in on a plot.\nFor zooming in on data in a plot—making the axes limits smaller than the data—it is preferable to use coord_cartesian() instead of scale_x/y_*(). scale_x/y_*() subsets the data, turning all of the data outside the limits into NA. coord_cartesian() draws the same plot but with more confined bounds. The difference is clear with a box plot.\n# Zoomed plot\npenguins |&gt; \nggplot(aes(x = species,\n           y = body_mass_g)) +\n  geom_boxplot() +\n  coord_cartesian(\n    ylim = c(3500, 5500))\n# Filtered plot\npenguins |&gt; \nggplot(aes(x = species,\n           y = body_mass_g)) +\n  geom_boxplot() +\n  scale_y_continuous(\n    limits = c(3500, 5500))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n20.2.2 Padding\nThe expand and clip arguments of coord_cartesian() are useful to eliminate padding of the data. To alter the padding or eliminate it for one axis, scale_x/y_*(expand) is preferable. You need to be careful in using clip = \"off\" because it can lead to plotted data outside the panel region. However, it is useful to prevent points from being clipped on the limits of the plot.\nFor more complex adjustment of padding with scale_x/y_*(), see Section 17.6.2.3.\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  geom_point(aes(color = species)) + \n  coord_cartesian(expand = FALSE,\n                  clip = \"off\") + \n  theme(legend.position = \"none\")",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Coordinates</span>"
    ]
  },
  {
    "objectID": "02-coords.html#sec-coords-linear",
    "href": "02-coords.html#sec-coords-linear",
    "title": "20  Coordinates",
    "section": "\n20.3 Linear coordinate systems",
    "text": "20.3 Linear coordinate systems\n\n20.3.1 Flipped coords\ncoord_flip() is often used with bar plots to make them sideways. Alternatively, this can also be done by placing the variable to be counted on the y axis. coord_flip() is more important when fitting a model, which assumes the data is y ~ x.\n\npenguins |&gt; \n  ggplot(aes(x = species)) + \n  geom_bar() + \n  coord_flip()\n\n\n\n\n\n\n\n\n20.3.2 Fixed coords\ncoord_fixed() fixes the ratio of length on the x and y axes using the ratio argument. The aspect ratio will also be set to ensure that the mapping is maintained regardless of the shape of the output device",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Coordinates</span>"
    ]
  },
  {
    "objectID": "02-coords.html#sec-coords-circular",
    "href": "02-coords.html#sec-coords-circular",
    "title": "20  Coordinates",
    "section": "\n20.4 Circular coordinate system",
    "text": "20.4 Circular coordinate system\nWith coord_polar() x and y are transformed into angle (theta) and radius. Rectangles become arcs. This is shown in the below plots. The expansion of the x axis moves the starting point out from the center, while the expansion of the y axis ensures that the largest bar does not become a closed donut. See the lollipop plot example from Cédric Scherer, Graphic Design with ggplot2 at RStudio conf 2022 for a more complex example.\n\npenguins |&gt; \n  ggplot(aes(x = species, fill = species)) + \n  geom_bar() + \n  scale_x_discrete(expand = expansion(mult = c(0.5, 0))) + \n  scale_y_continuous(expand = expansion(add = c(0, 10))) + \n  coord_polar(theta = \"y\")\n\n\n\n\n\n\n\n\n\n\n\nWickham, Hadley. 2016. Ggplot2: Elegant Graphics for Data Analysis. Second Edition. Use R! New York: Springer. https://doi.org/10.1007/978-3-319-24277-4.",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Coordinates</span>"
    ]
  },
  {
    "objectID": "02-coords.html#footnotes",
    "href": "02-coords.html#footnotes",
    "title": "20  Coordinates",
    "section": "",
    "text": "(Wickham 2016, 159)↩︎",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>Coordinates</span>"
    ]
  },
  {
    "objectID": "02-guides.html",
    "href": "02-guides.html",
    "title": "21  Guides: Legends",
    "section": "",
    "text": "21.1 Resources\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(palmerpenguins)\n\n# Data\npenguins &lt;- penguins |&gt; \n  filter(!is.na(flipper_length_mm),\n         !is.na(sex))\n# Base plot\np &lt;- penguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             color = species,\n             shape = species))",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Guides: Legends</span>"
    ]
  },
  {
    "objectID": "02-guides.html#sec-guides-resources",
    "href": "02-guides.html#sec-guides-resources",
    "title": "21  Guides: Legends",
    "section": "",
    "text": "Guides documentation\nWickham, ggplot2 Book: Scales and guides\nR for Data Science: Communication, Legend layout\nCedric Scherer, ggplot2 tutorial: Legends",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Guides: Legends</span>"
    ]
  },
  {
    "objectID": "02-guides.html#sec-guide-rm-legend",
    "href": "02-guides.html#sec-guide-rm-legend",
    "title": "21  Guides: Legends",
    "section": "\n21.2 Removing a legend",
    "text": "21.2 Removing a legend\nLegends are created automatically by ggplot() when a non-positional aesthetic is mapped to the data (e.g. color, shape, size, alpha, etc.).\nThere are four ways to remove a legend:\n\ngeom_point(show.legend = FALSE)\nscale_color_discrete(guide = \"none\")\nguides(color = \"none\")\ntheme(legend.position = \"none\")\n\nThese four different options demonstrate the relationship between these different elements in a ggplot2 plot. A legend can be turned on or off for one layer through the geom. However, the actual data aspects of the legend are mostly controlled through the guide argument of the chosen aesthetic scale. The guides() function is essentially a convenient way to access the guide argument for the chosen scale. Using either the guide argument or guides() allows you to address one aesthetic/scale/guide at a time: removing the guide in the color scale does not remove the shape guide, while removing the shape guide in guides() does not affect the color guide. Finally, the theme controls the position of the legend in the plot, making it possible to turn the legend off by giving it no position.\n# 1. geom\np + \n  geom_point(show.legend = FALSE\n             )\n# 2. scale\np + \n  geom_point() + \n  scale_color_discrete(guide = \"none\")\n# 3. guide\np + \n  geom_point() + \n  guides(shape = \"none\")\n# 4. theme\np + \n  geom_point() + \n  theme(legend.position = \"none\")",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Guides: Legends</span>"
    ]
  },
  {
    "objectID": "02-guides.html#sec-guide-title",
    "href": "02-guides.html#sec-guide-title",
    "title": "21  Guides: Legends",
    "section": "\n21.3 Legend titles",
    "text": "21.3 Legend titles\nLegend titles provide another way to see how elements in a ggplot2 plot are related and come together to make a legend.\n\n21.3.1 Set legend title\nThere are three ways to provide legend titles:\n\nlabs(color = \"Species\")\nscale_color_discrete(\"Species\")\nguides(color = guide_legend(\"Species\"))\n\nThe easiest is probably with labs(), but the first argument for scale_*() and guide_*() functions are name for the scale name and title to be used for the legend title. The exception is guide_colorsteps(), which requires title to be a named argument.\n\n21.3.2 Merge and split legends\nLegend titles are one way to merge or split legends. By default ggplot2 merges legends of the same variable, but they can be split by giving them different names.\n\np + \n  geom_point() + \n  labs(color = \"Color\",\n       shape = \"Shape\")\n\n\n\n\n\n\n\n\n21.3.3 Remove legend title\nTo remove the legend title set name to NULL or with theme(legend.title = element_blank()).\n\np + \n  geom_point() + \n  theme(legend.title = element_blank())",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Guides: Legends</span>"
    ]
  },
  {
    "objectID": "02-guides.html#sec-guide-fns",
    "href": "02-guides.html#sec-guide-fns",
    "title": "21  Guides: Legends",
    "section": "\n21.4 Guide functions",
    "text": "21.4 Guide functions\nTo change the type of legend or elements within the legend from the defaults use one of the guide_*() functions.\n\n\nguides(): general convenience function to set guides en masse like labs().\n\nguide_colorbar(): continuous scales for color/fill aesthetics.\n\nguide_colorsteps(): binned scales for color/fill aesthetics.\n\nguide_axis(): position scales (continuous, binned and discrete)\n\nguide_legend(): discrete scales (except position scales)\n\nguide_bins(): binned scales (except position/color/fill scales)\n\nOne reason to change the type of legend is to switch between continuous and binned versions of legends. Note that this does not change the scale in the plot from continuous to binned but only its representation in the legend. See Section 19.3 on changing the scale between continuous and binned within the plot itself.\nFor more details on using and tweaking the different types of legends see Section 21.8 below.\n\n21.4.1 Continuous to binned\nChange from a continuous scale that uses guide_legend() to a binned legend with either guides(size = legend_bins()) or guides(size = \"bins\").\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             size = bill_depth_mm)) + \n  geom_point(alpha = 0.4) + \n  guides(size = \"legend\")\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             size = bill_depth_mm)) + \n  geom_point(alpha = 0.4) + \n  guides(size = \"bins\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n21.4.2 Color bar to color steps\nChange from a continuous color scale to a binned color scale with either guides(color = guide_colorsteps() or guides(color = \"colorsteps\").\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             color = bill_depth_mm)) + \n  geom_point() + \n  labs(\n    color = \"Bill depth\")\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             color = bill_depth_mm)) + \n  geom_point() + \n  guides(color = guide_colorsteps(\n    title = \"Bill depth\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n21.4.3 Color bar to geom legend\nYou can also change a color bar legend to a normal geom legend that uses the default key glyph for the geom and binned colors with the given number of breaks in the scale by using guide_legend() or guide_bins().\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             color = bill_depth_mm)) + \n  geom_point() + \n  guides(color = guide_legend(\"Bill depth\"))\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             color = bill_depth_mm)) + \n  geom_point() + \n  guides(color = guide_bins(\"Bill depth\"))",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Guides: Legends</span>"
    ]
  },
  {
    "objectID": "02-guides.html#sec-guide-layout",
    "href": "02-guides.html#sec-guide-layout",
    "title": "21  Guides: Legends",
    "section": "\n21.5 Legend layout",
    "text": "21.5 Legend layout\nThe layout of the legend is controlled by both guide_*() and theme(). Remember that using guide_*() functions only affects one aesthetic at a time, while theme() affects all aesthetics and multiple legends if there are more than one.\n\n21.5.1 Legend position\nLegend position is controlled by theme(legend.position). The options are “none”, “left”, “right”, “bottom”, “top” to place the legend outside the plot area or a numeric vector of x and y positions within the plot on a scale of 0 to 1.\np + \n  geom_point() + \n  theme(legend.position = \"top\")\np + \n  geom_point() + \n  theme(legend.position = c(0.2, 0.8))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUse theme(legend.justification) to anchor the position of the legend to the “top” or “bottom” of the plot when legend.position is “left” or “right” and to the “left” or “right” when legend position is “top” or “bottom”.\n\np + \n  geom_point() + \n  theme(legend.justification = \"top\")\n\n\n\n\n\n\n\n\n21.5.2 Legend orientation\nLegends can be oriented vertically or horizontally. The default is for legends positioned on the right and left to be vertical and those on the top and bottom to be horizontal. This can be changed with either guide_legend(direction) or theme(legend.direction). The primary difference is that guide_legend(direction) only affects one scale at a time, while theme(legend.direction) affects all scales.\n\n# Legend orientation: guides\np + \n  geom_point() + \n  guides(color = guide_legend(direction = \"horizontal\"))\n\n\n\n\n\n\n\n\n# Legend orientation: theme\np + \n  geom_point() + \n  theme(legend.direction = \"horizontal\")\n\n\n\n\n\n\n\n\n21.5.3 Legend arrangement\nWhen there are multiple legends, use theme(legend.box) to arrange the legends either “horizontal” or “vertical”. You can use the legend.box.* arguments to further tune how the legends are arranged. The guide_*() functions also have an order argument if you want to manually order the legends.\n\np + \n  geom_point() + \n  labs(color = \"Color\",\n       shape = \"Shape\") + \n  theme(legend.box = \"horizontal\")\n\n\n\n\n\n\n\n\n21.5.4 Legend organization\nlegend_guide() allows you to control the organization and order of the keys in the legend. You can do this with the nrow, ncol, byrow, and reverse arguments. We can see this in a plot with a lot of groups.\n\nmpg |&gt; \n  ggplot(aes(x = displ, y = hwy, color = class)) +\n  geom_point() + \n  guides(color = guide_legend(\n    nrow = 3, ncol = 3)\n    )\n\n\n\n\n\n\n\nThe byrow and reverse arguments dictate the order of the keys. The default is for the order of the keys to go down by column. byrow = TRUE changes this, while reverse reverses the order of the keys.\n\nmpg |&gt; \n  ggplot(aes(x = displ, y = hwy, color = class)) +\n  geom_point() + \n  guides(color = guide_legend(\n    nrow = 3, ncol = 3,\n    byrow = TRUE, reverse = TRUE)\n    )",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Guides: Legends</span>"
    ]
  },
  {
    "objectID": "02-guides.html#sec-guide-keys",
    "href": "02-guides.html#sec-guide-keys",
    "title": "21  Guides: Legends",
    "section": "\n21.6 Legend key glyphs",
    "text": "21.6 Legend key glyphs\n\n21.6.1 Key glyph aesthetics\nThe aesthetic features of the key glyphs can be altered with the override.aes argument and a list() of aesthetics. This can be useful for making points larger or for changing the alpha to make the glyphs clearer.\n\np + \n  geom_point(alpha = 0.7, shape = 1) + \n  guides(color = guide_legend(\n    override.aes = list(size = 4, shape = 16, alpha = 1)\n  ))\n\n\n\n\n\n\n\n\n21.6.2 Key glyph types\nIt is also possible to change the type of key glyphs drawn for the legend within the geom_*() function using any of the glyphs listed under the draw_key_*() functions, see Key glyphs for legends. They are used in two ways: key_glyph = \"glyph-name\" or key_glyph = draw_key_name.\np + \n  geom_point(key_glyph = \"dotplot\")\n\npenguins |&gt; \n  count(species, year) |&gt; \n  ggplot(aes(x = year, y = n,\n             color = species)) + \n  geom_line(key_glyph = draw_key_timeseries)\n\n\n\n\n\n\n\n\n\n\n\n\n\n21.6.3 Key glyph spacing\nThe width and height of the area around the key glyphs can be changed with either the keywidth and keyheight arguments in the guide_*() functions or legend.key.width, legend.key.height, or legend.key.size arguments in theme(). keywidth and keyheight can either be a numeric that uses the base unit defined by legend.key.width, legend.key.height, or legend.key.size arguments in theme() or a grid::unit() object.\n\np + \n  geom_point() + \n  guides(color = guide_legend(\n    keywidth = 2,\n    keyheight = grid::unit(2, \"cm\")\n  ))\n\n\n\n\n\n\n\nControlling the width and height of the keys in theme() necessitates using a grid::unit() object.\n\np + \n  geom_point() + \n  theme(legend.key.size = grid::unit(2, \"lines\"))",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Guides: Legends</span>"
    ]
  },
  {
    "objectID": "02-guides.html#sec-guide-labels",
    "href": "02-guides.html#sec-guide-labels",
    "title": "21  Guides: Legends",
    "section": "\n21.7 Legend title and label positioning",
    "text": "21.7 Legend title and label positioning\nThe values of the legend labels are controlled through scale_*() functions as shown in Section 19.3, while the content of the legend title is discussed above, Section 21.3.1.\nThe title and label positions for legends can be controlled with either guide_legend() or theme(), but for the structure of the labels, guide_legend() generally seems to be easier. You can also affect the aesthetic text elements of labels and titles within guide_legend() with the title.theme and label.theme arguments, but these are probably better left to theme(), see below Section 21.9 and Section 23.5.3.\nArguments affecting the positioning of the legend title:\n\n\ntitle.position: Where to place the title in relation to the legend: “top”, “bottom”, “left”, and “right”.\n\ntitle.hjust: A number between 0 and 1 specifying the horizontal justification of the title.\n\ntitle.vjust: A number between 0 and 1 specifying the vertical justification of the title.\n\n\np + \n  geom_point() + \n  guides(color = guide_legend(title.position = \"left\",\n                              title.vjust = 0), # align to bottom\n         shape = guide_legend(direction = \"horizontal\",\n                              title.position = \"bottom\",\n                              title.hjust = 0.5)) # center title\n\n\n\n\n\n\n\nArguments affecting the positioning of the legend labels:\n\n\nlabel.position: Where to place the labels in relation to the legend: “top”, “bottom”, “left”, and “right”.\n\nlabel.hjust: Horizontal justification of the labels.\n\nlabel.vjust: Vertical justification of the labels.\n\n\np + \n  geom_point() + \n  guides(color = guide_legend(label.position = \"left\",\n                              label.vjust = 0,\n                              label.hjust = 0),\n         shape = guide_legend(direction = \"horizontal\",\n                              label.position = \"top\",\n                              label.hjust = 0.5))",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Guides: Legends</span>"
    ]
  },
  {
    "objectID": "02-guides.html#sec-guide-styling",
    "href": "02-guides.html#sec-guide-styling",
    "title": "21  Guides: Legends",
    "section": "\n21.8 Legend styling",
    "text": "21.8 Legend styling\nLegend styling is controlled through a combination of guide_*() and theme() functions. The previous sections of this chapter have focused on the styling options for the generic legend produced with guide_legend() that are also available in the other guide_*() functions. This section will focus on the other guide_*() functions, first looking at guide_bins() and then at the two color legends: guide_colorbar() and guide_colorsteps().\n\n21.8.1 Binned legends\nThe main difference between guide_legend() and guide_bins() is the drawing of an axis and ticks, as well as the addition of a lower and upper bounds of the bins in guide_bins() as shown in Section 21.4.1. These aspects are also the main things that you can change.\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             size = bill_depth_mm)) + \n  geom_point(alpha = 0.4) + \n  guides(size = guide_bins(axis.colour = \"firebrick\",\n                           axis.linewidth = 2,\n                           show.limits = TRUE))\n\n\n\n\n\n\n\n\n21.8.2 Color legends\nBase color plot\n\nCodepcolor &lt;- penguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             color = bill_depth_mm)) + \n  geom_point()\n\n\nMore customization is available with color legends.\nTicks\nBy default guide_colorbar() has tick marks to set off the breaks in the continuous color scale. guide_colorsteps() does not have tick marks by default since the breaks between the colors are more clear. Use the ticks argument to turn on or off tick marks and use ticks.colour and ticks.linewidth to control the ticks. Note the use of the British spelling of colour in the argument name.\n\npcolor + \n  guides(color = guide_colorbar(\n    title = \"Bill depth\",\n    ticks.colour = \"firebrick\",\n    ticks.linewidth = 0.8))\n\n\n\n\n\n\n\nFrame\nYou can put a colored frame around both continuous and binned color legends. By default there is no frame, but this can be changed with frame.colour, frame.linewidth, and frame.linetype. Note again the use of the British spelling of colour.\n\npcolor + \n  guides(color = guide_colorbar(\n    title = \"Bill depth\",\n    frame.colour = \"firebrick\",\n    frame.linewidth = 1))\n\n\n\n\n\n\n\nBar height and width\nOne of the most useful aspects of a color legend that you can change is the height and width of the color bar.\n\npcolor + \n  guides(color = guide_colorbar(\n    title = \"Bill depth\",\n    title.position = \"top\",\n    title.hjust = 0.5,\n    barwidth = grid::unit(20, \"lines\"),\n    barheight = grid::unit(0.5, \"lines\"),\n    ticks = FALSE\n  )) + \n  theme(legend.position = \"top\")\n\n\n\n\n\n\n\nColor steps\nTo change from a continuous color bar legend to a binned color legend use guide_colorsteps(). Similar to the difference between guide_legend() and guide_bins() discussed above (Section 21.8.1), there are only a few differences such as not showing ticks by default and a show.limits argument whether the upper and lower bounds of the scale should be shown.\n\npcolor + \n  guides(color = guide_colorsteps(\n    title = \"Bill depth\",\n    title.position = \"top\",\n    title.hjust = 0.5,\n    barwidth = grid::unit(20, \"lines\"),\n    barheight = grid::unit(0.5, \"lines\"),\n    show.limits = TRUE\n  )) + \n  theme(legend.position = \"top\")",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Guides: Legends</span>"
    ]
  },
  {
    "objectID": "02-guides.html#sec-guide-theme",
    "href": "02-guides.html#sec-guide-theme",
    "title": "21  Guides: Legends",
    "section": "\n21.9 Legend styling: theme()\n",
    "text": "21.9 Legend styling: theme()\n\nSee also Themes: Legends\n\nLegend layout: see Section 21.5\n\n\nlegend.position: the position of legends – “none”, “left”, “right”, “bottom”, “top”, or two-element character or numeric vector\n\nlegend.direction: “horizontal” or “vertical”\n\nlegend.justification: anchor point for positioning legend\n\n\nBounding box of all legends\n\n\nlegend.box: arrangement of multiple legends (“horizontal” or “vertical”)\n\nlegend.box.background: background of full legend area\n\nlegend.box.just: justification of each legend within the overall bounding box\n\nlegend.box.margin: margins around the full legend bounding box\n\nlegend.box.spacing: The spacing between the plotting area and the full legend bounding box\n\n\nBounding box of each legend\n\nlegend.background\n\nlegend.margin: the margin around each legend\n\nlegend.spacing: spacing between legends if there are multiple legends\n\n\nLegend keys: see Section 21.6.3\n\n\nlegend.key: background underneath legend keys (symbols of geoms)\n\nlegend.key.size, legend.key.height, and legend.key.width\n\n\n\nLegend text: see Section 21.7\n\n\nlegend.text: legend item labels\n\nlegend.text.align: alignment of legend labels (number from 0 (left) to 1 (right))\n\nlegend.title: legend title\n\n\nlegend.title.align: alignment of legend title\n\n\n\n\n\n\np + \n  geom_point() + \n  labs(color = \"Color\",\n       shape = \"Shape\") + \n  theme(\n    # Bounding box of all legends\n    legend.box.background = element_rect(linetype = \"dashed\",\n                                         fill = \"lightgrey\"),\n    legend.box.margin = margin(8, 8, 8, 8),\n    # Legend bounding box\n    legend.background = element_rect(color = \"orange\",\n                                     fill = \"lightpink\"),\n    legend.margin = margin(0, 6, 0, 6),\n    # Keys\n    legend.key = element_rect(fill = \"lightblue\",\n                              color = \"black\"),\n    # Spacing between legends\n    legend.spacing = grid::unit(1, \"cm\"),\n    # Title\n    legend.title = element_text(size = rel(1.5)),\n    legend.title.align = 1,\n    # Labels\n    legend.text = element_text(color = \"firebrick\",\n                               face = \"bold\")\n        )",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>Guides: Legends</span>"
    ]
  },
  {
    "objectID": "02-facets.html",
    "href": "02-facets.html",
    "title": "22  Facets",
    "section": "",
    "text": "22.1 Resources\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(forcats)\nlibrary(palmerpenguins)\nlibrary(gghighlight)\n\n# Data\npenguins &lt;- penguins |&gt; \n  filter(!is.na(flipper_length_mm),\n         !is.na(sex)) |&gt; \n  # Add factor data that has more levels\n  mutate(species_sex = as.factor(\n    paste(species, sex)))\n\n# Base plot\np &lt;- penguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             color = species,\n             shape = species)) + \n  geom_point() + \n  theme(legend.position = \"none\")",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Facets</span>"
    ]
  },
  {
    "objectID": "02-facets.html#sec-facet-resources",
    "href": "02-facets.html#sec-facet-resources",
    "title": "22  Facets",
    "section": "",
    "text": "Faceting documentation\nggplot2 Cheatsheet: Faceting\nWickham, ggplot2 Book: Facets\nCedric Scherer, A ggplot2 Tutorial: Facetting",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Facets</span>"
    ]
  },
  {
    "objectID": "02-facets.html#sec-facet-wrap",
    "href": "02-facets.html#sec-facet-wrap",
    "title": "22  Facets",
    "section": "\n22.2 facet_wrap()\n",
    "text": "22.2 facet_wrap()\n\nCreate a facetted plot by adding facet_wrap() to a plot and using a formula to choose what variable to facet by. The formula can be created with either ~ or vars().\n\n# ~ formula\np + \n  facet_wrap(~island)\n\n#vars()\np + \n  facet_wrap(vars(island))\n\n\n\n\n\n\n\n\n\n\n\n\n\nUsing facet_wrap() with multiple variables serves to extend the sequence of plots and adds a second level to the plot labels.\n\np + \n  facet_wrap(vars(island, sex))\n\n\n\n\n\n\n\n\n22.2.1 Facet layout\nTo change the order of the facets change the levels of the underlying factor used for faceting. For instance, you can reorder the species_sex variable by frequency with forcats::fct_infreq(), which leads to a sequence of Adelie, Gentoo, Chinstrap rather than the default alphabetical order of Adelie, Chinstrap, Gentoo.\n\np + \n  facet_wrap(vars(fct_infreq(species_sex)))\n\n\n\n\n\n\n\nThe organization of the sequence of plots is controlled by the arguments ncol, nrow, as.table, and dir.\nncol and nrow tell how many columns or rows to create for the plot.\n# ncol\np + \n  facet_wrap(vars(species_sex),\n             ncol = 2)\n# nrow\np + \n  facet_wrap(vars(species_sex),\n             nrow = 6)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nas.table = TRUE, the default, moves from the top-left across to the bottom-right. as.table = FALSE begins the sequence from the bottom-left and moves across to the top-right.\n\np + \n  facet_wrap(vars(species_sex)) + \n  labs(title = \"as.table = TRUE\")\n\np + \n  facet_wrap(vars(species_sex),\n             as.table = FALSE) + \n  labs(title = \"as.table = FALSE\")\n\n\n\n\n\n\n\n\n\n\n\n\n\ndir can be either \"h\" for horizontal, the default, or \"v\" for vertical. As shown below, this can also affect the number of rows and columns in which the facets are laid out.\np + \n  facet_wrap(vars(species_sex),\n             dir = \"h\")\np + \n  facet_wrap(vars(species_sex),\n             dir = \"v\")",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Facets</span>"
    ]
  },
  {
    "objectID": "02-facets.html#sec-facet-grid",
    "href": "02-facets.html#sec-facet-grid",
    "title": "22  Facets",
    "section": "\n22.3 facet_grid()\n",
    "text": "22.3 facet_grid()\n\nfacet_grid() lays out facets in a two-dimensional grid by rows and/or columns. As with facet_warp() this can be done with either vars() or the tilde formula with rows on the left-hand side and columns on the right-hand side. A dot in the formula is used to indicate there should be no faceting on this dimension.\nFaceting along only one dimension essentially replicates facet_wrap().\n\np + \n  facet_grid(rows = vars(island))\n\n\n\n\n\n\n\n\np + \n  facet_grid(cols = vars(island))\n\n\n\n\n\n\n\nUse both rows and cols to create a two-dimensional grid, which is the main use case for facet_grid().\n\np + \n  facet_grid(rows = vars(sex),\n             cols = vars(island))\n\n\n\n\n\n\n\nMultiple variables can be placed in either rows or cols to add more variables to the faceting.\n\np + \n  facet_grid(rows = vars(year),\n             cols = vars(island, sex)) + \n  scale_x_continuous(n.breaks = 4)\n\n\n\n\n\n\n\n\n22.3.1 Grid layout\nAs with facet_wrap() you can change the order of the facets by reordering the underlying levels of the faceting factor.\n\np + \n  facet_grid(rows = vars(sex),\n             cols = vars(fct_rev(island)))\n\n\n\n\n\n\n\nYou can also use the as.table argument as in facet_wrap().\n\np + \n  facet_grid(rows = vars(sex),\n             cols = vars(island),\n             as.table = FALSE)",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Facets</span>"
    ]
  },
  {
    "objectID": "02-facets.html#sec-facet-scales",
    "href": "02-facets.html#sec-facet-scales",
    "title": "22  Facets",
    "section": "\n22.4 Scales",
    "text": "22.4 Scales\nBy default the scales for the x and y axes are “fixed” so that they are the same in all of the plot facets. Use the scales argument to change this behavior to be free in one dimension (\"free_x\", \"free_y\") or in both dimensions (\"free\"). Making scales free in one or both dimensions make it more difficult to see patterns across the facets, but it make it easier to see patterns within each facet.\nThe scales argument works slightly differently in facet_wrap() and facet_grid(). In facet_wrap() each plot gets its own scales. In facet_grid() the scales are maintained across a dimension. Note how facet_grid() maintains the labeling of scales on the left and bottom of the grid with \"free\" scales, while facet_wrap() must label the scales for each individual facet.\n\n# Free scales: facet_wrap()\np + \n  facet_wrap(vars(species_sex),\n             scales = \"free\") + \n  labs(title = \"facet_wrap()\")\n\n# Free scales: facet_grid()\np + \n  facet_grid(rows = vars(sex),\n             cols = vars(island),\n             scales = \"free\") + \n  labs(title = \"facet_grid()\")\n\n\n\n\n\n\n\n\n\n\n\n\n\nfacet_grid() has an additional feature through the space argument. The default is for the space of each plot to be \"fixed\" as equal in size even when scales = \"free\". The space taken up by each plot can be changed to \"free\", \"free_x\", or \"free_y\" so that less space is taken up by plots that have smaller scales.\n\np + \n  facet_grid(rows = vars(sex),\n             cols = vars(island),\n             scales = \"free\",\n             space = \"free\")",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Facets</span>"
    ]
  },
  {
    "objectID": "02-facets.html#sec-facet-other-data",
    "href": "02-facets.html#sec-facet-other-data",
    "title": "22  Facets",
    "section": "\n22.5 Including other data",
    "text": "22.5 Including other data\nOne way to compare each facet panel to the rest of the data is to include the whole data set grayed out. This can be done by adding another geom layer that does not include the faceting variable.\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  geom_point(data = select(penguins, -island),\n             aes(shape = species),\n             color = \"gray80\") + \n  geom_point(aes(color = species, shape = species)) + \n  theme(legend.position = \"none\") + \n  facet_wrap(vars(island))\n\n\n\n\n\n\n\nThe process is the same with facet_grid():\n\npenguins |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g)) + \n  geom_point(data = select(penguins, -island, -sex),\n             aes(shape = species),\n             color = \"gray80\") + \n  geom_point(aes(color = species, shape = species)) + \n  theme(legend.position = \"none\") + \n  facet_grid(rows = vars(sex),\n             cols = vars(island))\n\n\n\n\n\n\n\nThis process can be done automatically with gghighlight, see Annotations: gghighlight.\n\np + \n  gghighlight(use_direct_label = FALSE) + \n  facet_wrap(vars(island))\n\np + \n  gghighlight(use_direct_label = FALSE) + \n  facet_grid(rows = vars(sex),\n             cols = vars(island))",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Facets</span>"
    ]
  },
  {
    "objectID": "02-facets.html#sec-facet-label",
    "href": "02-facets.html#sec-facet-label",
    "title": "22  Facets",
    "section": "\n22.6 Labeling facets",
    "text": "22.6 Labeling facets\n\n22.6.1 Label position\nTo change the position of the labels use strip.position in facet_wrap() and switch in facet_grid(). strip.position takes any of the four sides: \"top\", \"bottom\", \"left\", \"right\".\n\np + \n  facet_wrap(vars(island),\n             strip.position = \"left\")\n\n\n\n\n\n\n\nBy default, facet_grid() positions the labels of two-dimensional grids on the top and right. You can change to use of the bottom, left, or both with switch. switch takes one of \"x\", to move the labels along the x-axis to the bottom, \"y\", to move the labels along the y-axis to the left, or \"both\" to change the placement of both the x and y axes.\n\np + \n  facet_grid(rows = vars(sex),\n             cols = vars(island),\n             switch = \"x\")\n\n\n\n\n\n\n\n\n22.6.2 Labeller\nThe labeller argument allows you to control and tweak the labels used for the facets. You can use the labeller() function to modify the labels, creating your own changes. There are also a set of helper labeling functions. The most important are label_value(), the default, and label_both(), which uses both the variable name and the value. These can be used in a variety of ways: as arguments within labeller() or directly in the labeller argument. The difference is in the control that you have.\n\np + \n  facet_grid(rows = vars(sex),\n             cols = vars(island),\n             labeller = labeller(sex = label_both))\n\np + \n  facet_grid(rows = vars(sex),\n             cols = vars(island),\n             labeller = label_both)\n\n\n\n\n\n\n\n\n\n\n\n\n\nlabel_context() is another useful option. It only used label_both when multiple variables are faceted along one axis.\n\np + \n  facet_grid(rows = vars(year),\n             cols = vars(island, sex),\n             labeller = label_context) + \n  scale_x_continuous(n.breaks = 4)\n\n\n\n\n\n\n\nYou can also create your own transformation with either a look-up table or with a functional change. For instance, change “female” and “male” labels to be capitalized with stringr. See the example in Cédric Scherer’s RStudio conf 2022 ggplot2 workshop, Section 13.7.4.\n\np + \n    facet_grid(rows = vars(sex),\n               cols = vars(island),\n               labeller = labeller(\n                 sex = stringr::str_to_title))",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Facets</span>"
    ]
  },
  {
    "objectID": "02-facets.html#facet-theme-elements",
    "href": "02-facets.html#facet-theme-elements",
    "title": "22  Facets",
    "section": "\n22.7 Facet theme elements",
    "text": "22.7 Facet theme elements\nSee Section 23.5.7 for more information on theme elements that affect faceted plots. The main elements are strip.background, which uses element_rect(), strip.text, and panel.spacing.\n\np + \n    facet_grid(rows = vars(sex),\n               cols = vars(island)) + \n  theme(\n    strip.background = element_rect(fill = \"ivory\", color = \"salmon\"),\n    strip.text = element_text(color = \"firebrick\"),\n    panel.spacing.x = unit(0.05, \"npc\")\n    )\n\n\n\n\n\n\n\n\n22.7.1 ggtext\nIf you want to get fancy with the labels, they can be replaced with text boxes from the ggtext package. See Section 23.9 for more on using ggtext theme elements. The ggtext README provides a good example of creating text boxes for facet labels. element_textbox() is used instead of element_markdown() so that the width of the labels can be controlled. To produce labels along both x and y axes it is necessary to create text boxes for both strip.text.x and strip.text.y and to make sure that the y-axis labels are oriented \"right-rotated\".1 The arguments for these labels are taken directly from the ggtext README.\n\np + \n    facet_grid(rows = vars(sex),\n               cols = vars(island)) + \n  theme(\n    strip.background = element_blank(),\n    strip.text.x = ggtext::element_textbox(\n      size = 12,\n      color = \"white\", fill = \"#5D729D\", box.color = \"#4A618C\",\n      halign = 0.1, linetype = 1, r = unit(5, \"pt\"),\n      width = unit(1, \"npc\"),\n      padding = margin(2, 0, 1, 0),\n      margin = margin(3, 3, 3, 3)\n    ),\n    strip.text.y = ggtext::element_textbox(\n      size = 12,\n      color = \"white\", fill = \"#5D729D\", box.color = \"#4A618C\",\n      orientation = \"right-rotated\",\n      halign = 0.1, linetype = 1, r = unit(5, \"pt\"),\n      width = unit(1, \"npc\"),\n      padding = margin(2, 0, 1, 0),\n      margin = margin(3, 3, 3, 3)\n    )\n  )\n\n\n\n\n\n\n\nThis can be mostly replicated with strip.background and strip.text, though without the roundrect shape, which is not possible with element_rect().\n\np + \n    facet_grid(rows = vars(sex),\n               cols = vars(island)) + \n  theme(\n    strip.background = element_rect(\n      fill = \"#5D729D\", color = \"#4A618C\"\n    ),\n    strip.text = element_text(\n      color = \"white\", size = 12,\n      hjust = 0\n      )\n  )",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Facets</span>"
    ]
  },
  {
    "objectID": "02-facets.html#footnotes",
    "href": "02-facets.html#footnotes",
    "title": "22  Facets",
    "section": "",
    "text": "Just using strip.text, as done in the README, does not create labels on the y axis.↩︎",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>Facets</span>"
    ]
  },
  {
    "objectID": "02-themes.html",
    "href": "02-themes.html",
    "title": "23  Themes",
    "section": "",
    "text": "23.1 Resources",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Themes</span>"
    ]
  },
  {
    "objectID": "02-themes.html#sec-theme-resources",
    "href": "02-themes.html#sec-theme-resources",
    "title": "23  Themes",
    "section": "",
    "text": "theme() documentation\ntheme() code\nTheme elements functions\nWickham, ggplot2 book: Themes\nR for Data Science: Communication, Themes\nScherer, ggplot2 Tutorial: Themes\nThomas Mock - Creating and using custom ggplot2 themes\nggplot2 Theme Elements Reference Sheet\n\nggplot2 Theme Elements\n\n\nIsabella Benabaye - ggplot2 Theme Elements Reference Sheet",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Themes</span>"
    ]
  },
  {
    "objectID": "02-themes.html#sec-theme-baseplot",
    "href": "02-themes.html#sec-theme-baseplot",
    "title": "23  Themes",
    "section": "\n23.2 Base plot",
    "text": "23.2 Base plot\n\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(palmerpenguins)\nlibrary(systemfonts)\nlibrary(ggtext)\nlibrary(glue)\n# Base plot\np &lt;- penguins |&gt; \n  filter(!is.na(flipper_length_mm),\n         !is.na(sex)) |&gt; \n  ggplot(aes(x = flipper_length_mm,\n             y = body_mass_g,\n             color = species,\n             shape = sex)) + \n  geom_point() + \n  labs(title = \"Penguin Size\",\n       x = \"Flipper length (mm)\",\n       y = \"Body mass (g)\",\n       color = \"Penguin species\",\n       shape = \"Sex\")\n\nDefault plot uses theme_grey()",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Themes</span>"
    ]
  },
  {
    "objectID": "02-themes.html#sec-theme-inheritance",
    "href": "02-themes.html#sec-theme-inheritance",
    "title": "23  Themes",
    "section": "\n23.3 Theme inheritance",
    "text": "23.3 Theme inheritance\nTheme elements inherit properties from other theme elements hierarchically. For example, axis.title.x.bottom inherits from axis.title.x which inherits from axis.title, which in turn inherits from text. All text elements inherit directly or indirectly from text; all lines inherit from line, and all rectangular objects inherit from rect. This means that you can modify the appearance of multiple elements by setting a single high-level component.",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Themes</span>"
    ]
  },
  {
    "objectID": "02-themes.html#sec-theme-elements",
    "href": "02-themes.html#sec-theme-elements",
    "title": "23  Themes",
    "section": "\n23.4 Theme elements",
    "text": "23.4 Theme elements\nTheme elements documentation: These functions are used to modify arguments in theme().\n\n\nelement_blank(): draws nothing, and assigns no space.\n\nelement_rect(): borders and backgrounds.\n\nArguments: fill, color, linewidth, linetype\n\n\n\nelement_line(): lines.\n\nArguments: fill, color, linewidth, linetype, lineend, arrow\n\n\n\nelement_text(): text.\n\nArguments: family, face, color, size, hjust, vjust, angle, lineheight, margin\n\n\n\nrel(): Specify sizes relative to the parent\n\ne.g. plot.title = element_text(size = rel(2)) to make size of plot title twice as big.\n\n\nmargin(t = 0, r = 0, b = 0, l = 0, unit = \"pt\")",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Themes</span>"
    ]
  },
  {
    "objectID": "02-themes.html#sec-theme-components",
    "href": "02-themes.html#sec-theme-components",
    "title": "23  Themes",
    "section": "\n23.5 Components of a theme",
    "text": "23.5 Components of a theme\nArguments in theme(). Not all levels of the argument hierarchy are presented here.\n\n23.5.1 General\nHigh level arguments in the theme hierarchy:\n\n\nrect: element_rect()\n\n\nline: element_line()\n\n\ntext: element_text()\n\n\ntitle: element_text() all title elements: plot, axes, legends\n\naspect.ratio: aspect ratio of the panel\n\n23.5.2 Axes\n\n\naxis.title: title of axes\n\naxis.text: tick labels along axes\n\naxis.ticks: tick marks element_line()\n\n\naxis.line: lines along axes\n\n\np + \n  theme(axis.title = element_text(face = \"bold\"),\n        axis.text = element_text(color = \"orange\"),\n        axis.text.x = element_text(angle = -90, vjust = 0.5,\n                                   margin = margin(t = 3)),\n        axis.ticks = element_line(color = \"red\"),\n        axis.ticks.length.y = unit(0.25, \"cm\"),\n        axis.ticks.length.x = unit(-0.25, \"cm\"),\n        axis.line = element_line(linewidth = 3, colour = \"grey80\")\n        )\n\n\n\n\n\n\n\n\n23.5.3 Legend\nFor a full discussion of legends see Chapter 21 and specifically Section 21.9.\nRemove legend\n\np + \n  theme(legend.position = \"none\")\n\n\n\n\n\n\n\nLegend arguments\n\nLegend layout: see Section 21.5\n\n\nlegend.position: the position of legends – \"none\", \"left\", \"right\", \"bottom\", \"top\", or two-element character or numeric vector\n\nlegend.direction: \"horizontal\" or \"vertical\"\n\n\nlegend.justification: anchor point for positioning legend\n\n\nBounding box of all legends\n\n\nlegend.box: arrangement of multiple legends (\"horizontal\" or \"vertical\")\n\nlegend.box.background: background of full legend area\n\nlegend.box.just: justification of each legend within the overall bounding box\n\nlegend.box.margin: margins around the full legend bounding box\n\nlegend.box.spacing: The spacing between the plotting area and the full legend bounding box\n\n\nBounding box of each legend\n\nlegend.background\n\nlegend.margin: the margin around each legend\n\nlegend.spacing: spacing between legends if there are multiple legends\n\n\nLegend keys: see Section 21.6.3\n\n\nlegend.key: background underneath legend keys (symbols of geoms)\n\nlegend.key.size, legend.key.height, and legend.key.width\n\n\n\nLegend text: see Section 21.7\n\n\nlegend.text: legend item labels\n\nlegend.text.align: alignment of legend labels (number from 0 (left) to 1 (right))\n\nlegend.title: legend title\n\nlegend.title.align: alignment of legend title\n\n\n\n\np + \n  theme(legend.position = \"bottom\",\n        legend.direction = \"vertical\",\n        legend.justification = \"left\",\n        legend.box.background = element_rect(linetype = \"dashed\"),\n        legend.box.margin = margin(6, 6, 6, 6),\n        legend.background = element_rect(color = \"orange\", fill = \"lightgrey\"),\n        legend.key = element_rect(fill = \"lightblue\", color = \"black\"),\n        legend.title = element_text(size = rel(1.5)),\n        legend.text = element_text(color = \"firebrick\")\n        )\n\n\n\n\n\n\n\nPlace legend in the plot by positioning it at the bottom-right of the plot with legends justified to the right.\n\np + \n  theme(legend.position = c(1, 0), # position on right, bottom\n        legend.justification = c(\"right\", \"bottom\"), # anchor point\n        # same as legend.justification = c(1, 0),\n        legend.box.just = \"right\", # justification of legends in box\n        legend.spacing = unit(0, unit = \"lines\")\n        )\n\n\n\n\n\n\n\n\n23.5.4 Plot title and metadata\nPlots can have a number of plot labels: title, subtitle, caption, and tag.\n\n\nplot.title\n\n\nplot.title.position: Applies to both title and subtitle\n\n\n\"panel\" (default): Aligns to plotting region\n\n\"plot\": Aligns to entire plot\n\n\n\n\nplot.subtitle\n\nplot.caption: caption below the plot\n\nplot.tag: upper-left label to identify a plot\n\n\nplot.tag.position: \"topleft\", \"top\", \"topright\", \"left\", \"right\", \"bottomleft\", \"bottom\", \"bottomright\", or a coordinate\n\n\n\n\np + \n  labs(subtitle = \"Flipper length and body mass of penguins\",\n       caption = \"Caption: Palmer Station LTER\",\n       tag = \"Tag: ex. plot\") + \n  theme(plot.title.position = \"plot\",\n        plot.title = element_text(hjust = 1,\n                                  color = \"firebrick\",\n                                  family = \"mono\"),\n        plot.subtitle = element_text(hjust = 1,\n                                     color = \"orchid\",\n                                     family = \"serif\"),\n        plot.caption = element_text(color = \"salmon\", size = 11),\n        plot.caption.position = \"panel\", # the default\n        plot.tag = element_text(family = \"mono\"),\n        plot.tag.position = \"bottomleft\")\n\n\n\n\n\n\n\n\n23.5.5 Panel: Plotting area\nThe panel encompasses the area in which the data is plotted. The main elements that will be changed are the color of the background (panel.background) and the major and minor grid drawn on the panel (panel.grid).\n\n\npanel.background: background of plotting area, drawn underneath plot\n\npanel.border: border around plotting area, drawn on top of plot so that it covers tick marks and grid lines.\n\nTherefore you need to assign fill = NA when overriding panel.border.\n\n\n\npanel.grid: element_line()\n\npanel.grid.major\npanel.grid.minor\n\n\n\npanel.ontop: logical option to place the panel (background, gridlines) over the data layers.\n\nNote the difference between the panel, which has a fill of “lightsteelblue” and outlined in a dotted line, and the plot, which is outlined in “forestgreen”.\n\np + \n  theme(panel.background = element_rect(fill = \"lightsteelblue\"),\n        panel.border = element_rect(linetype = \"dashed\", fill = NA),\n        panel.grid.major = element_line(color = \"firebrick\"),\n        panel.grid.major.x = element_line(linewidth = 1.5),\n        panel.grid.minor = element_blank(),\n        plot.background = element_rect(color = \"forestgreen\", linewidth = 2)\n        )\n\n\n\n\n\n\n\n\n23.5.6 Plot: Whole area of the plot\n\n\nplot.background: background of the entire plot\n\nplot.margin: margin around entire plot\n\nAs above, notice the difference between the panel and the plot. The panel fill is “transparent” (can also use NA) to show plot.background covers the whole plot area.\n\np + \n  theme(panel.background = element_rect(fill = \"transparent\",\n                                        color = \"forestgreen\",\n                                        linewidth = 2),\n        plot.background = element_rect(fill = \"lightsteelblue\",\n                                       color = \"black\",\n                                       linetype = \"dashed\"),\n        plot.margin = margin(t = 0.5, r = 1, b = 0.5, l = 1, unit = \"cm\")\n        )\n\n\n\n\n\n\n\n\n23.5.7 Facets: Strip\n\n\nstrip.background: Background of panel strips (element_rect())\n\nstrip.text: Text in the strips\n\nstrip.placement: placement of strip with respect to axes, either “inside” or “outside”. Only important when axes and strips are on the same side of the plot.\n\npanel.spacing: spacing between facet panels\n\n\np + \n  facet_wrap(~ sex)\n\n\n\n\n\n\n\n\np + \n  facet_wrap(~ sex) + \n  theme(strip.background = element_rect(fill = \"ivory\", color = \"salmon\"),\n        strip.text = element_text(color = \"firebrick\"),\n        panel.spacing = unit(1, \"lines\")\n        )",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Themes</span>"
    ]
  },
  {
    "objectID": "02-themes.html#sec-complete-themes",
    "href": "02-themes.html#sec-complete-themes",
    "title": "23  Themes",
    "section": "\n23.6 Complete themes",
    "text": "23.6 Complete themes\nDocumentation for complete themes\n\n\ntheme_gray(): default\ntheme_bw()\ntheme_linedraw()\ntheme_light()\ntheme_dark()\ntheme_minimal()\ntheme_classic()\ntheme_void()\n\nA good way to explore aspects of themes is to look at the code of the theme functions. Use theme_grey to explore all aspects of the default themes. See also the code for themes on GitHub.\nTheme arguments: Changes to text size, text font, lines, and rects.\n\nbase_size = 11\nbase_family\nbase_line_size = base_size/22\nbase_rect_size = base_size/22\n\n\ntheme_bw\n#&gt; function (base_size = 11, base_family = \"\", base_line_size = base_size/22, \n#&gt;     base_rect_size = base_size/22) \n#&gt; {\n#&gt;     theme_grey(base_size = base_size, base_family = base_family, \n#&gt;         base_line_size = base_line_size, base_rect_size = base_rect_size) %+replace% \n#&gt;         theme(panel.background = element_rect(fill = \"white\", \n#&gt;             colour = NA), panel.border = element_rect(fill = NA, \n#&gt;             colour = \"grey20\"), panel.grid = element_line(colour = \"grey92\"), \n#&gt;             panel.grid.minor = element_line(linewidth = rel(0.5)), \n#&gt;             strip.background = element_rect(fill = \"grey85\", \n#&gt;                 colour = \"grey20\"), legend.key = element_rect(fill = \"white\", \n#&gt;                 colour = NA), complete = TRUE)\n#&gt; }\n#&gt; &lt;bytecode: 0x113e2d648&gt;\n#&gt; &lt;environment: namespace:ggplot2&gt;\n\n\n23.6.1 Light themes\nThe light themes are all very similar. theme_bw() and theme_linedraw() have a black border around the plot panel. The other differences are in the width and color of the grid lines.\n\nCodep + \n  ggtitle(\"theme_bw()\") + \n  theme_bw()\n\n\n\n\n\n\n\n\nCodep + \n  ggtitle(\"theme_linedraw()\") + \n  theme_linedraw()\n\n\n\n\n\n\n\n\nCodep + \n  ggtitle(\"theme_light()\") + \n  theme_light()\n\n\n\n\n\n\n\n\n23.6.2 Minimal themes\nNone of these themes have a panel border. theme_minimal() has grid lines. theme_classic() does not have grid lines and has x- and y-axis lines. theme_void() is completely empty.\n\nCodep + \n  ggtitle(\"theme_minimal()\") + \n  theme_minimal()\n\n\n\n\n\n\n\n\nCodep + \n  ggtitle(\"theme_classic()\") + \n  theme_classic()\n\n\n\n\n\n\n\n\nCodep + \n  ggtitle(\"theme_void()\") + \n  theme_void()\n\n\n\n\n\n\n\n\n23.6.3 Theme packages\n\nggthemes\nhrbrthemes",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Themes</span>"
    ]
  },
  {
    "objectID": "02-themes.html#sec-set-theme",
    "href": "02-themes.html#sec-set-theme",
    "title": "23  Themes",
    "section": "\n23.7 Setting themes",
    "text": "23.7 Setting themes\n\n\ntheme_set(): completely overrides the current theme.\n\ntheme_update(): Update individual elements of a plot. Any unspecified values in the theme element will default to the values set in the current theme.\n\ntheme_replace(): Modifies a particular element of the current theme using the %+replace% operator to completely replace the element, so any unspecified values will overwrite the current value in the theme with NULL.\n\ntheme_update() also returns the previous theme parameters, so you can easily restore the original parameters once you are done by using theme_set() again.\n\n# Set theme for remaining plots \ntheme_set(theme_light())\n\n# Update theme\nog_theme &lt;- theme_update(\n  panel.grid.minor = element_blank(),\n  plot.title = element_text(face = \"bold\"),\n  legend.position = \"top\",\n  legend.box = \"vertical\",\n  legend.box.just = \"left\",\n  legend.spacing = grid::unit(0, \"lines\"),\n  plot.title.position = \"plot\"\n)\np\n\n\n\n\n\n\n\nReturn to old theme.\n\ntheme_set(og_theme)\np\n\n\n\n\n\n\n\n\n23.7.1 Reusing themes\nSince update_theme() essentially uses +, the function and the operator can be used somewhat interchangeably. This opens up the ability to save a theme layer and reuse it just as you would with any other plot layer.\n\n# Save theme layer\nmy_theme &lt;- theme_light() + \n  theme(panel.grid.minor = element_blank(),\n        plot.title = element_text(face = \"bold\"),\n        legend.position = \"bottom\",\n        plot.title.position = \"plot\")\n\np + my_theme",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Themes</span>"
    ]
  },
  {
    "objectID": "02-themes.html#sec-fonts",
    "href": "02-themes.html#sec-fonts",
    "title": "23  Themes",
    "section": "\n23.8 Fonts",
    "text": "23.8 Fonts\n\nsystemfonts\nragg\nModern Text Features in R\nJune Choe - Setting up and debugging custom fonts\n\nThe packages systemfonts and ragg from Posit work together to give RStudio access to the fonts on your system and use them within plots. This works seemlessly for the most part once you install the packages and tell RStudio to use AGG as its graphic device. This is done in Settings -&gt; General -&gt; Graphics -&gt; Backend. To use ragg in knitr and quarto set knitr::opts_chunk$set(dev = \"ragg_png\").\nUse system_fonts() to list all fonts available on your system. A good workflow is to look for family of fonts using stringr::str_detect().\n\nsystem_fonts() |&gt; \n  filter(stringr::str_detect(family, \"Garamond\")) |&gt; \n  select(-path)\n#&gt; # A tibble: 10 × 8\n#&gt;    index name                       family   style weight width italic monospace\n#&gt;    &lt;int&gt; &lt;chr&gt;                      &lt;chr&gt;    &lt;chr&gt; &lt;ord&gt;  &lt;ord&gt; &lt;lgl&gt;  &lt;lgl&gt;    \n#&gt;  1     1 EBGaramondItalic-Medium    EB Gara… Medi… medium norm… TRUE   FALSE    \n#&gt;  2     3 EBGaramondItalic-Bold      EB Gara… Bold… bold   norm… TRUE   FALSE    \n#&gt;  3     4 EBGaramondItalic-ExtraBold EB Gara… Extr… ultra… norm… TRUE   FALSE    \n#&gt;  4     1 EBGaramondRoman-Medium     EB Gara… Medi… medium norm… FALSE  FALSE    \n#&gt;  5     0 EBGaramond-Regular         EB Gara… Regu… normal norm… FALSE  FALSE    \n#&gt;  6     0 EBGaramond-Italic          EB Gara… Ital… normal norm… TRUE   FALSE    \n#&gt;  7     3 EBGaramondRoman-Bold       EB Gara… Bold  bold   norm… FALSE  FALSE    \n#&gt;  8     2 EBGaramondItalic-SemiBold  EB Gara… Semi… semib… norm… TRUE   FALSE    \n#&gt;  9     4 EBGaramondRoman-ExtraBold  EB Gara… Extr… ultra… norm… FALSE  FALSE    \n#&gt; 10     2 EBGaramondRoman-SemiBold   EB Gara… Semi… semib… norm… FALSE  FALSE\n\np + \n  theme_light(\n    base_family = \"EB Garamond\")\np + \n  theme_light(\n    base_family = \"Roboto Condensed\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n23.8.1 Registering font variants\nThere may be times when you want to use a certain variant of a font. You can do this with either register_font() or register_variant(). For instance, you can get access to the Black variant of Source Code Pro. You first need to find the font with system_fonts() and then register it with a new name, here “Source Code Black”. You can then use that name as the base_family.\n\nsystem_fonts() |&gt; \n  filter(family == \"Source Code Pro\") |&gt; \n  select(name, weight)\n#&gt; # A tibble: 14 × 2\n#&gt;    name                       weight  \n#&gt;    &lt;chr&gt;                      &lt;ord&gt;   \n#&gt;  1 SourceCodePro-Bold         bold    \n#&gt;  2 SourceCodePro-Regular      normal  \n#&gt;  3 SourceCodePro-Light        normal  \n#&gt;  4 SourceCodePro-Black        heavy   \n#&gt;  5 SourceCodePro-Medium       medium  \n#&gt;  6 SourceCodePro-MediumIt     medium  \n#&gt;  7 SourceCodePro-BlackIt      heavy   \n#&gt;  8 SourceCodePro-BoldIt       bold    \n#&gt;  9 SourceCodePro-Semibold     semibold\n#&gt; 10 SourceCodePro-ExtraLight   light   \n#&gt; 11 SourceCodePro-SemiboldIt   semibold\n#&gt; 12 SourceCodePro-LightIt      normal  \n#&gt; 13 SourceCodePro-It           normal  \n#&gt; 14 SourceCodePro-ExtraLightIt light\n\nregister_variant(\n    name = \"Source Code Black\", \n    family = \"Source Code Pro\", \n    weight = \"heavy\")\n\nregistry_fonts() |&gt; \n  select(family, style)\n#&gt; # A tibble: 4 × 2\n#&gt;   family            style      \n#&gt;   &lt;chr&gt;             &lt;chr&gt;      \n#&gt; 1 Source Code Black Regular    \n#&gt; 2 Source Code Black Bold       \n#&gt; 3 Source Code Black Italic     \n#&gt; 4 Source Code Black Bold Italic\n\np + \n  theme_light(\n    base_family = \"Source Code Pro\")\np + \n  theme_light(\n    base_family = \"Source Code Black\")",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Themes</span>"
    ]
  },
  {
    "objectID": "02-themes.html#sec-theme-ggtext",
    "href": "02-themes.html#sec-theme-ggtext",
    "title": "23  Themes",
    "section": "\n23.9 ggtext",
    "text": "23.9 ggtext\nThe ggtext package provides two theme elements functions to render markdown and HTML in plot guides. They are alternatives to element_text(). In addition, the package provides two geoms that replace geom_label(), see Section 15.6. In both the geoms and the theme elements ggtext provides two alternatives: markdown text labels and markdown text boxes with word wrapping.\nThe theme elements functions are element_markdown() and element_textbox() with a third option to use element_textbox_simple() that provides common defaults for element_textbox().\nThese theme elements will mostly be used for labeling x and y axes and for adding information to titles of plots. They work by providing these labels with marked up text and then adding element_markdown() or element_textbox_simple() to the corresponding theme argument.\n\n23.9.1 Supported HTML\n\nBold and italic fonts\n\nBold: **bold text**\n\nItalic: *italic text*\n\n\n\nChange fonts\n\n&lt;span style = 'font-size:14pt; font-family:Helvetica;'&gt;font and size&lt;/span&gt;\n\n\nFont color and size:\n\ncolor: &lt;span style='color:blue'&gt;colored text&lt;/span&gt;\n\nsize: &lt;span style='font-size:18pt'&gt;larger text&lt;/span&gt;\n\n\n\nSuper and subscript text\n\n&lt;sup&gt;super&lt;/sup&gt;\n&lt;sub&gt;2&lt;/sub&gt;\n\n\nLine breaks: &lt;br&gt;\n\nSome image support\n\n&lt;img src=\"image-source.jpg\" /&gt;\n\n\n\n23.9.2 element_markdown()\n\nSimple Markdown can be added to the labels used in the base plot by adding the Markdown in labs() and then adding element_markdown(). Making the whole labels bold accomplishes the same as can be done with theme elements, but interspersing italics is different.\n\np + \n  labs(title = \"**Penguin Size**\",\n       x = \"Flipper length (*mm*)\",\n       y = \"Body mass (*g*)\",\n       color = \"**Penguin species**\",\n       shape = \"**Sex**\") + \n  theme(plot.title = element_markdown(),\n        axis.title.x = element_markdown(),\n        axis.title.y = element_markdown(),\n        legend.title = element_markdown())\n\n\n\n\n\n\n\nA common use for ggtext is to include colored text that matches the colors used within the plot as an alternative to using a legend. A good workflow to do this is to extract the color palette used in the plot and use the glue package to specify the colors to be used. An example is to remove the Species legend and place this information in the plot title/subtitle. This example creates a title and subtitle in one string. It uses CSS to define a larger font size for the title, while setting a smaller font size for the subtitle in element_markdown(). The expanded line height gives more room for both the title and subtitle. Because element_markdown() does not use word wrapping, it may be necessary to insert line breaks within the subtitle.\n\nhex &lt;- scales::hue_pal()(3)\nstyled_title &lt;- glue(\n  \"&lt;span style = 'font-size:14pt'&gt;Penguin size&lt;/span&gt;&lt;br&gt;\n  The body mass (*g*) compared to flipper length (*mm*) of&lt;br&gt;\n  &lt;span style='color:{hex[[1]]};'&gt;Adelie&lt;/span&gt;,\n  &lt;span style='color:{hex[[2]]};'&gt;Chinstrap&lt;/span&gt;, and\n  &lt;span style='color:{hex[[3]]};'&gt;Gentoo&lt;/span&gt; penguins.\"\n)\n\np + \n  guides(color = \"none\") + \n  labs(title = styled_title,\n       x = \"Flipper length (*mm*)\",\n       y = \"Body mass (*g*)\",\n       shape = \"**Sex**\") + \n  theme(plot.title = element_markdown(size = 11, lineheight = 1.2),\n        axis.title.x = element_markdown(),\n        axis.title.y = element_markdown(),\n        legend.title = element_markdown())\n\n\n\n\n\n\n\nAnother option is to color the axis text on a bar plot by modifying the group names, in this case the species, with markup using glue(). There are a couple of tricks here. Using sort = TRUE in count() helps to keep the sequence of the palette colors consistent. Placing the colors in a column and using scale_fill_identity() ensures that the colors of the axis text are correctly aligned with the fill of the bars. fct_reorder() places the bars in descending order and reconverts the species column to a factor; glue() casts the column to class glue.\n\nlibrary(forcats)\npenguins |&gt; \n  count(species, sort = TRUE) |&gt; \n  mutate(color = scales::hue_pal()(3),\n         species = glue(\n           \"&lt;span style='color:{color};'&gt;**{species}**&lt;/span&gt;\"),\n         species = fct_reorder(species, n, .desc = TRUE)) |&gt; \n  ggplot(aes(x = species, y = n,\n             fill = color)) + \n  geom_col() + \n  scale_fill_identity() +\n  guides(fill = \"none\") + \n  theme(axis.text.x = element_markdown())\n\n\n\n\n\n\n\n\n23.9.3 element_textbox()\n\nelement_markdown() will likely cover most cases, but you can use element_textbox() or element_textbox_simple() to create text boxes that have a specific width and use word wrapping. This is useful for longer labels. For example, we can expand on the above title to include more information. If the subtitle gets long, it may be necessary to add padding to the title. This example adds 10 points to the bottom margin.\n\nlonger_styled_title &lt;- glue(\n  \"&lt;span style = 'font-size:14pt'&gt;Penguin size&lt;/span&gt;&lt;br&gt;\n  The body mass (*g*) compared to flipper length (*mm*) of\n  &lt;span style='color:{hex[[1]]};'&gt;Adelie&lt;/span&gt;,\n  &lt;span style='color:{hex[[2]]};'&gt;Chinstrap&lt;/span&gt;, and\n  &lt;span style='color:{hex[[3]]};'&gt;Gentoo&lt;/span&gt; penguins\n  on the islands of Biscoe, Dream, and Torgersen off the\n  coast of Antartica.\"\n)\n\np + \n  guides(color = \"none\") + \n  labs(title = longer_styled_title,\n       x = \"Flipper length (*mm*)\",\n       y = \"Body mass (*g*)\",\n       shape = \"**Sex**\") + \n  theme(\n    plot.title = element_textbox_simple(size = 11, lineheight = 1,\n                                        padding = margin(0, 0, 10, 0)),\n    axis.title.x = element_markdown(),\n    axis.title.y = element_markdown(),\n    legend.title = element_markdown()\n    )\n\n\n\n\n\n\n\nText boxes can also have a background color and border. Because element_textbox() has word wrapping, the width of the box can also be restricted.\n\np + \n  guides(color = \"none\") + \n  labs(title = longer_styled_title,\n       x = \"Flipper length (*mm*)\",\n       y = \"Body mass (*g*)\",\n       shape = \"**Sex**\") + \n  theme(\n    plot.title = element_textbox_simple(\n      size = 11, lineheight = 1,\n      width = grid::unit(3, \"in\"), # fixed width\n      hjust = 1, # alignment of box relative to plot\n      linetype = 1, # turn on border\n      fill = \"darkseagreen1\", # background fill color\n      r = grid::unit(3, \"pt\"), # radius for rounded corners\n      padding = margin(5, 5, 5, 5), # padding around text inside the box\n      margin = margin(0, 0, 10, 0) # margin outside the box\n    ),\n    axis.title.x = element_markdown(),\n    axis.title.y = element_markdown(),\n    legend.title = element_markdown()\n    )\n\n\n\n\n\n\n\nSee Section 22.7.1 for an example of using element_textbox() to provide labels for a faceted plot.",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>Themes</span>"
    ]
  },
  {
    "objectID": "02-patchwork.html",
    "href": "02-patchwork.html",
    "title": "\n24  patchwork\n",
    "section": "",
    "text": "24.1 Patchwork functions",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>patchwork</span>"
    ]
  },
  {
    "objectID": "02-patchwork.html#patchwork-functions",
    "href": "02-patchwork.html#patchwork-functions",
    "title": "\n24  patchwork\n",
    "section": "",
    "text": "24.1.1 Composing plots\n\n\n+: Add plots in row order\n\n|: Place plots beside each other\n\n-: Used to keep each side from each other when building complex plots\n\n/: Place plots on top of each other\n\n&: Apply elements to all subplots in the composition\n\n*: Apply elements to all subplots in the current nesting level\n\nUsing + to add elements of a plot will affect the last plot\n\n\n\n(): Use parentheses to group plots\n\n24.1.2 Composing plots with functions\n\n\nwrap_plots(): Provides a functional way to construct plot\n\ninset_element(): Add inset graphics\n\nplot_spacer(): Add an empty element to a composition.\n\n24.1.3 Layout specifications\n\n\nplot_layout(): Adjust the layout, widths and heights\nUse text layouts to create custom layouts\n\nplot_annotation(): Add tags and general labels`",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>patchwork</span>"
    ]
  },
  {
    "objectID": "02-patchwork.html#setup",
    "href": "02-patchwork.html#setup",
    "title": "\n24  patchwork\n",
    "section": "\n24.2 Setup",
    "text": "24.2 Setup\n\nlibrary(patchwork)\nlibrary(tidyverse)\nlibrary(ggtext)\nlibrary(glue)\n\n# Data\nbikes &lt;- readr::read_csv(\n  here::here(\"data\", \"london-bikes-custom.csv\"),\n  col_types = \"Dcfffilllddddc\"\n)\n\nbikes$season &lt;- forcats::fct_inorder(bikes$season)\nbikes_sorted &lt;- bikes  |&gt; \n  filter(!is.na(weather_type)) |&gt;\n  group_by(weather_type) |&gt;\n  mutate(sum = sum(count)) |&gt;\n  ungroup() |&gt;\n  mutate(\n    weather_type = forcats::fct_reorder(\n      str_to_title(str_wrap(weather_type, 5)), sum\n    )\n  )\n\n\n24.2.1 Make the plots\n\nCode# Theme\ntheme_std &lt;- theme_set(theme_minimal(base_size = 18))\ntheme_update(\n  panel.grid = element_blank(),\n  axis.text = element_text(color = \"grey50\", size = 12),\n  axis.title = element_text(color = \"grey40\", face = \"bold\"),\n  axis.title.x = element_text(margin = margin(t = 12)),\n  axis.title.y = element_text(margin = margin(r = 12)),\n  axis.line = element_line(color = \"grey80\", linewidth = 0.4),\n  legend.text = element_text(color = \"grey50\", size = 12),\n  plot.tag = element_text(size = 40, margin = margin(b = 15)),\n  plot.background = element_rect(fill = \"white\", color = \"white\")\n)\n\np1 &lt;- ggplot(\n    bikes_sorted,\n    aes(x = weather_type, y = count, color = weather_type)\n  ) +\n  geom_hline(yintercept = 0, color = \"grey80\", size = .4) +\n  stat_summary(\n    geom = \"point\", fun = \"sum\", size = 12\n  ) +\n  stat_summary(\n    geom = \"linerange\", ymin = 0, fun.max = function(y) sum(y),\n    linewidth = 2, show.legend = FALSE\n  ) +\n  coord_flip(ylim = c(0, NA), clip = \"off\") +\n  scale_y_continuous(\n    expand = c(0, 0), limits = c(0, 8500000),\n    labels = scales::comma_format(scale = .0001, suffix = \"K\")\n  ) +\n  scale_color_viridis_d(\n    option = \"magma\", direction = -1, begin = .1, end = .9, name = NULL,\n    guide = guide_legend(override.aes = list(size = 7))\n  ) +\n  labs(\n    x = NULL, y = \"Sum of reported bike shares\", tag = \"P1\",\n  ) +\n  theme(\n    axis.line.y = element_blank(),\n    axis.text.y = element_text(color = \"grey50\", face = \"bold\",\n                               margin = margin(r = 15), lineheight = .9)\n  )\n#&gt; Warning: Using `size` aesthetic for lines was deprecated in ggplot2 3.4.0.\n#&gt; ℹ Please use `linewidth` instead.\n\np2 &lt;- bikes_sorted |&gt;\n  filter(season == \"winter\", is_weekend == TRUE, day_night == \"night\") |&gt;\n  group_by(weather_type, .drop = FALSE) |&gt;\n  mutate(id = row_number()) |&gt;\n  ggplot(\n      aes(x = weather_type, y = id, color = weather_type)\n    ) +\n    geom_point(size = 4.5) +\n    scale_color_viridis_d(\n      option = \"magma\", direction = -1, begin = .1, end = .9, name = NULL,\n      guide = guide_legend(override.aes = list(size = 7))\n    ) +\n    labs(\n      x = NULL, y = \"Reported bike shares on\\nweekend winter nights\", tag = \"P2\",\n    ) +\n    coord_cartesian(ylim = c(0.5, NA), clip = \"off\")\n\nmy_colors &lt;- c(\"#cc0000\", \"#000080\")\n\np3 &lt;- bikes |&gt;\n  group_by(week = lubridate::week(date), day_night, year) |&gt;\n  summarize(count = sum(count), .groups = \"drop_last\") |&gt;\n  mutate(avg = mean(count)) |&gt;\n  ggplot(aes(x = week, y = count,\n             group = interaction(day_night, year))) +\n    geom_line(color = \"grey65\", linewidth = 1) +\n    geom_line(aes(y = avg, color = day_night), stat = \"unique\", linewidth = 1.7) +\n    annotate(\n      geom = \"text\", label = c(\"Day\", \"Night\"), color = my_colors,\n      x = c(5, 18), y = c(125000, 29000),\n      size = 8, fontface = \"bold\",\n    ) +\n    scale_x_continuous(breaks = c(1, 1:10*5)) +\n    scale_y_continuous(labels = scales::comma_format()) +\n    scale_color_manual(values = my_colors, guide = \"none\") +\n    labs(\n      x = \"Week of the Year\", y = \"Reported bike shares\\n(cumulative # per week)\", tag = \"P3\",\n    )",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>patchwork</span>"
    ]
  },
  {
    "objectID": "02-patchwork.html#composing-plots-1",
    "href": "02-patchwork.html#composing-plots-1",
    "title": "\n24  patchwork\n",
    "section": "\n24.3 Composing plots",
    "text": "24.3 Composing plots\n\n(p1 + p2) / p3\n\n\n\n\n\n\n\nCollect the legends and place them on the composed plot. Note that the theme() is added with & to apply the theme to all subplots in the composition. Use * to apply elements to all subplots in the current nesting level. Use + to add element to the previous plot.\n\n((p1 + p2) / p3 & theme(legend.justification = \"top\")) + \n  plot_layout(guides = \"collect\")\n\n\n\n\n\n\n\nYou can apply a theme to all the plots using & theme().\n\n(p1 + p2) / p3 & \n  theme(legend.position = \"none\",\n        plot.background = element_rect(color = \"black\",\n                                       linewidth = 3)\n        )\n\n\n\n\n\n\n\nTo adjust the theme of the patchwork composition itself, such as modifying a title, use the theme argument in plot_annotation(). You can also use plot_annotation() to provide tags to the subplots.\n\n# Add titles to plots\npl1 &lt;- p1 + labs(tag = NULL, title = \"Plot One\") + \n  theme(legend.position = \"none\")\npl2 &lt;- p2 + labs(tag = NULL, title = \"Plot Two\") + \n  theme(legend.position = \"none\")\npl3 &lt;- p3 + labs(tag = NULL, title = \"Plot Three\") + \n  theme(legend.position = \"none\")\n\n(pl1 + pl2) / pl3 +\n  plot_annotation(\n    tag_levels = \"1\", tag_prefix = \"P\",\n    title = \"An overarching title for all 3 plots, placed on the very top while all other titles are sitting below the tags.\",\n    theme = theme(plot.title = element_text(size = 18))\n    )",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>patchwork</span>"
    ]
  },
  {
    "objectID": "02-patchwork.html#laying-out-plots",
    "href": "02-patchwork.html#laying-out-plots",
    "title": "\n24  patchwork\n",
    "section": "\n24.4 Laying out plots",
    "text": "24.4 Laying out plots\nSee the Controlling Layouts vignette.\nAdjust the widths and heights with plot_layout() using the widths and heights arguments to provide the relative widths and heights of each column and row in the grid.\n\n((p1 + p2) / p3 & theme(legend.position = \"none\")) +\n  plot_layout(heights = c(2, 1), widths = c(2, 1))\n\n\n\n\n\n\n\nYou can create a custom layout with a textual representation. # represents an empty area. Each plot is then represented by a capital letter in alphabetical order. Another way to do this is with the area() function, but textual representation gives options for many layouts.\n\npicasso &lt;- \"\nAAAAAA#BBBB\nCCCCCCCCC##\nCCCCCCCCC##\"\n\n(p1 + p2 + p3 & theme(legend.position = \"none\")) + \n  plot_layout(design = picasso)",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>patchwork</span>"
    ]
  },
  {
    "objectID": "02-patchwork.html#inserting-elements",
    "href": "02-patchwork.html#inserting-elements",
    "title": "\n24  patchwork\n",
    "section": "\n24.5 Inserting elements",
    "text": "24.5 Inserting elements\nYou can also add a plot of text with ggtext to add text directly to a composition, see the section on Insets in the Controlling Layouts vignette.\n\ntext &lt;- tibble(\n  x = 0, y = 0,\n  label = glue(\n    \"Lorem ipsum dolor sit amet, **consectetur adipiscing elit**, \",\n    \"sed do eiusmod tempor incididunt ut labore et dolore magna \",\n    \"aliqua. Ut enim ad minim veniam, quis nostrud exercitation \",\n    \"&lt;b style='color:#000080;'&gt;ullamco laboris nisi&lt;/b&gt; ut aliquip \",\n    \"ex ea commodo consequat. Duis aute irure dolor in reprehenderit \",\n    \"in voluptate velit esse cillum dolore eu fugiat nulla pariatur. \",\n    \"Excepteur sint occaecat &lt;b style='color:#cc0000;'&gt;cupidatat non \",\n    \"proident&lt;/b&gt;, sunt in culpa qui officia deserunt mollit anim id \",\n    \"est laborum.\"\n    )\n)\n\npt &lt;- ggplot(text, aes(x = x, y = y)) +\n  ggtext::geom_textbox(\n    aes(label = label),\n    box.color = NA, width = unit(23, \"lines\"),\n    color = \"grey40\", size = 6.5, lineheight = 1.4\n  ) +\n  coord_cartesian(expand = FALSE, clip = \"off\") +\n  theme_void()\n\n(p1 + pt) / p3\n\n\n\n\n\n\n\nAdd inset plots with inset_element()\n\npl1 + inset_element(pl2, l = .6, b = .1, r = 1, t = .6)\n\n\n\n\n\n\n\nPlots with insets can be added to larger compositions.\n\n(pl1 + inset_element(pl2, l = .6, b = .1, r = 1, t = .6) + pt) / pl3",
    "crumbs": [
      "ggplot2",
      "<span class='chapter-number'>24</span>  <span class='chapter-title'>patchwork</span>"
    ]
  },
  {
    "objectID": "03-programming-dplyr-superceded.html",
    "href": "03-programming-dplyr-superceded.html",
    "title": "25  Programming with dplyr (pre 1.0.0)",
    "section": "",
    "text": "25.1 Introduction\ndplyr uses non-standard evaluation (NSE)\ndf &lt;- tibble(\n  g1 = c(1, 1, 2, 2, 2),\n  g2 = c(1, 2, 1, 2, 1),\n  a = sample(5), \n  b = sample(5)\n)",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Programming with dplyr (pre 1.0.0)</span>"
    ]
  },
  {
    "objectID": "03-programming-dplyr-superceded.html#introduction",
    "href": "03-programming-dplyr-superceded.html#introduction",
    "title": "25  Programming with dplyr (pre 1.0.0)",
    "section": "",
    "text": "Positives\n\nEnables ability to only state name of data frame once and perform multiple operations.\nBetter able to integrate with SQL\n\n\nNegatives\n\nArguments are not referentially transparent, meaning that you cannot replace a value with a seemingly equivalent object that has been defined elsewhere. This makes it hard to create functions with arguments that change how dplyr verbs are computed.\nBecause of its terseness, dplyr code can be ambiguous, making functions more unpredictable.\n\n\nTools to help solve this problem in working with functions.\n\nPronouns\nQuasiquotation\n\n\nGoals of tutorial\n\nTeach quosures: the data structure that stores both an expression and an environment\nTeach tidyeval, which is the underlying toolkit through which this is implemented.\n\n\nProgramming recipes\n\ndplyr verbs in functions can fail silently if one of the variables is not present in the data frame, but is present in the global environment.\nWriting a function is hard if you want one of the arguments to be a variable name (like x) or an expression (like x + y). That is because dplyr automatically “quotes” those inputs, so they are not referentially transparent.",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Programming with dplyr (pre 1.0.0)</span>"
    ]
  },
  {
    "objectID": "03-programming-dplyr-superceded.html#summarise-example",
    "href": "03-programming-dplyr-superceded.html#summarise-example",
    "title": "25  Programming with dplyr (pre 1.0.0)",
    "section": "\n25.2 Summarise example",
    "text": "25.2 Summarise example\nStart with a function that does not work.\n\nmy_summarise &lt;- function(df, group_var) {\n  df %&gt;%\n  group_by(group_var) %&gt;%\n  summarise(a = mean(a))\n}\n\nmy_summarise(df, g1)\n#&gt; Error in `group_by()`:\n#&gt; ! Must group by variables found in `.data`.\n#&gt; ✖ Column `group_var` is not found.\n\nThe problem is that group_by() works by quoting the input rather than evaluating it.\nTo fix this we can manually quote the input so that the function can take a take a bare variable name like group_by(). We then need to use !! to unquote an input so that it’s evaluated, not quoted within group_by().\n\nmy_summarise &lt;- function(df, group_var) {\n  df %&gt;%\n    group_by(!!group_var) %&gt;%\n    summarise(a = mean(a))\n}\n\nmy_summarise(df, quo(g1))\n#&gt; # A tibble: 2 × 2\n#&gt;      g1     a\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1  2.5 \n#&gt; 2     2  3.33\n\nTo be able to call function without using quo() in function call you need a function that turns an argument into a string. This is done by enquo(): this looks at the argument, sees what the user typed, and returns that value as a quosure.\n\nmy_summarise &lt;- function(df, group_var) {\n  group_var &lt;- enquo(group_var)\n  print(group_var)\n\n  df %&gt;%\n    group_by(!!group_var) %&gt;%\n    summarise(a = mean(a))\n}\n\nmy_summarise(df, g1)\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^g1\n#&gt; env:  global\n#&gt; # A tibble: 2 × 2\n#&gt;      g1     a\n#&gt;   &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1  2.5 \n#&gt; 2     2  3.33",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Programming with dplyr (pre 1.0.0)</span>"
    ]
  },
  {
    "objectID": "03-programming-dplyr-superceded.html#different-input-variable",
    "href": "03-programming-dplyr-superceded.html#different-input-variable",
    "title": "25  Programming with dplyr (pre 1.0.0)",
    "section": "\n25.3 Different input variable",
    "text": "25.3 Different input variable\nSolution for the same problem as above but with multiple arguments within a dplyr function\n\nsummarise(df, mean = mean(a), sum = sum(a), n = n())\n#&gt; # A tibble: 1 × 3\n#&gt;    mean   sum     n\n#&gt;   &lt;dbl&gt; &lt;int&gt; &lt;int&gt;\n#&gt; 1     3    15     5\nsummarise(df, mean = mean(a * b), sum = sum(a * b), n = n())\n#&gt; # A tibble: 1 × 3\n#&gt;    mean   sum     n\n#&gt;   &lt;dbl&gt; &lt;int&gt; &lt;int&gt;\n#&gt; 1   7.4    37     5\n\nTest the approach above using quo() and !!\n\nmy_var &lt;- quo(a)\nsummarise(df, mean = mean(!!my_var), sum = sum(!!my_var), n = n())\n#&gt; # A tibble: 1 × 3\n#&gt;    mean   sum     n\n#&gt;   &lt;dbl&gt; &lt;int&gt; &lt;int&gt;\n#&gt; 1     3    15     5\n\nCan also wrap quo() around the dplyr call to see what will happen from dplyr’s perspective. This is useful for debugging.\n\nquo(summarise(df, mean = mean(!!my_var), sum = sum(!!my_var), n = n()))\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^summarise(df, mean = mean(^a), sum = sum(^a), n = n())\n#&gt; env:  global\n\nFully fixed function\n\nmy_summarise2 &lt;- function(df, expr) {\n  expr &lt;- enquo(expr)\n  \n  summarise(df, \n    mean = mean(!!expr),\n    sum = sum(!!expr),\n    n = n()\n  )\n}\nmy_summarise2(df, a)\n#&gt; # A tibble: 1 × 3\n#&gt;    mean   sum     n\n#&gt;   &lt;dbl&gt; &lt;int&gt; &lt;int&gt;\n#&gt; 1     3    15     5\nmy_summarise2(df, a * b)\n#&gt; # A tibble: 1 × 3\n#&gt;    mean   sum     n\n#&gt;   &lt;dbl&gt; &lt;int&gt; &lt;int&gt;\n#&gt; 1   7.4    37     5",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Programming with dplyr (pre 1.0.0)</span>"
    ]
  },
  {
    "objectID": "03-programming-dplyr-superceded.html#different-input-and-output-variable",
    "href": "03-programming-dplyr-superceded.html#different-input-and-output-variable",
    "title": "25  Programming with dplyr (pre 1.0.0)",
    "section": "\n25.4 Different input and output variable",
    "text": "25.4 Different input and output variable\n\nmutate(df, mean_a = mean(a), sum_a = sum(a))\n#&gt; # A tibble: 5 × 6\n#&gt;      g1    g2     a     b mean_a sum_a\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt;  &lt;dbl&gt; &lt;int&gt;\n#&gt; 1     1     1     4     1      3    15\n#&gt; 2     1     2     1     4      3    15\n#&gt; 3     2     1     2     5      3    15\n#&gt; 4     2     2     5     2      3    15\n#&gt; 5     2     1     3     3      3    15\nmutate(df, mean_b = mean(b), sum_b = sum(b))\n#&gt; # A tibble: 5 × 6\n#&gt;      g1    g2     a     b mean_b sum_b\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt;  &lt;dbl&gt; &lt;int&gt;\n#&gt; 1     1     1     4     1      3    15\n#&gt; 2     1     2     1     4      3    15\n#&gt; 3     2     1     2     5      3    15\n#&gt; 4     2     2     5     2      3    15\n#&gt; 5     2     1     3     3      3    15\n\nThis is different in that we want a function that will not only do the mean and sum calculation, but will also name the column correctly. Need to create new names by pasting strings. Use quo_name() for this. !!mean_name = mean(!!expr) is not valid R code, so need helper of :=, thus !!mean_name := mean(!!expr).\n\nmy_mutate &lt;- function(df, expr) {\n  expr &lt;- enquo(expr)\n  mean_name &lt;- paste0(\"mean_\", quo_name(expr))\n  sum_name &lt;- paste0(\"sum_\", quo_name(expr))\n  \n  mutate(df, \n    !!mean_name := mean(!!expr), \n    !!sum_name := sum(!!expr)\n  )\n}\n\nmy_mutate(df, a)\n#&gt; # A tibble: 5 × 6\n#&gt;      g1    g2     a     b mean_a sum_a\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt;  &lt;dbl&gt; &lt;int&gt;\n#&gt; 1     1     1     4     1      3    15\n#&gt; 2     1     2     1     4      3    15\n#&gt; 3     2     1     2     5      3    15\n#&gt; 4     2     2     5     2      3    15\n#&gt; 5     2     1     3     3      3    15",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Programming with dplyr (pre 1.0.0)</span>"
    ]
  },
  {
    "objectID": "03-programming-dplyr-superceded.html#capturing-multiple-variables",
    "href": "03-programming-dplyr-superceded.html#capturing-multiple-variables",
    "title": "25  Programming with dplyr (pre 1.0.0)",
    "section": "\n25.5 Capturing multiple variables",
    "text": "25.5 Capturing multiple variables\nIn order to make the my_summarise() function accept any number of grouping variables need to make three changes:\n\nUse ... in the function definition so our function can accept any number of arguments.\nUse quos() to capture all the ... as a list of formulas.\nUse !!! instead of !! to splice the arguments into group_by().\n\n\nmy_summarise &lt;- function(df, ...) {\n  group_var &lt;- quos(...)\n\n  df %&gt;%\n    group_by(!!!group_var) %&gt;%\n    summarise(a = mean(a))\n}\n\nmy_summarise(df, g1, g2)\n#&gt; `summarise()` has grouped output by 'g1'. You can override using the `.groups`\n#&gt; argument.\n#&gt; # A tibble: 4 × 3\n#&gt; # Groups:   g1 [2]\n#&gt;      g1    g2     a\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     1     1   4  \n#&gt; 2     1     2   1  \n#&gt; 3     2     1   2.5\n#&gt; 4     2     2   5",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Programming with dplyr (pre 1.0.0)</span>"
    ]
  },
  {
    "objectID": "03-programming-dplyr-superceded.html#theory",
    "href": "03-programming-dplyr-superceded.html#theory",
    "title": "25  Programming with dplyr (pre 1.0.0)",
    "section": "\n25.6 Theory",
    "text": "25.6 Theory\n\n25.6.1 Quoting\nSee also: http://rlang.tidyverse.org/reference/quosure.html\n\nDefining quotation in R: “Quoting is the action of capturing an expression instead of evaluating it. All expression-based functions quote their arguments and get the R code as an expression rather than the result of evaluating that code.”\n\nNote that \"\" is not a quoting operation, because it returns a string rather than an expression\n\n\nCommon quote expression is use of formula in statistical evaluations such as disp ~ cyl + drat\n\nHave to be careful in creating formulas, because expressions could be different based on their environment.\n\nAbility for one name to refer to different values in different environments is an important part of R and dplyr.\n\n\nWhen an object keeps track of an environment, it is said to have an enclosure.\n\nquosures: one-sided formulas; one-sided formulas are quotes (they carry an expression) with an environment.\n\nExample: var &lt;- ~toupper(letters[1:5])\n\n\n\n\n25.6.2 Quasiquotation\nAutomatic quoting makes dplyr very convenient for interactive use. But if you want to program with dplyr, you need some way to refer to variables indirectly. The solution to this problem is quasiquotation, which allows you to evaluate directly inside an expression that is otherwise quoted.\nAutomatic quoting makes dplyr very convenient for interactive use. But if you want to program with dplyr, you need some way to refer to variables indirectly. The solution to this problem is quasiquotation, which allows you to evaluate directly inside an expression that is otherwise quoted.\nThree types of unquoting in the tidyeval framework\n\nBasic with either UQ() or !!\n\n\n\n# Here we capture `letters[1:5]` as an expression:\nquo(toupper(letters[1:5]))\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^toupper(letters[1:5])\n#&gt; env:  global\n\n# Here we capture the value of `letters[1:5]`\nquo(toupper(!!letters[1:5]))\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^toupper(&lt;chr: \"a\", \"b\", \"c\", \"d\", \"e\"&gt;)\n#&gt; env:  global\nquo(toupper(UQ(letters[1:5])))\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^toupper(&lt;chr: \"a\", \"b\", \"c\", \"d\", \"e\"&gt;)\n#&gt; env:  global\n\n\nUnquote-splicing\n\nUnquote-splicing’s functional form is UQS() and the syntactic shortcut is !!!. It takes a vector and inserts each element of the vector in the surrounding function call.\n\nquo(list(!!! letters[1:5]))\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^list(\"a\", \"b\", \"c\", \"d\", \"e\")\n#&gt; env:  global\n\n\nUnquoting names\n\nSetting argument names with :=",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>25</span>  <span class='chapter-title'>Programming with dplyr (pre 1.0.0)</span>"
    ]
  },
  {
    "objectID": "03-programming-dplyr.html",
    "href": "03-programming-dplyr.html",
    "title": "26  Programming with dplyr",
    "section": "",
    "text": "26.1 Data masking\nData masking allows you to refer to variables in data frames (data-variables) as if they were objects in your R environment (env-variables). This blurring of the meaning of “variable” is useful within interactive data analysis, but it introduces problems when programming with these tools.",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Programming with dplyr</span>"
    ]
  },
  {
    "objectID": "03-programming-dplyr.html#data-masking",
    "href": "03-programming-dplyr.html#data-masking",
    "title": "26  Programming with dplyr",
    "section": "",
    "text": "26.1.1 Indirection\nThe concept of indirection is a replacement for the language of quasiquotation. Indirection occurs “when you want to get the data-variable from an env-variable instead of directly typing the data-variable’s name.” There are two main cases:\n\nData-variable in a function argument: Need to embrace the argument with curly-curly ({{).\n\n\nvar_summary &lt;- function(data, var) {\n  data %&gt;%\n    summarise(n = n(), min = min({{ var }}), max = max({{ var }}))\n}\n\n\nEnvironment-variable that is a character vector: Need to index into the .data pronoun.\n\n.data is not a data frame but a pronoun that provides access to current variables by either referring directly to the column with .data$x or indirectly through a character vector with .data[[var]].\n\nfor (var in names(mtcars)) {\n  mtcars %&gt;% count(.data[[var]]) %&gt;% print()\n}\n\n\n26.1.2 Name injection\nName injection is related to dynamic dots, which makes it possible to generate names programmatically with :=. There are two forms of name injection:\n\nIf the name is an env-variable, use glue syntax.\n\n\nname &lt;- \"susan\"\ntibble(\"{name}\" := 2)\n#&gt; # A tibble: 1 × 1\n#&gt;   susan\n#&gt;   &lt;dbl&gt;\n#&gt; 1     2\n\n\nIf the name is derived from a data-variable in an argument, use embracing syntax.\n\n\nmy_df &lt;- function(x) {\n  tibble(\"{{x}}_2\" := x * 2)\n}\ny &lt;- 10\nmy_df(y)\n#&gt; # A tibble: 1 × 1\n#&gt;     y_2\n#&gt;   &lt;dbl&gt;\n#&gt; 1    20",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Programming with dplyr</span>"
    ]
  },
  {
    "objectID": "03-programming-dplyr.html#tidy-selection",
    "href": "03-programming-dplyr.html#tidy-selection",
    "title": "26  Programming with dplyr",
    "section": "\n26.2 Tidy selection",
    "text": "26.2 Tidy selection\nThe capabilities of tidy selection are based on the tidyselect package. Tidy select provides a domain specific language to select columns by name, position, or type.\n\n26.2.1 Indirection\nIndirection with tidy select occurs when column selection is stored in an intermediate variable. There are two main cases:\n\nData-variable in a function argument: Need to embrace the argument with curly-curly ({{).\n\n\nsummarise_mean &lt;- function(data, vars) {\n  data %&gt;% summarise(n = n(), across({{ vars }}, mean))\n}\nmtcars %&gt;% \n  group_by(cyl) %&gt;% \n  summarise_mean(where(is.numeric))\n#&gt; # A tibble: 3 × 12\n#&gt;     cyl     n   mpg  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt; 1     4    11  26.7  105.  82.6  4.07  2.29  19.1 0.909 0.727  4.09  1.55\n#&gt; 2     6     7  19.7  183. 122.   3.59  3.12  18.0 0.571 0.429  3.86  3.43\n#&gt; 3     8    14  15.1  353. 209.   3.23  4.00  16.8 0     0.143  3.29  3.5\n\n\nEnvironment-variable that is a character vector: Need to use all_of() or any_of() depending on whether you want the function to error if a variable is not found.\n\n\nvars &lt;- c(\"mpg\", \"vs\")\nmtcars %&gt;% select(all_of(vars)) %&gt;% head()\n#&gt;                    mpg vs\n#&gt; Mazda RX4         21.0  0\n#&gt; Mazda RX4 Wag     21.0  0\n#&gt; Datsun 710        22.8  1\n#&gt; Hornet 4 Drive    21.4  1\n#&gt; Hornet Sportabout 18.7  0\n#&gt; Valiant           18.1  1",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Programming with dplyr</span>"
    ]
  },
  {
    "objectID": "03-programming-dplyr.html#how-tos",
    "href": "03-programming-dplyr.html#how-tos",
    "title": "26  Programming with dplyr",
    "section": "\n26.3 How-tos",
    "text": "26.3 How-tos\n\n26.3.1 Eliminating R CMD check NOTEs\nIf you have a function that uses data masking or tidy selection the variables used within the function will lead to a note about undefined global variables. There are two ways to eliminate this note depending on whether it derives from data masking or tidy selection.\n\nData masking: use .data$var and import .data from its source in the rlang package.\nTidy selection: use \"var\" instead of var.\n\n\n#' @importFrom rlang .data\nmy_summary_function &lt;- function(data) {\n  data %&gt;% \n    select(\"grp\", \"x\", \"y\") %&gt;% \n    filter(.data$x &gt; 0) %&gt;% \n    group_by(.data$grp) %&gt;% \n    summarise(y = mean(.data$y), n = n())\n}\n\n\n26.3.2 User-suplied expressions in function arguments\nUse embracing to capture and inject the expression into the function.\n\nmy_summarise &lt;- function(data, expr) {\n  data %&gt;% summarise(\n    mean = mean({{ expr }}),\n    sum = sum({{ expr }}),\n    n = n()\n  )\n}\n\nTo use the name of the variable in the output embrace the variable on the left side and use {{ to embrace.\n\nmy_summarise2 &lt;- function(data, mean_var, sd_var) {\n  data %&gt;% \n    summarise(\n      \"mean_{{mean_var}}\" := mean({{ mean_var }}), \n      \"sd_{{sd_var}}\" := sd({{ sd_var }})\n    )\n}\n\n\n26.3.3 Any number of user-supplied expressions\nUse ... to take any number of user-specified expressions. When using ... all named arguments should begin with . to minimize chances for argument clashes. See the tidyverse design guide for details.\n\nmy_summarise &lt;- function(.data, ...) {\n  .data %&gt;%\n    group_by(...) %&gt;%\n    summarise(mass = mean(mass, na.rm = TRUE),\n              height = mean(height, na.rm = TRUE))\n}\nstarwars %&gt;% my_summarise(homeworld, gender)\n#&gt; `summarise()` has grouped output by 'homeworld'. You can override using the\n#&gt; `.groups` argument.\n#&gt; # A tibble: 57 × 4\n#&gt; # Groups:   homeworld [49]\n#&gt;    homeworld      gender     mass height\n#&gt;    &lt;chr&gt;          &lt;chr&gt;     &lt;dbl&gt;  &lt;dbl&gt;\n#&gt;  1 Alderaan       feminine     49   150 \n#&gt;  2 Alderaan       masculine    79   190.\n#&gt;  3 Aleen Minor    masculine    15    79 \n#&gt;  4 Bespin         masculine    79   175 \n#&gt;  5 Bestine IV     &lt;NA&gt;        110   180 \n#&gt;  6 Cato Neimoidia masculine    90   191 \n#&gt;  7 Cerea          masculine    82   198 \n#&gt;  8 Champala       masculine   NaN   196 \n#&gt;  9 Chandrila      feminine    NaN   150 \n#&gt; 10 Concord Dawn   masculine    79   183 \n#&gt; # ℹ 47 more rows\n\n\n26.3.4 Transforming user-supplied variables\nUse across() and pick() (new with dplyr 1.1.0) to transform sets of data variables. You can also use the .names argument to across() to control the names of the output columns.\n\nmy_summarise &lt;- function(data, group_var, summarise_var) {\n  data %&gt;%\n    group_by(pick({{ group_var }})) %&gt;% \n    summarise(across({{ summarise_var }},\n                     ~ mean(., na.rm = TRUE),\n                     .names = \"mean_{.col}\"))\n}\nmy_summarise(starwars, \n             group_var = c(species, gender),\n             summarise_var = c(mass, height))\n#&gt; `summarise()` has grouped output by 'species'. You can override using the\n#&gt; `.groups` argument.\n#&gt; # A tibble: 42 × 4\n#&gt; # Groups:   species [38]\n#&gt;    species   gender    mean_mass mean_height\n#&gt;    &lt;chr&gt;     &lt;chr&gt;         &lt;dbl&gt;       &lt;dbl&gt;\n#&gt;  1 Aleena    masculine      15            79\n#&gt;  2 Besalisk  masculine     102           198\n#&gt;  3 Cerean    masculine      82           198\n#&gt;  4 Chagrian  masculine     NaN           196\n#&gt;  5 Clawdite  feminine       55           168\n#&gt;  6 Droid     feminine      NaN            96\n#&gt;  7 Droid     masculine      69.8         140\n#&gt;  8 Dug       masculine      40           112\n#&gt;  9 Ewok      masculine      20            88\n#&gt; 10 Geonosian masculine      80           183\n#&gt; # ℹ 32 more rows",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>26</span>  <span class='chapter-title'>Programming with dplyr</span>"
    ]
  },
  {
    "objectID": "03-metaprogramming.html",
    "href": "03-metaprogramming.html",
    "title": "27  Advanced R: Metaprogramming",
    "section": "",
    "text": "27.1 Quasiquotation\nQuasiquotation is the ability to both quote—by capturing an unevaluated expression—and unquote—by selectively evaluating parts of an otherwise quoted expression. You can distinguish between evaluated arguments and quoted arguments by whether they obey R’s usual evaluation rules or not. If you cannot evaluate a piece of code outside a function, it is quoted. Thus, the first argument of library() is a quoted argument, allowing you to write library(rlang) instead of library(\"rlang\"). If you just write rlang, you will get an error.\nrlang\n#&gt; Error in eval(expr, envir, enclos): object 'rlang' not found\nAn expression is captured code that you can compute on and treat as a list. Can use expr() to capture code and make it into an expression. expr() captures code and returns exactly what you pass in. It quotes code.\nexpr(mean(x, na.rm = TRUE))\n#&gt; mean(x, na.rm = TRUE)\nexpr(10 + 100 + 1000)\n#&gt; 10 + 100 + 1000\nYou can capture user-specified code in function arguments with enexpr().\ncapture_it &lt;- function(x) {\n  enexpr(x)\n}\n\ncapture_it(x + y)\n#&gt; x + y\nUse base eval() to evaluate an expression in a given environment.\nx &lt;- 10\ny &lt;- 2\neval(expr(x + y))\n#&gt; [1] 12\n\n# eval with a specified environment\neval(expr(x + y), env(x = 1000))\n#&gt; [1] 1002\nUse !! (bang-bang) to unquote a single argument at a time. !! takes a single expression, evaluates it, and inlines the result in the abstract syntax tree. Compare the quoted expression with the unquoted expression.\na &lt;- sym(\"y\")\nb &lt;- 1\n# Quoted\nexpr(f(a, b))\n#&gt; f(a, b)\n# Quoted and unquoted\nexpr(f(!!a, !!b))\n#&gt; f(y, 1)\nYou can unquote a list of expressions that have been captured by ... with !!!. You can capture the dots with list2(). To unquote the left-hand side of an expression you need to use := because R does not allow expressions as argument names. These steps are shown in the below example of a function that allows you to set attributes for an object. Note the difference between unquoting a list of quoted expressions (attrs) and unquoting an argument name (attr_name).\nset_attr &lt;- function(.x, ...) {\n  attr &lt;- rlang::list2(...) # Collect and quote the dots\n  attributes(.x) &lt;- attr\n  .x\n}\n\nattrs &lt;- list(x = 1, y = 2)\nattr_name &lt;- \"z\"\n\n1:10 |&gt; \n  set_attr(w = 0, !!!attrs, !!attr_name := 3) |&gt;  \n  str()\n#&gt;  int [1:10] 1 2 3 4 5 6 7 8 9 10\n#&gt;  - attr(*, \"w\")= num 0\n#&gt;  - attr(*, \"x\")= num 1\n#&gt;  - attr(*, \"y\")= num 2\n#&gt;  - attr(*, \"z\")= num 3",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Advanced R: Metaprogramming</span>"
    ]
  },
  {
    "objectID": "03-metaprogramming.html#sec-quosures",
    "href": "03-metaprogramming.html#sec-quosures",
    "title": "27  Advanced R: Metaprogramming",
    "section": "\n27.2 Quosures",
    "text": "27.2 Quosures\nHowever, what you usually want to do is to use enquo() to create a quosure in which the expression is bundled with the environment. This ensures that the data environment is used when evaluating the code and not affected by variables from the user environment.\n\ncapture_it &lt;- function(x) {\n  enquo(x)\n}\n\ncapture_it(x + y)\n#&gt; &lt;quosure&gt;\n#&gt; expr: ^x + y\n#&gt; env:  global\n\neval_tidy() can take a single quosure to evaluate instead of an expression-environment pair. This can be seen by creating a quosure from scratch with new_quosure() and then evaluating it.\n\nx &lt;- 100\ny &lt;- 20\nq1 &lt;- new_quosure(expr(x + y), env(x = 1, y = 10))\neval_tidy(q1)\n#&gt; [1] 11",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Advanced R: Metaprogramming</span>"
    ]
  },
  {
    "objectID": "03-metaprogramming.html#sec-data-mask",
    "href": "03-metaprogramming.html#sec-data-mask",
    "title": "27  Advanced R: Metaprogramming",
    "section": "\n27.3 Data mask",
    "text": "27.3 Data mask\nQuasiquotation and quosures come together in creating a data mask in which the evaluation process is modified to be able to treat variables in data frames as if they are variables in the user environment. You can see this with a simplified replacement for the with() function that uses a data mask.\nIn with2() the user-specified input is captured as an expression by enquo(), creating a quosure that associates it with the data frame df, and then uses eval_tidy() to evaluate the quosure.\n\nwith2 &lt;- function(df, expr) {\n  eval_tidy(enquo(expr), df)\n}\n\ndf &lt;- data.frame(x = 1:5, y = 100)\nwith2(df, x * y)\n#&gt; [1] 100 200 300 400 500\n\nData masks introduce ambiguity because you cannot be sure if a variable comes from the data or user environment. Data masks provide two pronouns to deal with this ambiguity: .data$x always refers to x in the data mask and .env$x always refers to x in the environment.\n\nx &lt;- 1\nwith2(df, .data$x)\n#&gt; [1] 1 2 3 4 5\nwith2(df, .env$x)\n#&gt; [1] 1\n\nYou can also subset data mask pronouns with [[.\n\nwith2(df, .data[[\"x\"]])\n#&gt; [1] 1 2 3 4 5\n\nAnother example is provided by creating a simple function for subset() that is similar to dplyr::filter(). This uses enquo() to create the quosure and evaluate with tidy_eval() since a data masking function is being created from scratch instead of being passed on to another function.\n\nsubset2 &lt;- function(data, rows) {\n  rows &lt;- enquo(rows)\n  rows_val &lt;- eval_tidy(rows, data)\n  stopifnot(is.logical(rows_val))\n\n  data[rows_val, , drop = FALSE]\n}\ndf &lt;- data.frame(a = 1:5, b = 5:1, c = c(5, 3, 1, 4, 1))\n\nsubset2(df, b == c)\n#&gt;   a b c\n#&gt; 1 1 5 5\n#&gt; 5 5 1 1\n\nIf you want to use subset2() within another function, you need to use the quoting and unquoting pattern because cond is now a quoted argument.\n\nsubsample &lt;- function(df, cond, n = nrow(df)) {\n  cond &lt;- enquo(cond)\n  # subset\n  df &lt;- subset2(df, !!cond)\n  # resample\n  idx &lt;- sample(nrow(df), n, replace = TRUE)\n  df[idx, , drop = FALSE]\n}\n\ndf &lt;- data.frame(x = c(1, 1, 1, 2, 2), y = 1:5)\nsubsample(df, x == 1)\n#&gt;     x y\n#&gt; 1   1 1\n#&gt; 1.1 1 1\n#&gt; 3   1 3\n\n\n\n\n\nWickham, Hadley. 2019. Advanced R. Second Edition. Boca Raton: CRC Press.",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>27</span>  <span class='chapter-title'>Advanced R: Metaprogramming</span>"
    ]
  },
  {
    "objectID": "03-rlang-tidyeval.html",
    "href": "03-rlang-tidyeval.html",
    "title": "28  rlang: Tidy evaluation",
    "section": "",
    "text": "28.1 rlang Tidy evaluation vignettes\nlibrary(rlang)\nlibrary(dplyr)",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>rlang: Tidy evaluation</span>"
    ]
  },
  {
    "objectID": "03-rlang-tidyeval.html#rlang-tidy-evaluation-vignettes",
    "href": "03-rlang-tidyeval.html#rlang-tidy-evaluation-vignettes",
    "title": "28  rlang: Tidy evaluation",
    "section": "",
    "text": "What is data-masking and why do I need {{?\nData mask programming patterns\nThe data mask ambiguity\nThe double evaluation problem\nWhat happens if I use injection operators out of context?\nDoes {{ work on regular objects?",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>rlang: Tidy evaluation</span>"
    ]
  },
  {
    "objectID": "03-rlang-tidyeval.html#sec-data-mask",
    "href": "03-rlang-tidyeval.html#sec-data-mask",
    "title": "28  rlang: Tidy evaluation",
    "section": "\n28.2 What is data-masking and why do I need {{?",
    "text": "28.2 What is data-masking and why do I need {{?\n“Data-masking is a distinctive feature of R whereby programming is performed directly on a data set, with columns defined as normal objects.” This is achieved by defusing R code (quoting it) and then injecting (unquoting) the defused expression in the correct context of the data frame instead of the user environment.\nIf you pass arguments to a data-masking function in a normal way such as dplyr::summarise() the arguments are defused, but the user-defined arguments are not injected. For instance, below my_mean() does not know to look for cyl and am in the mtcars data frame and instead looks for them in the user environment.\n\nmy_mean &lt;- function(data, var1, var2) {\n  summarise(data, mean(var1 + var2))\n}\n\nmy_mean(mtcars, cyl, am)\n#&gt; Error in `summarise()`:\n#&gt; ℹ In argument: `mean(var1 + var2)`.\n#&gt; Caused by error:\n#&gt; ! object 'cyl' not found\n\nIf you introduce objects named cyl and am into the user environment, those will be used and the mtcars data frame will not be used at all. Notice that the column is named mean(var1 + var2), just like the error message above, indicating the actual code that is being run.\n\ncyl &lt;- 1\nam &lt;- 2\nmy_mean(mtcars, cyl, am)\n#&gt;   mean(var1 + var2)\n#&gt; 1                 3\n\nTo inject a function argument in a data masking context use the embracing syntax curly-curly ({{). Note that when this is done the column is correctly named mean(cyl + am) and the names properly refer to variables in the mtcars data frame and not the user environment.\n\nmy_mean &lt;- function(data, var1, var2) {\n  summarise(data, mean({{ var1 }} + {{ var2 }}))\n}\n\nmy_mean(mtcars, cyl, am)\n#&gt;   mean(cyl + am)\n#&gt; 1        6.59375\n\n\n28.2.1 What does “masking” mean?\nData masking occurs by placing the data frame at the bottom of the chain of environments so that it takes precedence over the user environment. It thus masks the user environment. This means that data masking functions will use a data frame variable instead of a variable in the user environment as in the above my_mean() function. Tidy eval provides .data and .env pronouns to help deal with this ambiguity.\n\nmtcars  |&gt; \n  summarise(\n    mean_data = mean(.data$cyl),\n    mean_env = mean(.env$cyl)\n  )\n#&gt;   mean_data mean_env\n#&gt; 1    6.1875        1\n\n\n28.2.2 How does data-masking work?\nData masking relies on three language features of R:\n\nArgument defusal\nFirst class environments: Environments are a special type of list-like object in which defused R code can be evaluated.\nExplicit evaluation with eval() (base) or eval_tidy() (rlang).\n\nThe below code brings these three features together: the code is defused (quoted) and then explicitly evaluated within the environment of the mtcars data frame instead of the default user environment.\n\ncode &lt;- expr(mean(cyl + am))\neval(code, mtcars)\n#&gt; [1] 6.59375",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>rlang: Tidy evaluation</span>"
    ]
  },
  {
    "objectID": "03-rlang-tidyeval.html#sec-data-mask-patters",
    "href": "03-rlang-tidyeval.html#sec-data-mask-patters",
    "title": "28  rlang: Tidy evaluation",
    "section": "\n28.3 Data mask programming patterns",
    "text": "28.3 Data mask programming patterns\nThere are two main considerations when determining which programming pattern should be used to wrap a data-masking function:\n\nWhat behavior does the wrapped function implement?\nWhat behavior should your function implement?\n\n\n28.3.1 Argument behaviors\nData masking arguments are not only defined by the type of objects they accept but also the special computational behaviors they exhibit. Options include:\n\nBase data-masked expressions (e.g. with()): Expressions may refer to the columns of the supplied data frame.\nTidy eval data-masked expressions: Same as base data-masked expressions but with addition features such as injection operators: {{ and !! and the .data and .env pronouns.\nData-masked symbols: Supplied expressions must be simple column names.\nTidy selections: Tidy selection is an alternative to data masking and does not involve masking. Expressions are either interpreted in the context of a data frame (c(cyl, am)) or evaluated in the user environment (starts_with()).\nDynamic dots: These may be data-masked arguments, tidy selections, or just regular arguments.\n\nYou can include documentation about the three main tidy eval options with the following tags:\n\n\n@param foo &lt;[`data-masked`][dplyr::dplyr_data_masking]&gt; What `foo` does.\n@param bar &lt;[`tidy-select`][dplyr::dplyr_tidy_select]&gt; What `bar` does.\n@param ... &lt;[`dynamic-dots`][rlang::dyn-dots]&gt; What these dots do.\n\n28.3.2 Forwarding patterns\nYour function inherits the behavior of the function it interfaces with. In both data masking and tidy selection contexts use the embrace operator ({{).\n\nmy_summarise &lt;- function(data, var) {\n  data %&gt;% dplyr::summarise({{ var }})\n}\nmtcars %&gt;% my_summarise(mean(cyl))\n#&gt;   mean(cyl)\n#&gt; 1    6.1875\n\nThe behavior of my_summarise() is the same as dplyr::summarise(). This includes the ability to use the .data pronoun to refer to columns. The below both work in the same way.\n\nx &lt;- \"cyl\"\nmtcars %&gt;% dplyr::summarise(mean(.data[[x]]))\n#&gt;   mean(.data[[\"cyl\"]])\n#&gt; 1               6.1875\nmtcars %&gt;% my_summarise(mean(.data[[x]]))\n#&gt;   mean(.data[[\"cyl\"]])\n#&gt; 1               6.1875\n\nDots can be forwarded by simply passing them on to another argument.\n\nmy_group_by &lt;- function(.data, ...) {\n  .data %&gt;% dplyr::group_by(...)\n}\n\nThere are some tidy selection functions that use a single named argument instead of ... such as pivot_longer(). In that case, pass the ... inside c(), which acts as a selection combinator in this context.\n\nmy_pivot_longer &lt;- function(.data, ...) {\n  .data %&gt;% tidyr::pivot_longer(c(...))\n}\n\n\n28.3.3 Names patterns\nYour function takes strings or character vectors to refer to column names.\nThe .data pronoun is a tidy eval feature enabled within data-masked arguments and represents the data mask. It can be subset with [[ and $. The three below statements are equivalent just as above with my_summarise().\n\nmtcars %&gt;% dplyr::summarise(mean = mean(cyl))\n#&gt;     mean\n#&gt; 1 6.1875\n\nmtcars %&gt;% dplyr::summarise(mean = mean(.data$cyl))\n#&gt;     mean\n#&gt; 1 6.1875\n\nvar &lt;- \"cyl\"\nmtcars %&gt;% dplyr::summarise(mean = mean(.data[[var]]))\n#&gt;     mean\n#&gt; 1 6.1875\n\nYou can also use the .data pronoun to connect function arguments to a data-variable. This insulates the function from data-masking behavior. Notice that my_mean() now needs a character vector and uses the environmental variable equivalent to \"cyl\" instead of the data variable of am.\n\nmy_mean &lt;- function(data, var) {\n  data %&gt;% dplyr::summarise(mean = mean(.data[[var]]))\n}\n\nmy_mean(mtcars, \"cyl\")\n#&gt;     mean\n#&gt; 1 6.1875\n\nam &lt;- \"cyl\"\nmy_mean(mtcars, am)\n#&gt;     mean\n#&gt; 1 6.1875\n\n.data does not support character vectors of length greater than one. For character vectors of names greater than one use all_of() or any_of().\n\nvars &lt;- c(\"cyl\", \"am\")\nmtcars %&gt;% tidyr::pivot_longer(all_of(vars))\n#&gt; # A tibble: 64 × 11\n#&gt;      mpg  disp    hp  drat    wt  qsec    vs  gear  carb name  value\n#&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt;  1  21     160   110  3.9   2.62  16.5     0     4     4 cyl       6\n#&gt;  2  21     160   110  3.9   2.62  16.5     0     4     4 am        1\n#&gt;  3  21     160   110  3.9   2.88  17.0     0     4     4 cyl       6\n#&gt;  4  21     160   110  3.9   2.88  17.0     0     4     4 am        1\n#&gt;  5  22.8   108    93  3.85  2.32  18.6     1     4     1 cyl       4\n#&gt;  6  22.8   108    93  3.85  2.32  18.6     1     4     1 am        1\n#&gt;  7  21.4   258   110  3.08  3.22  19.4     1     3     1 cyl       6\n#&gt;  8  21.4   258   110  3.08  3.22  19.4     1     3     1 am        0\n#&gt;  9  18.7   360   175  3.15  3.44  17.0     0     3     2 cyl       8\n#&gt; 10  18.7   360   175  3.15  3.44  17.0     0     3     2 am        0\n#&gt; # ℹ 54 more rows\n\n\n28.3.4 Bridge patterns\nYou change the behavior of an argument instead of inheriting it.\nYou can use across() or pick() as a bridge between selection and data masking.\n\nmy_group_by &lt;- function(data, cols) {\n  group_by(data, pick({{ cols }}))\n}\n\nmtcars %&gt;% my_group_by(starts_with(\"c\"))\n#&gt; # A tibble: 32 × 11\n#&gt; # Groups:   cyl, carb [9]\n#&gt;      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n#&gt;  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n#&gt;  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n#&gt;  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n#&gt;  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n#&gt;  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n#&gt;  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n#&gt;  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n#&gt;  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n#&gt; 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n#&gt; # ℹ 22 more rows\n\npick(), unlike across() takes dynamic dots, so you can also just pass on the dots. With across() you need to collect the dots with c(...).\n\nmy_group_by &lt;- function(.data, ...) {\n  group_by(.data, pick(...))\n}\n\nmtcars %&gt;% my_group_by(starts_with(\"c\"), vs:gear)\n#&gt; # A tibble: 32 × 11\n#&gt; # Groups:   cyl, carb, vs, am, gear [15]\n#&gt;      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n#&gt;  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n#&gt;  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n#&gt;  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n#&gt;  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n#&gt;  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n#&gt;  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n#&gt;  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n#&gt;  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n#&gt; 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n#&gt; # ℹ 22 more rows\n\nUse all_of() or any_of() to bridge names, or character vectors, to a data mask.\n\nmy_group_by &lt;- function(data, vars) {\n  data %&gt;% dplyr::group_by(pick(all_of(vars)))\n}\n\nmtcars %&gt;% my_group_by(c(\"cyl\", \"am\"))\n#&gt; # A tibble: 32 × 11\n#&gt; # Groups:   cyl, am [6]\n#&gt;      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n#&gt;  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n#&gt;  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n#&gt;  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n#&gt;  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n#&gt;  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n#&gt;  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n#&gt;  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n#&gt;  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n#&gt; 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n#&gt; # ℹ 22 more rows\n\nUse mutate(.keep = \"none\") to bridge data-mask to selection. This pattern is a little trickier and uses mutate() as a way to inspect the names passed to ... and make sure that they are included in the data frame. The column names and any transformation are done with the splice operator (!!!) and then the selection can be passed to pivot_longer() through all_of(). For the output, look to the columns on the right that show name and value. For another way to do this using a symbolize and inject pattern, see Metaprogramming patterns - Bridge patterns.\n\nmy_pivot_longer &lt;- function(data, ...) {\n  # Forward `...` in data-mask context with `mutate(.keep = \"none\")`\n  # to create a new data frame and save the inputs names\n  inputs &lt;- dplyr::mutate(data, ..., .keep = \"none\")\n  names &lt;- names(inputs)\n  \n  # Update the data with the inputs\n  data &lt;- dplyr::mutate(data, !!!inputs)\n\n  # Select the inputs by name with `all_of()`\n  tidyr::pivot_longer(data, cols = all_of(names))\n}\n\nmtcars %&gt;% my_pivot_longer(cyl, am = am * 100)\n#&gt; # A tibble: 64 × 11\n#&gt;      mpg  disp    hp  drat    wt  qsec    vs  gear  carb name  value\n#&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt;  1  21     160   110  3.9   2.62  16.5     0     4     4 cyl       6\n#&gt;  2  21     160   110  3.9   2.62  16.5     0     4     4 am      100\n#&gt;  3  21     160   110  3.9   2.88  17.0     0     4     4 cyl       6\n#&gt;  4  21     160   110  3.9   2.88  17.0     0     4     4 am      100\n#&gt;  5  22.8   108    93  3.85  2.32  18.6     1     4     1 cyl       4\n#&gt;  6  22.8   108    93  3.85  2.32  18.6     1     4     1 am      100\n#&gt;  7  21.4   258   110  3.08  3.22  19.4     1     3     1 cyl       6\n#&gt;  8  21.4   258   110  3.08  3.22  19.4     1     3     1 am        0\n#&gt;  9  18.7   360   175  3.15  3.44  17.0     0     3     2 cyl       8\n#&gt; 10  18.7   360   175  3.15  3.44  17.0     0     3     2 am        0\n#&gt; # ℹ 54 more rows\n\n\n28.3.5 Transformation patterns\nYou can transform inputs with across() by forwarding ... to across() and performing an action on it. This uses ... to inherit tidy selection behavior. For another way to do this using a symbolize and inject pattern, see Metaprogramming patterns - Transformation patterns.\n\nmy_mean &lt;- function(data, ...) {\n  data %&gt;%  dplyr::summarise(\n    across(c(...), ~ mean(.x, na.rm = TRUE))\n    )\n}\n\nmtcars %&gt;% my_mean(cyl, carb)\n#&gt;      cyl   carb\n#&gt; 1 6.1875 2.8125\n\nmtcars %&gt;% my_mean(foo = cyl, bar = carb)\n#&gt;      foo    bar\n#&gt; 1 6.1875 2.8125\n\nmtcars %&gt;% my_mean(starts_with(\"c\"), mpg:disp)\n#&gt;      cyl   carb      mpg     disp\n#&gt; 1 6.1875 2.8125 20.09062 230.7219\n\nfilter() necessitates a different pattern because it is built on logical expressions. if_all() and if_any() provide variants of across() suitable to use in filter. For instance, creating a function to filter all rows for which a set of variables are not equal to their minimum value.\n\nfilter_non_baseline &lt;- function(.data, ...) {\n  .data %&gt;% dplyr::filter(if_all(c(...), ~ .x != min(.x, na.rm = TRUE)))\n}\n\nmtcars %&gt;% filter_non_baseline(vs, am, gear)\n#&gt;                 mpg cyl  disp  hp drat    wt  qsec vs am gear carb\n#&gt; Datsun 710     22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\n#&gt; Fiat 128       32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\n#&gt; Honda Civic    30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\n#&gt; Toyota Corolla 33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\n#&gt; Fiat X1-9      27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\n#&gt; Lotus Europa   30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\n#&gt; Volvo 142E     21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>rlang: Tidy evaluation</span>"
    ]
  },
  {
    "objectID": "03-rlang-tidyeval.html#the-data-mask-ambiguity",
    "href": "03-rlang-tidyeval.html#the-data-mask-ambiguity",
    "title": "28  rlang: Tidy evaluation",
    "section": "\n28.4 The data mask ambiguity",
    "text": "28.4 The data mask ambiguity\nThe convenience of data masking makes it possible to refer to both columns in data frames and objects in the user environment. However, this convenience introduces ambiguity.\nFor instance, which value of x is being referred to in the mutate() function. The problem occurs when you want to use an object from the user environment but there is a column with the same name.\n\ndf &lt;- data.frame(x = NA, y = 2)\nx &lt;- 100\n\ndf %&gt;% dplyr::mutate(y = y / x)\n#&gt;    x  y\n#&gt; 1 NA NA\n\nAnother issue occurs when you have a typo in a data-variable name or you were expecting a column that is missing and there is an object with that name in the user environment. In a data-masking context if a variable cannot be found in the data mask, R looks for variables in the surrounding environment.\n\ndf &lt;- data.frame(foo = \"right\")\nffo &lt;- \"wrong\"\n\ndf %&gt;% dplyr::mutate(foo = toupper(ffo))\n#&gt;     foo\n#&gt; 1 WRONG\n\n\n28.4.1 Preventing collisions\nThe .data and .env pronouns\nThe easiest solution to disambiguate between data-variables and environment-variables is to use the .data and .env pronouns.\n\ndf &lt;- data.frame(x = 1, y = 2)\nx &lt;- 100\n\ndf %&gt;% dplyr::mutate(y = .data$y / .env$x)\n#&gt;   x    y\n#&gt; 1 1 0.02\n\nThis is particularly useful when using named arguments with values in a function to avoid name conflicts with data frames. Use the .env pronoun for any environment variables scoped in the function to avoid hitting a masking column. The below example shows how the factor column is given preference over the argument factor in a data-masking context. The function is fixed through the .env pronoun.\n\ndf &lt;- data.frame(factor = 0, value = 1)\n\n# Without .env pronoun\nmy_rescale &lt;- function(data, var, factor = 10) {\n  data %&gt;% dplyr::mutate(\"{{ var }}\" := {{ var }} / factor)\n}\n\n# Oh no!\ndf %&gt;% my_rescale(value)\n#&gt;   factor value\n#&gt; 1      0   Inf\n\n# With .env pronoun to ensure factor argument is used\nmy_rescale &lt;- function(data, var, factor = 10) {\n  data %&gt;% dplyr::mutate(\"{{ var }}\" := {{ var }} / .env$factor)\n}\n\n# Yay!\ndata.frame(factor = 0, value = 1) %&gt;% my_rescale(value)\n#&gt;   factor value\n#&gt; 1      0   0.1\n\nSubsetting .data with env-variables\nThe use of .data[[var]] pattern to bridge from name to data mask is insulated from column name collisions. You can only subset the .data pronoun with environment variables not data variables. [[ works as an injection operator when applied to .data and so is evaluated before the data mask is created.\n\nvar &lt;- \"cyl\"\n\nmtcars2 &lt;- mtcars\nmtcars2$var &lt;- \"wrong\"\n\nmtcars2 %&gt;% dplyr::summarise(mean = mean(.data[[var]]))\n#&gt;     mean\n#&gt; 1 6.1875\n\nInjecting env-variables with !!\n\nAs noted above, injection operators modify a piece of code early in the evaluation process before any data-masking logic occurs. “If you inject the value of a variable, it becomes inlined in the expression. R no longer needs to look up any variable to find the value.”\nInjection with !! can be used to solve the same problem as using .data and .env pronouns, but the current advice is that it is preferable to use the pronouns instead of the injection operators.\n\ndf &lt;- data.frame(x = 1, y = 2)\nx &lt;- 100\n\n# .data and .env pronouns\ndf %&gt;% dplyr::mutate(y = .data$y / .env$x)\n#&gt;   x    y\n#&gt; 1 1 0.02\n\n# Injection\ndf %&gt;% dplyr::mutate(y = y / !!x)\n#&gt;   x    y\n#&gt; 1 1 0.02\n\nNo ambiguity in tidy selections\n“The selection language is designed in such a way that evaluation of expressions is either scoped in the data mask only, or in the environment only.” For instance, in the code below data is a symbol given to the selection operator :. It is scoped in the data mask only and, therefore, refers to the “data” column. ncol(data) is evaluated as normal R code. It is an environmental expression referring to the environmental variable of the data data frame.\n\ndata &lt;- data.frame(x = 1, data = 1:3)\n\ndata %&gt;% dplyr::select(data:ncol(data))\n#&gt;   data\n#&gt; 1    1\n#&gt; 2    2\n#&gt; 3    3",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>rlang: Tidy evaluation</span>"
    ]
  },
  {
    "objectID": "03-rlang-tidyeval.html#the-double-evaluation-problem",
    "href": "03-rlang-tidyeval.html#the-double-evaluation-problem",
    "title": "28  rlang: Tidy evaluation",
    "section": "\n28.5 The double evaluation problem",
    "text": "28.5 The double evaluation problem\nA problem with metaprogramming is that it introduces the ability to evaluate the same code multiple times when a piece of code is contained within a data-masking context that is evaluated in multiple places. For instance, a function that summarizes multiple functions on a single column has the potential to run twice if there is also a computation (mutate()-like functionality) on the column. The following function seems to work as expected.\n\nsummarise_stats &lt;- function(data, var) {\n  data %&gt;%\n    dplyr::summarise(\n      mean = mean({{ var }}),\n      sd = sd({{ var }})\n    )\n}\n\nsummarise_stats(mtcars, cyl)\n#&gt;     mean       sd\n#&gt; 1 6.1875 1.785922\n\nHowever, if a computation is added to var, that computation will be run on the var column for both the mean() and sd() calculations. Thus, if you multiply cyl by 100, that code is evaluated twice.\n\nsummarise_stats(mtcars, cyl * 100)\n#&gt;     mean       sd\n#&gt; 1 618.75 178.5922\n\nThe output is correct, but the code will take longer to evaluate. Below shows what is actually happening in the code because a defused expression is injected in two places. The caret signs represent quosure boundaries.\n\ndplyr::summarise(\n  mean = ^mean(^cyl * 100),\n  sd = ^sd(^cyl * 100)\n)\n\nWe can confirm this by creating a function with a side effect of printing some messages and running it on cyl.\n\ntimes100 &lt;- function(x) {\n  message(\"Takes a long time...\")\n  Sys.sleep(0.1)\n\n  message(\"And causes side effects such as messages!\")\n  x * 100\n}\n\nsummarise_stats(mtcars, times100(cyl))\n#&gt; Takes a long time...\n#&gt; And causes side effects such as messages!\n#&gt; Takes a long time...\n#&gt; And causes side effects such as messages!\n#&gt;     mean       sd\n#&gt; 1 618.75 178.5922\n\nThe issue of double evaluation can be fixed by ensuring that any computations on var are performed before the summarise() function. This can be done with mutate(.keep = \"none\").\n\nsummarise_stats &lt;- function(data, var) {\n  data %&gt;%\n    # Evaluate calculations on val\n    dplyr::mutate(var = {{ var }}, .keep = \"none\") %&gt;%\n    # Then summarise\n    dplyr::summarise(mean = mean(var),\n                    sd = sd(var))\n}\n\n# Now the defused input is only evaluated the one time in mutate\nsummarise_stats(mtcars, times100(cyl))\n#&gt; Takes a long time...\n#&gt; And causes side effects such as messages!\n#&gt;     mean       sd\n#&gt; 1 618.75 178.5922",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>rlang: Tidy evaluation</span>"
    ]
  },
  {
    "objectID": "03-rlang-tidyeval.html#what-happens-if-i-use-injection-operators-out-of-context",
    "href": "03-rlang-tidyeval.html#what-happens-if-i-use-injection-operators-out-of-context",
    "title": "28  rlang: Tidy evaluation",
    "section": "\n28.6 What happens if I use injection operators out of context?",
    "text": "28.6 What happens if I use injection operators out of context?\nInjection operators {{, !!, and !!! are parts of tidy evaluation and not part of base R. Therefore, they are special characters that should only be used in data-masked arguments powered by tidy eval. Outside of the context of tidy eval data masks they have different meaning.\n\n28.6.1 Using {{ out of context\nIn R { is like ( but takes multiple expressions instead of one. Wrapping an expression in multiple curly brackets does not do anything special.\n\n# Multiple expressions\nlist(\n  { message(\"foo\"); 2 }\n)\n#&gt; foo\n#&gt; [[1]]\n#&gt; [1] 2\n\n{{ 2 }}\n#&gt; [1] 2\n\nHere, the result is at worst a silent error. However, an error will occur if {{ is used in a base R data mask.\n\nmy_mean &lt;- function(data, var) {\n  with(data, mean({{ var }}))\n}\n\nmy_mean(mtcars, cyl)\n#&gt; Error in eval(expr, envir, enclos): object 'cyl' not found\n\n\n28.6.2 Using !! and !!! out of context\n!! and !!! are interpreted as double and triple negation in regular R code.\n\n!! TRUE\n#&gt; [1] TRUE\n!!! TRUE\n#&gt; [1] FALSE",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>28</span>  <span class='chapter-title'>rlang: Tidy evaluation</span>"
    ]
  },
  {
    "objectID": "03-rlang-metaprogramming.html",
    "href": "03-rlang-metaprogramming.html",
    "title": "29  rlang: Metaprogramming",
    "section": "",
    "text": "29.1 rlang metaprogramming vignettes\nlibrary(rlang)\nlibrary(dplyr)",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>rlang: Metaprogramming</span>"
    ]
  },
  {
    "objectID": "03-rlang-metaprogramming.html#rlang-metaprogramming-vignettes",
    "href": "03-rlang-metaprogramming.html#rlang-metaprogramming-vignettes",
    "title": "29  rlang: Metaprogramming",
    "section": "",
    "text": "Defusing R expressions\nInjecting with !!, !!!, and glue syntax\nMetaprogramming patterns\nWhat are quosures and when are they needed?",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>rlang: Metaprogramming</span>"
    ]
  },
  {
    "objectID": "03-rlang-metaprogramming.html#defusing-r-expressions",
    "href": "03-rlang-metaprogramming.html#defusing-r-expressions",
    "title": "29  rlang: Metaprogramming",
    "section": "\n29.2 Defusing R expressions",
    "text": "29.2 Defusing R expressions\nDefusing is the act of capturing code and returning an expression in a tree-like structure that provides a recipe for how to compute the value.\nDefuse your own R expressions with expr(); defuse expressions supplied by the user of a function you write with enquo() or enquos(); and evaluate it with eval() or eval_tidy().\n\n# Return the result of `1 + 1`\n1 + 1\n#&gt; [1] 2\n\n# Defuse the code and return the expression `1 + 1`\nexpr(1 + 1)\n#&gt; 1 + 1\n\n# Evaluate the defused code and return the result\neval(expr(1 + 1))\n#&gt; [1] 2\n\n“The most common use case for defusing expressions is to resume its evaluation in a data mask. This makes it possible for the expression to refer to columns of a data frame as if they were regular objects.”\n\ne &lt;- expr(mean(cyl))\neval(e, mtcars)\n#&gt; [1] 6.1875\n\n\n29.2.1 The booby trap analogy\nWith lazy evaluations arguments are like booby traps. They are only evaluated when touched. “Defusing an argument can be seen as defusing the booby trap.” The argument is captured rather than evaluated, rather than setting off the booby trap.\n\n29.2.2 Types of defused expressions\nThere are three basic types of defused expressions. See Wickham, Advanced R, Chapter 18: Expressions for more details.\n\nCalls: calling a function\nSymbols: named objects\n\nEnvironment-variable: object defined in the global environment or a function.\nData-variable: object is a column in a data frame.\n\n\nConstants: Either NULL or an atomic vector of length 1.\n\n\n# 1. Create a call representing the computation of the mean of `foo`\nexpr(mean(foo, na.rm = TRUE))\n#&gt; mean(foo, na.rm = TRUE)\n\n# 2. Create a symbol representing objects called `foo`\nexpr(foo)\n#&gt; foo\n\n# 3. Return a constant\nexpr(1)\n#&gt; [1] 1\n\nAnother way to create defused expressions is to assemble them from data.\n\n# Assemble a symbol from a string\nvar &lt;- \"foo\"\nsym(var)\n#&gt; foo\n\n# Assemble a call from strings, symbols, and constants\ncall(\"mean\", sym(var), na.rm = TRUE)\n#&gt; mean(foo, na.rm = TRUE)\n\n\n29.2.3 Defuse and inject\nThe defuse and inject pattern is to defuse an argument and inject the expression into another function in the context of a data mask. This can be done in two steps with enquo() and !! or in a single defuse-and-inject step with the embrace operator {{. The two-step process can be useful in more complex settings where you need access to the defused expression rather than just passing it on.\n\n# Defuse-and-inject: two steps\nmy_summarise2 &lt;- function(data, arg) {\n  # Defuse the user expression in `arg`\n  arg &lt;- enquo(arg)\n\n  # Inject the expression contained in `arg`\n  # inside a `summarise()` argument\n  data |&gt; \n    dplyr::summarise(mean = mean(!!arg, na.rm = TRUE))\n}\n\n# Defuse and inject in a single step with the embracing operator\nmy_summarise1 &lt;- function(data, arg) {\n  data |&gt; \n    dplyr::summarise(mean = mean({{ arg }}, na.rm = TRUE))\n}\n\n\n29.2.4 Defused arguments and quosures\nexpr() returns a defused expression, while enquo() returns a quosure, an expression along with an environment. See Section 29.5.",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>rlang: Metaprogramming</span>"
    ]
  },
  {
    "objectID": "03-rlang-metaprogramming.html#sec-injecing",
    "href": "03-rlang-metaprogramming.html#sec-injecing",
    "title": "29  rlang: Metaprogramming",
    "section": "\n29.3 Injecting with !!, !!!, and glue syntax",
    "text": "29.3 Injecting with !!, !!!, and glue syntax\nThere are two main families of injection operators that are used to modify code before R processes it:\n\n\nDynamic dots operators: !!! and \"{\"\n\nMetaprogramming operators: !!, splicing with !!!, {{, and“{{”`\n\n\n29.3.1 Dots injection\nDynamic dots make ... programmable with injection operators.\nSplicing with !!!\n\nYou can use list2() to turn ... into dynamic dots. For instance, to turn a list into a set of arguments taken in by ... in base R you can use do.call(), but if you use list2() within the do.call() call, you can splice this list of arguments with !!!.\n\n# Create an rbind function that takes dynamic dots\nrbind2 &lt;- function(...) {\n  do.call(\"rbind\", list2(...))\n}\n\nrows &lt;- list(a = 1:2, b = 3:4)\nrbind2(!!!rows, c = 5:6)\n#&gt;   [,1] [,2]\n#&gt; a    1    2\n#&gt; b    3    4\n#&gt; c    5    6\n\nInjecting names with “{”\nDynamic dots also allows you to use an argument name that is stored in a variable. In the case of rbind2() this makes it possible to use a variable to name the row.\n\nname &lt;- \"foo\"\n\nrbind2(\"{name}\" := 1:2, bar = 3:4)\n#&gt;     [,1] [,2]\n#&gt; foo    1    2\n#&gt; bar    3    4\n\nrbind2(\"prefix_{name}\" := 1:2, bar = 3:4)\n#&gt;            [,1] [,2]\n#&gt; prefix_foo    1    2\n#&gt; bar           3    4\n\n\n29.3.2 Metaprogramming injection\nEmbracing with {{\n\nThe embracing operator is made for dealing with function arguments. “It defuses the expression supplied as argument and immediately injects it in place.” The evaluation usually takes place in the context of a data mask.\nInjecting with !!\n\n!! is meant to inject a single object in place. For example, it can inject a data-symbol object stored in an environment variable into a data-masking context to ensure that it is evaluated.\n\nvar &lt;- data_sym(\"disp\")\n\nmtcars %&gt;%\n  dplyr::summarise(avg = mean(!!var, na.rm = TRUE))\n#&gt;        avg\n#&gt; 1 230.7219\n\nSplicing with !!!\n\nThe splice operator !!! can be used in data-masking contexts and inside inject(). For example, rbind2() could be rewritten with inject() so that the function can also use the splice operator and no longer needs do.call().\n\nrbind2 &lt;- function(...) {\n  inject(rbind(!!!list2(...)))\n}\nrbind2(!!!rows, c = 5:6)\n#&gt;   [,1] [,2]\n#&gt; a    1    2\n#&gt; b    3    4\n#&gt; c    5    6",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>rlang: Metaprogramming</span>"
    ]
  },
  {
    "objectID": "03-rlang-metaprogramming.html#metaprogramming-patterns",
    "href": "03-rlang-metaprogramming.html#metaprogramming-patterns",
    "title": "29  rlang: Metaprogramming",
    "section": "\n29.4 Metaprogramming patterns",
    "text": "29.4 Metaprogramming patterns\nThis vignette is meant to present more theoretical and advanced patterns than those discussed in Data mask programming patterns.\n\n29.4.1 Forwarding patterns\nDefuse and inject\nThe defuse and inject pattern can be done in wither one or two steps. Using the embracing operator and passing the dots is the simpler form. However, sometimes you might want to inspect or modify the expression before injecting them in the target context. This is made possible by the two-step patterns of enquo() and !! or enquos() and !!!.\n\n\n{{ is the combination of enquo() and !!.\nPassing ... is equivalent to the combination of enquos() and !!!.\n\n\nmy_summarise &lt;- function(data, var) {\n  data %&gt;% dplyr::summarise({{ var }})\n}\nmy_summarise &lt;- function(data, var) {\n  data %&gt;% dplyr::summarise(!!enquo(var))\n}\n\nmy_group_by &lt;- function(.data, ...) {\n  .data %&gt;% dplyr::group_by(...)\n}\nmy_group_by &lt;- function(.data, ...) {\n  .data %&gt;% dplyr::group_by(!!!enquos(...))\n}\n\nInspecting input labels\nUse of as_label() or englue() to create an automatic name for one or more defused arguments.\n\n# as_label()\nf &lt;- function(var) {\n  var &lt;- enquo(var)\n  as_label(var)\n}\n\n# englue()\nf2 &lt;- function(var) {\n  englue(\"{{ var }}\")\n}\n\nf(cyl)\n#&gt; [1] \"cyl\"\n\nf2(1 + 1)\n#&gt; [1] \"1 + 1\"\n\nWith multiple arguments you can use enquos() and set the .name argument to TRUE to automatically call as_label() on the inputs, though the user can also provide names.\n\ng &lt;- function(...) {\n  vars &lt;- enquos(..., .named = TRUE)\n  names(vars)\n}\n\n# automatic names with as_label\ng(cyl, 1 + 1)\n#&gt; [1] \"cyl\"   \"1 + 1\"\n\n# user provided names\ng(x = cyl, y = 1 + 1)\n#&gt; [1] \"x\" \"y\"\n\n\n29.4.2 Names patterns: Symbolize and inject\nYou can use a symbolize and inject pattern when across(all_of()) is not supported. In this pattern defused expressions are created that refer to column names that are then injected into a data-mask context.\nYou can cast a string to a symbol with sym() and syms() to return simple symbols or data_sym() and data_syms() that return calls to $ to subset the .data pronoun. The later functions can only be used in a tidy eval context.\n\nvar &lt;- \"cyl\"\nvars &lt;- c(\"cyl\", \"am\")\n\nsym(var)\n#&gt; cyl\nsyms(vars)\n#&gt; [[1]]\n#&gt; cyl\n#&gt; \n#&gt; [[2]]\n#&gt; am\n\ndata_sym(var)\n#&gt; .data$cyl\ndata_syms(vars)\n#&gt; [[1]]\n#&gt; .data$cyl\n#&gt; \n#&gt; [[2]]\n#&gt; .data$am\n\nThis pattern can be used to create a group_by() variant that takes a vector of names that is captured by data_syms() and then injected with the splice operator !!!.\n\nmy_group_by &lt;- function(data, vars) {\n  data %&gt;% dplyr::group_by(!!!data_syms(vars))\n}\n\nmtcars %&gt;% my_group_by(vars)\n#&gt; # A tibble: 32 × 11\n#&gt; # Groups:   cyl, am [6]\n#&gt;      mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n#&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n#&gt;  1  21       6  160    110  3.9   2.62  16.5     0     1     4     4\n#&gt;  2  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n#&gt;  3  22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n#&gt;  4  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n#&gt;  5  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n#&gt;  6  18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n#&gt;  7  14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n#&gt;  8  24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n#&gt;  9  22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n#&gt; 10  19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n#&gt; # ℹ 22 more rows\n\n\n29.4.3 Bridge patterns\nmutate() as a data-mask to selection bridge that accomplishes the same task as in Data masking patterns - Bridge patterns but using enquos() to defuse and inspect the names.\n\nmy_pivot_longer &lt;- function(data, ...) {\n  # Defuse the dots and inspect the names\n  dots &lt;- enquos(..., .named = TRUE)\n  names &lt;- names(dots)\n\n  # Pass the inputs to `mutate()`\n  data &lt;- data %&gt;% dplyr::mutate(!!!dots)\n\n  # Select `...` inputs by name with `all_of()`\n  data %&gt;%\n    tidyr::pivot_longer(cols = all_of(names))\n}\n\nmtcars %&gt;% my_pivot_longer(cyl, am = am * 100)\n#&gt; # A tibble: 64 × 11\n#&gt;      mpg  disp    hp  drat    wt  qsec    vs  gear  carb name  value\n#&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt;\n#&gt;  1  21     160   110  3.9   2.62  16.5     0     4     4 cyl       6\n#&gt;  2  21     160   110  3.9   2.62  16.5     0     4     4 am      100\n#&gt;  3  21     160   110  3.9   2.88  17.0     0     4     4 cyl       6\n#&gt;  4  21     160   110  3.9   2.88  17.0     0     4     4 am      100\n#&gt;  5  22.8   108    93  3.85  2.32  18.6     1     4     1 cyl       4\n#&gt;  6  22.8   108    93  3.85  2.32  18.6     1     4     1 am      100\n#&gt;  7  21.4   258   110  3.08  3.22  19.4     1     3     1 cyl       6\n#&gt;  8  21.4   258   110  3.08  3.22  19.4     1     3     1 am        0\n#&gt;  9  18.7   360   175  3.15  3.44  17.0     0     3     2 cyl       8\n#&gt; 10  18.7   360   175  3.15  3.44  17.0     0     3     2 am        0\n#&gt; # ℹ 54 more rows\n\n\n29.4.4 Transformation patterns\nIt is also possible to recreate my_mean() from Data masking patterns - Transformation patterns. “The pattern consists in defusing the input expression, building larger calls around them, and finally inject the modified expressions inside the data-masking functions.” With ... to take in multiple arguments, you need to use purrr::map() to loop over the arguments to construct the call.\n\nmy_mean &lt;- function(.data, ...) {\n  # Defuse the dots. Make sure they are automatically named.\n  vars &lt;- enquos(..., .named = TRUE)\n\n  # Map over each defused expression and wrap it in a call to `mean()`\n  vars &lt;- purrr::map(vars, ~ expr(mean(!!.x, na.rm = TRUE)))\n\n  # Inject the expressions\n  .data %&gt;% dplyr::summarise(!!!vars)\n}\n\nmtcars %&gt;% my_mean(cyl, mpg)\n#&gt;      cyl      mpg\n#&gt; 1 6.1875 20.09062\n\nThe difference with the previous version of my_mean() is that the function does not inherit tidy selection helpers and syntax. However, it does gain the ability to create new vectors on the fly as in summarise().\n\nmtcars %&gt;% my_mean(cyl = cyl * 100, mpg)\n#&gt;      cyl      mpg\n#&gt; 1 618.75 20.09062",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>rlang: Metaprogramming</span>"
    ]
  },
  {
    "objectID": "03-rlang-metaprogramming.html#sec-quosures",
    "href": "03-rlang-metaprogramming.html#sec-quosures",
    "title": "29  rlang: Metaprogramming",
    "section": "\n29.5 What are quosures and when are they needed?",
    "text": "29.5 What are quosures and when are they needed?\nA quosure is a special type of defused expression that keeps track of the original context in which the expression was written. The ability to keep track of the original context helps to interface multiple data-masking functions that might come from two unrelated environments, like two different packages.\n\n29.5.1 Blending environments\nExample of a function call that uses a function from a package that uses another function from another package, which, in turn, is built on data-masking functions in dplyr. This creates a number of different contexts or environments in which the code needs to pass through to be evaluated. The role of quosures is to ensure that each variable is evaluated in the correct context.\n\n# Function call\ndplyr::starwars %&gt;%\n  foo::summarise_bmi(mass, div100(height))\n\n# Context 1: global environment of user\ndiv100 &lt;- function(x) {\n  x / 100\n}\n\n# Context 2: foo package\nbmi &lt;- function(mass, height) {\n  mass / height^2\n}\n\nsummarise_bmi &lt;- function(data, mass, height) {\n  data %&gt;%\n    bar::summarise_stats(bmi({{ mass }}, {{ height }}))\n}\n\n# Context 3: bar package\ncheck_numeric &lt;- function(x) {\n  stopifnot(is.numeric(x))\n  x\n}\n\nsummarise_stats &lt;- function(data, var) {\n  # Context 4: dplyr package\n  data %&gt;%\n    dplyr::transmute(\n      var = check_numeric({{ var }})\n    ) %&gt;%\n    dplyr::summarise(\n      mean = mean(var, na.rm = TRUE),\n      sd = sd(var, na.rm = TRUE)\n    )\n}\n\n# Final expression with quosures identified by ^\ndplyr::transmute(\n  var = ^check_numeric(^bmi(^mass, ^div100(height)))\n)\n\n\n29.5.2 When should I create quosures?\n{{ and dynamic dots create quosures for you, and so tidy eval documentation has moved away from directly discussing quosures.\nAs a rule of thumb, quosures are only needed for defused arguments that come from another environment (often the user environment) not your own. Any local expressions created within a function do not need quosures because there is no exchange of environment. Thus, local expressions can be created with expr(), which do not carry an environment and so are not quosures. These expressions can be evaluated with either !! or eval()/eval_tidy().\n\nmy_mean &lt;- function(data, var) {\n  # `expr()` is sufficient\n  expr &lt;- expr(mean({{ var }}))\n  dplyr::summarise(data, !!expr)\n}\nmy_mean(mtcars, cyl)\n#&gt;   mean(cyl)\n#&gt; 1    6.1875\n\nmy_mean &lt;- function(data, var) {\n  expr &lt;- expr(mean({{ var }}))\n  eval_tidy(expr, data)\n}\nmy_mean(mtcars, cyl)\n#&gt; [1] 6.1875\n\n\n29.5.3 Technical description of quosures\n\nQuosures are made up of an expression and an environment.\nQuosures are:\n\nCallable: evaluation produces a result\nHygienic: evaluated in the tracked environment\nMaskable: can be evaluated in a data mask such that the mask comes first in scope before the quosure environment.",
    "crumbs": [
      "tidy eval",
      "<span class='chapter-number'>29</span>  <span class='chapter-title'>rlang: Metaprogramming</span>"
    ]
  },
  {
    "objectID": "readr-data.html",
    "href": "readr-data.html",
    "title": "Appendix A — readr example data",
    "section": "",
    "text": "Column type specifications",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>readr example data</span>"
    ]
  },
  {
    "objectID": "readr-data.html#sec-key",
    "href": "readr-data.html#sec-key",
    "title": "Appendix A — readr example data",
    "section": "",
    "text": "a: character\nb: character with NAs as blank character and “NA”\nc: double\nd: logical\ne: factor with optional NA with “none”\nf: integer\ng: number\nh: date: “20230316”\ni: date in locale: “2023-03-16”\nj: date: 16 March 2023\nk: date: Mar 16 2023\nl: time\nm: datetime in locale: “2023-03-16 11:38”\n\nWrite the data frame to data/\n\n\nwrite.csv(df, \"data/readr-example.csv\", row.names = FALSE)",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>readr example data</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "McNamara, Amelia, and Nicholas J Horton. 2017. “Wrangling\nCategorical Data in R.” https://doi.org/10.7287/peerj.preprints.3163v2.\n\n\nWickham, Hadley. 2014. “Tidy Data.”\nJournal of Statistical Software 59 (10). https://doi.org/10.18637/jss.v059.i10.\n\n\n———. 2016. Ggplot2: Elegant Graphics for Data\nAnalysis. Second Edition. Use R! New\nYork: Springer. https://doi.org/10.1007/978-3-319-24277-4.\n\n\n———. 2019. Advanced R. Second Edition. Boca\nRaton: CRC Press.\n\n\nZeileis, Achim, and Paul Murrell. 2023. “Coloring in\nR’s Blind Spot.” arXiv. https://arxiv.org/abs/2303.04918.",
    "crumbs": [
      "Appendices",
      "References"
    ]
  }
]